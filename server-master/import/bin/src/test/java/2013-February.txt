From htejun@gmail.com Thu Jan 31 19:18:54 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r110Ir1K030334 for <cluster-devel@listman.util.phx.redhat.com>;
	Thu, 31 Jan 2013 19:18:53 -0500
Received: from mx1.redhat.com (ext-mx15.extmail.prod.ext.phx2.redhat.com
	[10.5.110.20])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r110IrHi026286; Thu, 31 Jan 2013 19:18:53 -0500
Received: from mail-qe0-f49.google.com (mail-qe0-f49.google.com
	[209.85.128.49])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r110Iq3H003346;
	Thu, 31 Jan 2013 19:18:52 -0500
Received: by mail-qe0-f49.google.com with SMTP id 5so1560643qea.22
	for <multiple recipients>; Thu, 31 Jan 2013 16:18:52 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:sender:date:from:to:cc:subject:message-id:references
	:mime-version:content-type:content-disposition:in-reply-to
	:user-agent; bh=JeLv6uoUSoxnPlTHyqx/Elmh5Ztbrd5INRfLT7TweHk=;
	b=h01kiXgADwnSsWPr3D5MPQqvqIhvVBUurn+bDXGVAkp+2/mIYic2SA7ocIpjVlq4Dt
	tr4ux8gFUOyPgmpJPcs1CbgCxcGWBLSrfW6f+KM9l55O2ztHqQ8AKNOAdA+92s+dwkeP
	+/GDbar6RUu5Fki2qJy9Mw52CT4vmDZCOaPpcf2VmHa+OYw8ODUQmj6XfM+UpBFC4Ufe
	0ghHCMP77uIcIfE663TVVqCwsFKobBex6bXAbt9K+oUfz/Ch7P+tuvW38NWePp/tSUG9
	C9UZKFvvmVsYMCFQ6Yj8wY8QBG8HD8z5/PQdePAy2fYImmy5VqfYZp1/BjHj/gORHbDH
	nNoQ==
X-Received: by 10.49.96.234 with SMTP id dv10mr12375283qeb.48.1359677932200;
	Thu, 31 Jan 2013 16:18:52 -0800 (PST)
Received: from mtj.dyndns.org (nat-pool-3-rdu.redhat.com. [66.187.233.203])
	by mx.google.com with ESMTPS id 8sm5371864qed.6.2013.01.31.16.18.49
	(version=TLSv1 cipher=RC4-SHA bits=128/128);
	Thu, 31 Jan 2013 16:18:51 -0800 (PST)
Sender: Tejun Heo <htejun@gmail.com>
Date: Thu, 31 Jan 2013 16:18:41 -0800
From: Tejun Heo <tj@kernel.org>
To: David Teigland <teigland@redhat.com>
Message-ID: <20130201001841.GP6824@mtj.dyndns.org>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20130131235320.GN6824@mtj.dyndns.org>
User-Agent: Mutt/1.5.21 (2010-09-15)
X-RedHat-Spam-Score: -3  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	FREEMAIL_FROM, RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.20
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Fri, 01 Feb 2013 04:28:16 -0500
Cc: cluster-devel@redhat.com, akpm@linux-foundation.org, rusty@rustcorp.com.au,
	linux-kernel@vger.kernel.org
Subject: Re: [Cluster-devel] [PATCH 10/14] dlm: don't use idr_remove_all()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 01 Feb 2013 00:18:55 -0000

Hello, David.

On Thu, Jan 31, 2013 at 03:53:20PM -0800, Tejun Heo wrote:
> The function description is misleading.  The function does search
> inclusive range and needs explicit cursor increment to make progress.
> Weird that it doesn't work.  Looking into it.  I'll write when I know
> more.

It looks a bit weird to me that ls->ls_recover_list_count is also
incremented by recover_list_add().  The two code paths don't seem to
be interlocke at least upon my very shallow glance.  Is it that only
either the list or idr is in use?

Anyways, can you please apply the following patch and see which IDs
are leaking from the iteration?  The patch too is only compile tested
so I might have done something stupid but it hopefully shouldn't be
too difficult to make it work.

Thanks!
---
 fs/dlm/recover.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

--- a/fs/dlm/recover.c
+++ b/fs/dlm/recover.c
@@ -351,6 +351,12 @@ static struct dlm_rsb *recover_idr_find(
 	return r;
 }
 
+static int dlm_dump_idr(int id, void *p, void *data)
+{
+	pr_cont(" %d", id);
+	return 0;
+}
+
 static void recover_idr_clear(struct dlm_ls *ls)
 {
 	struct dlm_rsb *r;
@@ -358,7 +364,9 @@ static void recover_idr_clear(struct dlm
 
 	spin_lock(&ls->ls_recover_idr_lock);
 
+	pr_info("XXX clearing:");
 	idr_for_each_entry(&ls->ls_recover_idr, r, id) {
+		pr_cont(" %d", id);
 		idr_remove(&ls->ls_recover_idr, id);
 		r->res_id = 0;
 		r->res_recover_locks_count = 0;
@@ -366,10 +374,14 @@ static void recover_idr_clear(struct dlm
 
 		dlm_put_rsb(r);
 	}
+	pr_cont("\n");
 
 	if (ls->ls_recover_list_count != 0) {
 		log_error(ls, "warning: recover_list_count %d",
 			  ls->ls_recover_list_count);
+		pr_info("XXX leftovers: ");
+		idr_for_each(&ls->ls_recover_idr, dlm_dump_idr, NULL);
+		pr_cont("\n");
 		ls->ls_recover_list_count = 0;
 	}
 	spin_unlock(&ls->ls_recover_idr_lock);


From rpeterso@redhat.com Fri Feb  1 12:03:03 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r11H33Of026207 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 1 Feb 2013 12:03:03 -0500
Received: from mx3-phx2.redhat.com (mx01.colomx.prod.int.phx2.redhat.com
	[10.5.7.1])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r11H32Ol021029
	for <cluster-devel@redhat.com>; Fri, 1 Feb 2013 12:03:03 -0500
Received: from zmail12.collab.prod.int.phx2.redhat.com
	(zmail12.collab.prod.int.phx2.redhat.com [10.5.83.14])
	by mx3-phx2.redhat.com (8.13.8/8.13.8) with ESMTP id r11H32Qk016029
	for <cluster-devel@redhat.com>; Fri, 1 Feb 2013 12:03:02 -0500
Date: Fri, 1 Feb 2013 12:03:02 -0500 (EST)
From: Bob Peterson <rpeterso@redhat.com>
To: cluster-devel@redhat.com
Message-ID: <1847869626.18286471.1359738182937.JavaMail.root@redhat.com>
In-Reply-To: <60871952.18277548.1359737783438.JavaMail.root@redhat.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.3.112.25]
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [GFS2 PATCH] GFS2: Get a block reservation before
	resizing a file
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 01 Feb 2013 17:03:03 -0000

Hi,

This patch allocates a block reservation structure before growing 
or shrinking a file. Without this structure, the grow or shink code
can reference the bad pointer.

Regards,

Bob Peterson
Red Hat File Systems

Signed-off-by: Bob Peterson <rpeterso@redhat.com> 
---
 fs/gfs2/bmap.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index d29d779..df686d1 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -1288,6 +1288,10 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 
 	inode_dio_wait(inode);
 
+	ret = gfs2_rs_alloc(GFS2_I(inode));
+	if (ret)
+		return ret;
+
 	oldsize = inode->i_size;
 	if (newsize >= oldsize)
 		return do_grow(inode, newsize);


From teigland@redhat.com Fri Feb  1 12:44:46 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r11Hikxk016169 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 1 Feb 2013 12:44:46 -0500
Received: from redhat.com (s01.msp.redhat.com [10.15.95.15])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r11HihTP008789
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES128-SHA bits=128 verify=NO);
	Fri, 1 Feb 2013 12:44:45 -0500
Date: Fri, 1 Feb 2013 12:44:43 -0500
From: David Teigland <teigland@redhat.com>
To: Tejun Heo <tj@kernel.org>
Message-ID: <20130201174443.GC3812@redhat.com>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20130201001841.GP6824@mtj.dyndns.org>
User-Agent: Mutt/1.5.20 (2009-12-10)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com, akpm@linux-foundation.org, rusty@rustcorp.com.au,
	linux-kernel@vger.kernel.org
Subject: Re: [Cluster-devel] [PATCH 10/14] dlm: don't use idr_remove_all()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 01 Feb 2013 17:44:46 -0000

On Thu, Jan 31, 2013 at 04:18:41PM -0800, Tejun Heo wrote:
> It looks a bit weird to me that ls->ls_recover_list_count is also
> incremented by recover_list_add().  The two code paths don't seem to
> be interlocke at least upon my very shallow glance.  Is it that only
> either the list or idr is in use?

Yes, that's correct.

> Anyways, can you please apply the following patch and see which IDs
> are leaking from the iteration?  The patch too is only compile tested
> so I might have done something stupid but it hopefully shouldn't be
> too difficult to make it work.

I'm trying your patch now, I don't have a test optimized to hit this code
so it may take a while.

>  static void recover_idr_clear(struct dlm_ls *ls)
>  {
>  	struct dlm_rsb *r;
> @@ -358,7 +364,9 @@ static void recover_idr_clear(struct dlm
>  
>  	spin_lock(&ls->ls_recover_idr_lock);
>  
> +	pr_info("XXX clearing:");
>  	idr_for_each_entry(&ls->ls_recover_idr, r, id) {
> +		pr_cont(" %d", id);

It will often be clearing hundreds of thousands of entries, so this will
probably be excessive.

>  	if (ls->ls_recover_list_count != 0) {
>  		log_error(ls, "warning: recover_list_count %d",
>  			  ls->ls_recover_list_count);
> +		pr_info("XXX leftovers: ");
> +		idr_for_each(&ls->ls_recover_idr, dlm_dump_idr, NULL);
> +		pr_cont("\n");

I already tried my own version of this, but used idr_for_each_entry a
second time.  Unfortunately, the number it found and printed did not match
recover_list_count.

warning: recover_list_count 566

It printed 304 ids:

41218 41222 41223 41224 41226 41228 41229 41230 41231 41232 41234 41235
41236 41237 41239 41241 41242 41243 41244 41245 41246 41249 41252 41253
41254 41255 41256 41257 41259 41260 41261 41263 41264 41266 41271 41272
41273 41274 41277 41278 41475 41480 41483 41524 41525 41526 41655 41731
41741 41745 41749 41767 41768 41769 41772 41773 41782 42113 42114 42115
42121 42122 42124 42128 42132 42136 42138 42139 42141 42165 42375 42381
42385 42388 42390 42392 42399 42401 42404 42407 42409 42411 42416 42422
42694 42699 42712 42717 42727 42866 43009 43042 43044 43046 43049 43051
43058 43059 43064 43065 43066 43067 43330 43332 43337 43338 43339 43343
43348 43349 43351 43354 43355 43356 43361 43362 43368 43369 43370 43375
43376 43377 43378 43379 43381 43575 43576 43577 43677 43678 43680 43683
43684 43685 43689 43690 43819 43820 43823 43824 43825 43826 43827 43828
43829 43831 43905 43907 43908 43912 43929 43930 43955 43956 43960 43962
43965 44288 44289 44291 44296 44298 44300 44310 44311 44313 44314 44316
44318 44321 44323 44325 44454 44456 44457 44458 44544 44547 44548 44550
44555 44557 44560 44562 44564 44567 44573 44575 44576 44578 44579 44581
44582 44583 44584 44585 44589 44592 44595 44596 44726 44728 44729 44732
44734 44866 44867 44873 44876 44878 44879 44912 44914 44916 44920 44923
44924 45053 45186 45189 45190 45195 45197 45199 45200 45201 45203 45204
45208 45209 45212 45213 45216 45220 45223 45224 45225 45227 45228 45231
45234 45440 45441 45444 45448 45450 45452 45454 45456 45457 45458 45459
45460 45461 45464 45466 45467 45472 45475 45477 45484 45485 45488 45492
45494 45495 45496 45497 45498 45499 45628 45630 45698 45699 45700 45703
45707 45708 45710 45713 45715 45717 45720 45722 45723 45724 45725 45727
45729 45730 45731 45733 45734 45737 45739 45741 45742 45746 45748 45750
45755 47292 47293 47294


From htejun@gmail.com Fri Feb  1 13:55:39 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r11ItcGN013949 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 1 Feb 2013 13:55:38 -0500
Received: from mx1.redhat.com (ext-mx16.extmail.prod.ext.phx2.redhat.com
	[10.5.110.21])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r11Itb3E027423; Fri, 1 Feb 2013 13:55:38 -0500
Received: from mail-qe0-f52.google.com (mail-qe0-f52.google.com
	[209.85.128.52])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r11I0YDj003118;
	Fri, 1 Feb 2013 13:00:41 -0500
Received: by mail-qe0-f52.google.com with SMTP id 6so1986345qeb.11
	for <multiple recipients>; Fri, 01 Feb 2013 10:00:34 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:sender:date:from:to:cc:subject:message-id:references
	:mime-version:content-type:content-disposition:in-reply-to
	:user-agent; bh=Fv7RHh65LWifNNh2iNNzO7W+5S3o8XhM5R4ckUlJSy0=;
	b=ydERhfPIFBr0GeQ6c3CNd0U+yU99dJ5pKxTfTbsYhH/aZdDfh2Ojx3tmmDKdYDUufq
	ZXGnIHa1yp4nQmH5TDkv5v13PQ7bT0txmgZD/vCSbk+gMn2Yrwtuvm4jWEEn1pVg3laO
	kw8WFjJPxxgG+qHKqDSfAJNGMFyVd669N2B2SpBrYNlEzTazpFjFxGgrWilqyXfiJNae
	tyqdaMAzFcjKat1rF2mBqGD5/HVJChfvJZX2AW26XvfP5nkZMG8sTjySCX9NWaxLLyR5
	y/WUlo6OfPH5M6GVO+EpLGf2E+alOGuu1umDx+NDP1vmfxWI7dmr+MineVcUVAYif4FD
	10lQ==
X-Received: by 10.224.72.134 with SMTP id m6mr4387601qaj.42.1359741634280;
	Fri, 01 Feb 2013 10:00:34 -0800 (PST)
Received: from mtj.dyndns.org (nat-pool-3-rdu.redhat.com. [66.187.233.203])
	by mx.google.com with ESMTPS id f7sm7713442qap.13.2013.02.01.10.00.32
	(version=TLSv1 cipher=RC4-SHA bits=128/128);
	Fri, 01 Feb 2013 10:00:33 -0800 (PST)
Sender: Tejun Heo <htejun@gmail.com>
Date: Fri, 1 Feb 2013 10:00:28 -0800
From: Tejun Heo <tj@kernel.org>
To: David Teigland <teigland@redhat.com>
Message-ID: <20130201180028.GC31863@mtj.dyndns.org>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20130201174443.GC3812@redhat.com>
User-Agent: Mutt/1.5.21 (2010-09-15)
X-RedHat-Spam-Score: -3  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	FREEMAIL_FROM, RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.21
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com, akpm@linux-foundation.org, rusty@rustcorp.com.au,
	linux-kernel@vger.kernel.org
Subject: Re: [Cluster-devel] [PATCH 10/14] dlm: don't use idr_remove_all()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 01 Feb 2013 18:55:39 -0000

Hello, David.

On Fri, Feb 01, 2013 at 12:44:43PM -0500, David Teigland wrote:
> I already tried my own version of this, but used idr_for_each_entry a
> second time.  Unfortunately, the number it found and printed did not match
> recover_list_count.
> 
> warning: recover_list_count 566
> 
> It printed 304 ids:

Heh, that's really weird.  Maybe idr_get_next() is buggy above certain
number or at certain boundaries?  If you find something, please let me
know.  I'll see if I can reproduce it in some minimal way.

Thanks!

-- 
tejun


From swhiteho@redhat.com Fri Feb  1 15:58:34 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r11KwYfR007897 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 1 Feb 2013 15:58:34 -0500
Received: from [10.10.63.60] (vpn-63-60.rdu2.redhat.com [10.10.63.60])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r11KwX03007995
	for <cluster-devel@redhat.com>; Fri, 1 Feb 2013 15:58:34 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Fri, 01 Feb 2013 20:57:19 +0000
Message-ID: <1359752239.2714.79.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] GFS2: Split glock lru processing into two parts
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 01 Feb 2013 20:58:34 -0000


The intent here is to split the processing of the glock lru
list into two parts, so that the selection of glocks and the
disposal are separate functions. The plan is then, that further
updates can then be made to these functions in the future
to improve the selection of glocks and also the efficiency of
glock disposal.

The new feature which this patch brings is sorting the
glocks to be disposed of into glock number (and thus also
disk block number) order. Not all glocks will need i/o in
order to dispose of them, but some will, and at least we'll
generate mostly disk block order i/o now.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 3ad8fd3..cf35155 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -30,6 +30,7 @@
 #include <linux/rculist_bl.h>
 #include <linux/bit_spinlock.h>
 #include <linux/percpu.h>
+#include <linux/list_sort.h>
 
 #include "gfs2.h"
 #include "incore.h"
@@ -1376,50 +1377,93 @@ void gfs2_glock_complete(struct gfs2_glock *gl, int ret)
 		gfs2_glock_put(gl);
 }
 
+static int glock_cmp(void *priv, struct list_head *a, struct list_head *b)
+{
+	struct gfs2_glock *gla, *glb;
+
+	gla = list_entry(a, struct gfs2_glock, gl_lru);
+	glb = list_entry(b, struct gfs2_glock, gl_lru);
+
+	if (gla->gl_name.ln_number > glb->gl_name.ln_number)
+		return 1;
+	if (gla->gl_name.ln_number < glb->gl_name.ln_number)
+		return -1;
+
+	return 0;
+}
+
+/**
+ * gfs2_dispose_glock_lru - Demote a list of glocks
+ * @list: The list to dispose of
+ *
+ * Disposing of glocks may involve disk accesses, so that here we sort
+ * the glocks by number (i.e. disk location of the inodes) so that if
+ * there are any such accesses, they'll be sent in order (mostly).
+ *
+ * Must be called under the lru_lock, but may drop and retake this
+ * lock. While the lru_lock is dropped, entries may vanish from the
+ * list, but no new entries will appear on the list (since it is
+ * private)
+ */
+
+static void gfs2_dispose_glock_lru(struct list_head *list)
+__releases(&lru_lock)
+__acquires(&lru_lock)
+{
+	struct gfs2_glock *gl;
+
+	list_sort(NULL, list, glock_cmp);
+
+	while(!list_empty(list)) {
+		gl = list_entry(list->next, struct gfs2_glock, gl_lru);
+		list_del_init(&gl->gl_lru);
+		clear_bit(GLF_LRU, &gl->gl_flags);
+		gfs2_glock_hold(gl);
+		spin_unlock(&lru_lock);
+		spin_lock(&gl->gl_spin);
+		if (demote_ok(gl))
+			handle_callback(gl, LM_ST_UNLOCKED, 0);
+		WARN_ON(!test_and_clear_bit(GLF_LOCK, &gl->gl_flags));
+		smp_mb__after_clear_bit();
+		if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
+			gfs2_glock_put_nolock(gl);
+		spin_unlock(&gl->gl_spin);
+		spin_lock(&lru_lock);
+	}
+}
+
 /**
  * gfs2_scan_glock_lru - Scan the LRU looking for locks to demote
  * @nr: The number of entries to scan
  *
+ * This function selects the entries on the LRU which are able to
+ * be demoted, and then kicks off the process by calling
+ * gfs2_dispose_glock_lru() above.
  */
 
 static void gfs2_scan_glock_lru(int nr)
 {
 	struct gfs2_glock *gl;
-	int may_demote;
-	int nr_skipped = 0;
 	LIST_HEAD(skipped);
+	LIST_HEAD(dispose);
 
 	spin_lock(&lru_lock);
 	while(nr && !list_empty(&lru_list)) {
 		gl = list_entry(lru_list.next, struct gfs2_glock, gl_lru);
-		list_del_init(&gl->gl_lru);
-		clear_bit(GLF_LRU, &gl->gl_flags);
-		atomic_dec(&lru_count);
 
 		/* Test for being demotable */
 		if (!test_and_set_bit(GLF_LOCK, &gl->gl_flags)) {
-			gfs2_glock_hold(gl);
-			spin_unlock(&lru_lock);
-			spin_lock(&gl->gl_spin);
-			may_demote = demote_ok(gl);
-			if (may_demote) {
-				handle_callback(gl, LM_ST_UNLOCKED, 0);
-				nr--;
-			}
-			clear_bit(GLF_LOCK, &gl->gl_flags);
-			smp_mb__after_clear_bit();
-			if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
-				gfs2_glock_put_nolock(gl);
-			spin_unlock(&gl->gl_spin);
-			spin_lock(&lru_lock);
+			list_move(&gl->gl_lru, &dispose);
+			atomic_dec(&lru_count);
+			nr--;
 			continue;
 		}
-		nr_skipped++;
-		list_add(&gl->gl_lru, &skipped);
-		set_bit(GLF_LRU, &gl->gl_flags);
+
+		list_move(&gl->gl_lru, &skipped);
 	}
 	list_splice(&skipped, &lru_list);
-	atomic_add(nr_skipped, &lru_count);
+	if (!list_empty(&dispose))
+		gfs2_dispose_glock_lru(&dispose);
 	spin_unlock(&lru_lock);
 }
 



From swhiteho@redhat.com Fri Feb  1 16:14:43 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r11LEhD5006604 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 1 Feb 2013 16:14:43 -0500
Received: from [10.10.63.60] (vpn-63-60.rdu2.redhat.com [10.10.63.60])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r11LEg0D016594; Fri, 1 Feb 2013 16:14:42 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: Bob Peterson <rpeterso@redhat.com>
In-Reply-To: <1847869626.18286471.1359738182937.JavaMail.root@redhat.com>
References: <1847869626.18286471.1359738182937.JavaMail.root@redhat.com>
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Fri, 01 Feb 2013 21:13:28 +0000
Message-ID: <1359753208.2714.80.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] [GFS2 PATCH] GFS2: Get a block reservation
 before resizing a file
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 01 Feb 2013 21:14:43 -0000

Hi,

Now in the -nmw tree. Thanks,

Steve.

On Fri, 2013-02-01 at 12:03 -0500, Bob Peterson wrote:
> Hi,
> 
> This patch allocates a block reservation structure before growing 
> or shrinking a file. Without this structure, the grow or shink code
> can reference the bad pointer.
> 
> Regards,
> 
> Bob Peterson
> Red Hat File Systems
> 
> Signed-off-by: Bob Peterson <rpeterso@redhat.com> 
> ---
>  fs/gfs2/bmap.c | 4 ++++
>  1 file changed, 4 insertions(+)
> 
> diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
> index d29d779..df686d1 100644
> --- a/fs/gfs2/bmap.c
> +++ b/fs/gfs2/bmap.c
> @@ -1288,6 +1288,10 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
>  
>  	inode_dio_wait(inode);
>  
> +	ret = gfs2_rs_alloc(GFS2_I(inode));
> +	if (ret)
> +		return ret;
> +
>  	oldsize = inode->i_size;
>  	if (newsize >= oldsize)
>  		return do_grow(inode, newsize);
> 



From htejun@gmail.com Sat Feb  2 18:10:55 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r12NAtSW003079 for <cluster-devel@listman.util.phx.redhat.com>;
	Sat, 2 Feb 2013 18:10:55 -0500
Received: from mx1.redhat.com (ext-mx11.extmail.prod.ext.phx2.redhat.com
	[10.5.110.16])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r12NAsMw020438; Sat, 2 Feb 2013 18:10:54 -0500
Received: from mail-pa0-f45.google.com (mail-pa0-f45.google.com
	[209.85.220.45])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r12NArX0007558;
	Sat, 2 Feb 2013 18:10:53 -0500
Received: by mail-pa0-f45.google.com with SMTP id kl14so99664pab.18
	for <multiple recipients>; Sat, 02 Feb 2013 15:10:53 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:sender:date:from:to:cc:subject:message-id:references
	:mime-version:content-type:content-disposition:in-reply-to
	:user-agent; bh=0pzRVgM2GkUlO8eX8oJdBUeu3M6Bpz4alMKgxAUuj6s=;
	b=iX2XK8Os0H6q6Ko1nnoQLX5E74iTKroaX/vwyx5ZPhOlzxTl9XvHyzVmgoNsHnRIJJ
	rd6+KPuhoHIiR88UWRCvzobcxmLxsPAblq2v2VonqM8O8zOH6KToYfPT8lxeN+PBTbQi
	rkLVvqIsTbL/4U+sIN+CrO4mceLct7SzJRUJ4OOo//XzQn8kVYLZ8eJjM5PuTaiL3O+L
	mXYRprckYvwsTz8wPefFuHpOIqeTyCpgUxOaNRDJsRhpnzHkGQx5RIADm6Q3j6TbcM6l
	oQLXMOvUjnOZ/auPS98goFlws2klLiw++5ZfNhFsU6uN37F0pMbgDPACphJ2Wn/nv+zf
	2QSA==
X-Received: by 10.68.136.163 with SMTP id qb3mr43422140pbb.129.1359846653083; 
	Sat, 02 Feb 2013 15:10:53 -0800 (PST)
Received: from mtj.dyndns.org (c-69-181-251-227.hsd1.ca.comcast.net.
	[69.181.251.227])
	by mx.google.com with ESMTPS id hc4sm12878979pbc.30.2013.02.02.15.10.50
	(version=TLSv1 cipher=RC4-SHA bits=128/128);
	Sat, 02 Feb 2013 15:10:51 -0800 (PST)
Sender: Tejun Heo <htejun@gmail.com>
Date: Sat, 2 Feb 2013 15:10:48 -0800
From: Tejun Heo <tj@kernel.org>
To: David Teigland <teigland@redhat.com>
Message-ID: <20130202231048.GA3940@mtj.dyndns.org>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
	<20130201180028.GC31863@mtj.dyndns.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20130201180028.GC31863@mtj.dyndns.org>
User-Agent: Mutt/1.5.21 (2010-09-15)
X-RedHat-Spam-Score: -3  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	FREEMAIL_FROM, RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.16
X-loop: cluster-devel@redhat.com
Cc: rusty@rustcorp.com.au, linux-kernel@vger.kernel.org,
	cluster-devel@redhat.com, akpm@linux-foundation.org,
	KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: [Cluster-devel] [PATCH] idr: fix a subtle bug in idr_get_next()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Sat, 02 Feb 2013 23:10:56 -0000

The iteration logic of idr_get_next() is borrowed mostly verbatim from
idr_for_each().  It walks down the tree looking for the slot matching
the current ID.  If the matching slot is not found, the ID is
incremented by the distance of single slot at the given level and
repeats.

The implementation assumes that during the whole iteration id is
aligned to the layer boundaries of the level closest to the leaf,
which is true for all iterations starting from zero or an existing
element and thus is fine for idr_for_each().

However, idr_get_next() may be given any point and if the starting id
hits in the middle of a non-existent layer, increment to the next
layer will end up skipping the same offset into it.  For example, an
IDR with IDs filled between [64, 127] would look like the following.

          [  0  64 ... ]
       /----/   |
       |        |
      NULL    [ 64 ... 127 ]

If idr_get_next() is called with 63 as the starting point, it will try
to follow down the pointer from 0.  As it is NULL, it will then try to
proceed to the next slot in the same level by adding the slot distance
at that level which is 64 - making the next try 127.  It goes around
the loop and finds and returns 127 skipping [64, 126].

Note that this bug also triggers in idr_for_each_entry() loop which
deletes during iteration as deletions can make layers go away leaving
the iteration with unaligned ID into missing layers.

Fix it by ensuring proceeding to the next slot doesn't carry over the
unaligned offset - ie. use round_up(id + 1, slot_distance) instead of
id += slot_distance.

Signed-off-by: Tejun Heo <tj@kernel.org>
Reported-by: David Teigland <teigland@redhat.com>
Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
---
 lib/idr.c |    9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/lib/idr.c b/lib/idr.c
index 6482390..ca5aa00 100644
--- a/lib/idr.c
+++ b/lib/idr.c
@@ -625,7 +625,14 @@ void *idr_get_next(struct idr *idp, int *nextidp)
 			return p;
 		}
 
-		id += 1 << n;
+		/*
+		 * Proceed to the next layer at the current level.  Unlike
+		 * idr_for_each(), @id isn't guaranteed to be aligned to
+		 * layer boundary at this point and adding 1 << n may
+		 * incorrectly skip IDs.  Make sure we jump to the
+		 * beginning of the next layer using round_up().
+		 */
+		id = round_up(id + 1, 1 << n);
 		while (n < fls(id)) {
 			n += IDR_BITS;
 			p = *--paa;


From htejun@gmail.com Sat Feb  2 18:11:41 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r12NBfFQ011642 for <cluster-devel@listman.util.phx.redhat.com>;
	Sat, 2 Feb 2013 18:11:41 -0500
Received: from mx1.redhat.com (ext-mx14.extmail.prod.ext.phx2.redhat.com
	[10.5.110.19])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r12NBfln019417; Sat, 2 Feb 2013 18:11:41 -0500
Received: from mail-pb0-f49.google.com (mail-pb0-f49.google.com
	[209.85.160.49])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r12NBeOh017600;
	Sat, 2 Feb 2013 18:11:40 -0500
Received: by mail-pb0-f49.google.com with SMTP id xa12so2645211pbc.8
	for <multiple recipients>; Sat, 02 Feb 2013 15:11:40 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:sender:date:from:to:cc:subject:message-id:references
	:mime-version:content-type:content-disposition:in-reply-to
	:user-agent; bh=SOD9WgTiuYevH6Cgkz2GpjumVWW8pqi7u1Vf28nC26g=;
	b=d4Am076Cgay1CMsmAWOvmz9x7oBGyzpV0eNLmc7sZLsRA7VyUcywTsYm9L9wvsewLG
	XDswmhwul/Ujf5RXlHVmZ09G456BOpshRL1PDdFTpQAcNCAf4a2/p6RSBOzGRB75Ird0
	LZixWd/KpHotenwii4/f7V1ALLvvupaaB3qR4+7PPP9wxPEW/h84116lVjM+0CK4ySNQ
	f330d/saD3sJW834LViaFqacJs/WfXqtUS3hhhPmpj4evQLod7ZROkeR/qMmeXAgSRJH
	lOeNImSnvRWnAKWffIXSXFydZakLwkDtzhFVKsedTcvFRzvupqemNoaQHPsxs0T382aL
	5fIA==
X-Received: by 10.66.76.42 with SMTP id h10mr40710334paw.59.1359846700431;
	Sat, 02 Feb 2013 15:11:40 -0800 (PST)
Received: from mtj.dyndns.org (c-69-181-251-227.hsd1.ca.comcast.net.
	[69.181.251.227])
	by mx.google.com with ESMTPS id x6sm13784039paw.0.2013.02.02.15.11.38
	(version=TLSv1 cipher=RC4-SHA bits=128/128);
	Sat, 02 Feb 2013 15:11:39 -0800 (PST)
Sender: Tejun Heo <htejun@gmail.com>
Date: Sat, 2 Feb 2013 15:11:35 -0800
From: Tejun Heo <tj@kernel.org>
To: David Teigland <teigland@redhat.com>
Message-ID: <20130202231135.GB3940@mtj.dyndns.org>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
	<20130201180028.GC31863@mtj.dyndns.org>
	<20130202231048.GA3940@mtj.dyndns.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20130202231048.GA3940@mtj.dyndns.org>
User-Agent: Mutt/1.5.21 (2010-09-15)
X-RedHat-Spam-Score: -3  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	FREEMAIL_FROM, RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.19
X-loop: cluster-devel@redhat.com
Cc: rusty@rustcorp.com.au, linux-kernel@vger.kernel.org,
	cluster-devel@redhat.com, akpm@linux-foundation.org,
	KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: Re: [Cluster-devel] [PATCH] idr: fix a subtle bug in idr_get_next()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Sat, 02 Feb 2013 23:11:42 -0000

On Sat, Feb 02, 2013 at 03:10:48PM -0800, Tejun Heo wrote:
> Fix it by ensuring proceeding to the next slot doesn't carry over the
> unaligned offset - ie. use round_up(id + 1, slot_distance) instead of
> id += slot_distance.
> 
> Signed-off-by: Tejun Heo <tj@kernel.org>
> Reported-by: David Teigland <teigland@redhat.com>
> Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>

David, can you please test whether the patch makes the skipped
deletion bug go away?

Thanks!

-- 
tejun


From rdunlap@infradead.org Sat Feb  2 21:14:26 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r132EP0i019793 for <cluster-devel@listman.util.phx.redhat.com>;
	Sat, 2 Feb 2013 21:14:25 -0500
Received: from mx1.redhat.com (ext-mx13.extmail.prod.ext.phx2.redhat.com
	[10.5.110.18])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r132EPcI026939; Sat, 2 Feb 2013 21:14:25 -0500
Received: from casper.infradead.org (casper.infradead.org [85.118.1.10])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r132ENLr006150;
	Sat, 2 Feb 2013 21:14:24 -0500
Received: from static-50-53-38-135.bvtn.or.frontiernet.net ([50.53.38.135]
	helo=dragon.site)
	by casper.infradead.org with esmtpsa (Exim 4.76 #1 (Red Hat Linux))
	id 1U1p61-0002Bb-5B; Sun, 03 Feb 2013 02:14:17 +0000
Message-ID: <510DC830.70707@infradead.org>
Date: Sat, 02 Feb 2013 18:15:12 -0800
From: Randy Dunlap <rdunlap@infradead.org>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/20130105 Thunderbird/17.0.2
MIME-Version: 1.0
To: Tejun Heo <tj@kernel.org>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
	<20130201180028.GC31863@mtj.dyndns.org>
	<20130202231048.GA3940@mtj.dyndns.org>
	<20130202231135.GB3940@mtj.dyndns.org>
In-Reply-To: <20130202231135.GB3940@mtj.dyndns.org>
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
X-RedHat-Spam-Score: -4.575  (BAYES_00,RCVD_IN_DNSWL_MED,RP_MATCHES_RCVD)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.18
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Sun, 03 Feb 2013 12:17:31 -0500
Cc: rusty@rustcorp.com.au, Hugh Dickins <hughd@google.com>,
	linux-kernel@vger.kernel.org, eric paris <eparis@redhat.com>,
	cluster-devel@redhat.com, akpm@linux-foundation.org,
	KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: Re: [Cluster-devel] [PATCH] idr: fix a subtle bug in idr_get_next()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Sun, 03 Feb 2013 02:14:26 -0000

On 02/02/13 15:11, Tejun Heo wrote:
> On Sat, Feb 02, 2013 at 03:10:48PM -0800, Tejun Heo wrote:
>> Fix it by ensuring proceeding to the next slot doesn't carry over the
>> unaligned offset - ie. use round_up(id + 1, slot_distance) instead of
>> id += slot_distance.
>>
>> Signed-off-by: Tejun Heo <tj@kernel.org>
>> Reported-by: David Teigland <teigland@redhat.com>
>> Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
> 
> David, can you please test whether the patch makes the skipped
> deletion bug go away?
> 
> Thanks!

Hugh, did you update the idr test suite or the radix-tree test suite?

Is there an idr test suite or module?  I have a kernel module source file
named idr_test.c by Eric Paris.

thanks,

-- 
~Randy


From hughd@google.com Sun Feb  3 12:53:48 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r13HrlPw003665 for <cluster-devel@listman.util.phx.redhat.com>;
	Sun, 3 Feb 2013 12:53:47 -0500
Received: from mx1.redhat.com (ext-mx14.extmail.prod.ext.phx2.redhat.com
	[10.5.110.19])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r13HrknL009082
	for <cluster-devel@redhat.com>; Sun, 3 Feb 2013 12:53:47 -0500
Received: from mail-pb0-f49.google.com (mail-pb0-f49.google.com
	[209.85.160.49])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r13HrkJY017275
	for <cluster-devel@redhat.com>; Sun, 3 Feb 2013 12:53:46 -0500
Received: by mail-pb0-f49.google.com with SMTP id xa12so2837326pbc.36
	for <cluster-devel@redhat.com>; Sun, 03 Feb 2013 09:53:45 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:in-reply-to
	:message-id:references:user-agent:mime-version:content-type;
	bh=s3R3ltjQjnCLLbcy4L4bJr3ndUOcW2RgbuNgCXNGO6s=;
	b=CD1WYL8DkIFFkKwVkQEnI/o3Q0t19zOx+2mU03SF7euE1m7hh82jsx0fQaW9YmpXTB
	MY5nd0qcma+MFrypR8OmAwt+8w2CUIIg0L7Zq2R+dehvzzX3vpEX0CDlfNVI5RmPoEQE
	5zpuXxL9NqkO9YE52ErY/RBqsxfY5mzP7L6Y/U1yCVEAx/y7zGz/8n6W6Qhc4Nhy0vU6
	UHhM3/hyIrJlY/WJXocHdUNCn5dSLT5t/H0CwndQWcHRbjkLaERsIg0YksrrjlWNhs62
	4AVZq/NJ6+GF/tOxtIoxSUNa9R0s0MmruqVfG0RHMhBNJZkHeUXY0znGNTweiV19LqMX
	XE6Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:in-reply-to
	:message-id:references:user-agent:mime-version:content-type
	:x-gm-message-state;
	bh=s3R3ltjQjnCLLbcy4L4bJr3ndUOcW2RgbuNgCXNGO6s=;
	b=LbG9nM2xY5rqzN13PxGsT1LQeTdtBheDIidOVwEqCkfC/UupFbzJ1/hDlPFt3kxdUV
	GwLFZQpKUn7JpVqqfJzBGwVjefSUeLoOmgl+5KF3+tGie4dPDUqLARvs9nDTDauHfb6x
	PxhJwq+dlJ6hVITq5JDI6H7xaH4ul+D9nGgTqsExS/6JL3VnAb/BZXH1GPUW8f6K0Ql/
	s60jbdldbEEhqTMT5jYPfBp7/h2HGa0jAFikbvn7p9DIphbK/nsO/ih7t4up+W/XbfvF
	r2N7+GN4XxrJzdVWR3hqkbndlLZ64DCluNJuK4AoTM66jJA1dQ/Y2lsvElS/rWg+y4Sp
	+Iug==
X-Received: by 10.66.78.1 with SMTP id x1mr45701387paw.2.1359914025817;
	Sun, 03 Feb 2013 09:53:45 -0800 (PST)
Received: from [192.168.1.8] (c-67-188-178-35.hsd1.ca.comcast.net.
	[67.188.178.35])
	by mx.google.com with ESMTPS id rv8sm15254814pbc.27.2013.02.03.09.53.44
	(version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);
	Sun, 03 Feb 2013 09:53:45 -0800 (PST)
Date: Sun, 3 Feb 2013 09:53:47 -0800 (PST)
From: Hugh Dickins <hughd@google.com>
X-X-Sender: hugh@eggly.anvils
To: Randy Dunlap <rdunlap@infradead.org>
In-Reply-To: <510DC830.70707@infradead.org>
Message-ID: <alpine.LNX.2.00.1302030949280.1437@eggly.anvils>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
	<20130201180028.GC31863@mtj.dyndns.org>
	<20130202231048.GA3940@mtj.dyndns.org>
	<20130202231135.GB3940@mtj.dyndns.org>
	<510DC830.70707@infradead.org>
User-Agent: Alpine 2.00 (LNX 1167 2008-08-23)
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
X-Gm-Message-State: ALoCoQke0rAZ15mLGMWvPgvmM0i27UCAaSRaVP+950HzIfNXKWm3ZR2maSIaDmlGlgKsS+LEUkipoXnL4MDtwBoiFOs9lSZkCFrLareb3pkkzAUkAXL6xj+ybxo0pHWJJqBoFlu2FlQaYl/qmaYTlRHXLwttXMclgk1ipLY3iqEvV1lPHpZJm5dWR72BwMxVfl1HFQjJmTz6
X-RedHat-Spam-Score: -3.102  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, RCVD_IN_DNSWL_LOW, RP_MATCHES_RCVD,
	SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.19
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Sun, 03 Feb 2013 13:04:37 -0500
Cc: rusty@rustcorp.com.au, linux-kernel@vger.kernel.org,
	eric paris <eparis@redhat.com>, cluster-devel@redhat.com,
	Tejun Heo <tj@kernel.org>, akpm@linux-foundation.org,
	KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: Re: [Cluster-devel] [PATCH] idr: fix a subtle bug in idr_get_next()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Sun, 03 Feb 2013 17:53:48 -0000

On Sat, 2 Feb 2013, Randy Dunlap wrote:
> On 02/02/13 15:11, Tejun Heo wrote:
> > On Sat, Feb 02, 2013 at 03:10:48PM -0800, Tejun Heo wrote:
> >> Fix it by ensuring proceeding to the next slot doesn't carry over the
> >> unaligned offset - ie. use round_up(id + 1, slot_distance) instead of
> >> id += slot_distance.
> >>
> >> Signed-off-by: Tejun Heo <tj@kernel.org>
> >> Reported-by: David Teigland <teigland@redhat.com>
> >> Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
> > 
> > David, can you please test whether the patch makes the skipped
> > deletion bug go away?
> > 
> > Thanks!
> 
> Hugh, did you update the idr test suite or the radix-tree test suite?

Sorry, not the answer you want: it was the radix-tree test harness, rtth,
that I updated a year ago (but then lib/radix-tree.c changed again).

Hugh

> 
> Is there an idr test suite or module?  I have a kernel module source file
> named idr_test.c by Eric Paris.
> 
> thanks,
> 
> -- 
> ~Randy


From lizefan@huawei.com Sun Feb  3 22:40:48 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r143ekqY017238 for <cluster-devel@listman.util.phx.redhat.com>;
	Sun, 3 Feb 2013 22:40:48 -0500
Received: from mx1.redhat.com (ext-mx12.extmail.prod.ext.phx2.redhat.com
	[10.5.110.17])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r143ekLV012996; Sun, 3 Feb 2013 22:40:46 -0500
Received: from szxga02-in.huawei.com (szxga02-in.huawei.com [119.145.14.65])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r143ehBa009369;
	Sun, 3 Feb 2013 22:40:44 -0500
Received: from 172.24.2.119 (EHLO szxeml207-edg.china.huawei.com)
	([172.24.2.119])
	by szxrg02-dlp.huawei.com (MOS 4.3.4-GA FastPath queued)
	with ESMTP id AWS57724; Mon, 04 Feb 2013 11:40:42 +0800 (CST)
Received: from SZXEML420-HUB.china.huawei.com (10.82.67.159) by
	szxeml207-edg.china.huawei.com (172.24.2.56) with Microsoft SMTP Server
	(TLS) id 14.1.323.7; Mon, 4 Feb 2013 11:39:56 +0800
Received: from [10.135.68.215] (10.135.68.215) by smtpscn.huawei.com
	(10.82.67.159) with Microsoft SMTP Server (TLS) id 14.1.323.7;
	Mon, 4 Feb 2013 11:39:51 +0800
Message-ID: <510F2D86.5050408@huawei.com>
Date: Mon, 4 Feb 2013 11:39:50 +0800
From: Li Zefan <lizefan@huawei.com>
User-Agent: Mozilla/5.0 (Windows NT 6.1;
	rv:17.0) Gecko/20130107 Thunderbird/17.0.2
MIME-Version: 1.0
To: Tejun Heo <tj@kernel.org>
References: <1359163872-1949-1-git-send-email-tj@kernel.org>
	<1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
	<20130201180028.GC31863@mtj.dyndns.org>
	<20130202231048.GA3940@mtj.dyndns.org>
In-Reply-To: <20130202231048.GA3940@mtj.dyndns.org>
Content-Type: text/plain; charset="ISO-8859-1"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.135.68.215]
X-CFilter-Loop: Reflected
X-RedHat-Spam-Score: -2.302  (BAYES_00, DCC_REPUT_00_12, RP_MATCHES_RCVD,
	SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.17
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Mon, 04 Feb 2013 04:19:01 -0500
Cc: rusty@rustcorp.com.au, linux-kernel@vger.kernel.org,
	cluster-devel@redhat.com, akpm@linux-foundation.org,
	KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: Re: [Cluster-devel] [PATCH] idr: fix a subtle bug in idr_get_next()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 04 Feb 2013 03:40:49 -0000

On 2013/2/3 7:10, Tejun Heo wrote:
> The iteration logic of idr_get_next() is borrowed mostly verbatim from
> idr_for_each().  It walks down the tree looking for the slot matching
> the current ID.  If the matching slot is not found, the ID is
> incremented by the distance of single slot at the given level and
> repeats.
> 
> The implementation assumes that during the whole iteration id is
> aligned to the layer boundaries of the level closest to the leaf,
> which is true for all iterations starting from zero or an existing
> element and thus is fine for idr_for_each().
> 
> However, idr_get_next() may be given any point and if the starting id
> hits in the middle of a non-existent layer, increment to the next
> layer will end up skipping the same offset into it.  For example, an
> IDR with IDs filled between [64, 127] would look like the following.
> 
>           [  0  64 ... ]
>        /----/   |
>        |        |
>       NULL    [ 64 ... 127 ]
> 
> If idr_get_next() is called with 63 as the starting point, it will try
> to follow down the pointer from 0.  As it is NULL, it will then try to
> proceed to the next slot in the same level by adding the slot distance
> at that level which is 64 - making the next try 127.  It goes around
> the loop and finds and returns 127 skipping [64, 126].
> 
> Note that this bug also triggers in idr_for_each_entry() loop which
> deletes during iteration as deletions can make layers go away leaving
> the iteration with unaligned ID into missing layers.
> 
> Fix it by ensuring proceeding to the next slot doesn't carry over the
> unaligned offset - ie. use round_up(id + 1, slot_distance) instead of
> id += slot_distance.
> 
> Signed-off-by: Tejun Heo <tj@kernel.org>

Don't we need to cc stable?

> Reported-by: David Teigland <teigland@redhat.com>
> Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
> ---
>  lib/idr.c |    9 ++++++++-
>  1 file changed, 8 insertions(+), 1 deletion(-)
> 
> diff --git a/lib/idr.c b/lib/idr.c
> index 6482390..ca5aa00 100644
> --- a/lib/idr.c
> +++ b/lib/idr.c
> @@ -625,7 +625,14 @@ void *idr_get_next(struct idr *idp, int *nextidp)
>  			return p;
>  		}
>  
> -		id += 1 << n;
> +		/*
> +		 * Proceed to the next layer at the current level.  Unlike
> +		 * idr_for_each(), @id isn't guaranteed to be aligned to
> +		 * layer boundary at this point and adding 1 << n may
> +		 * incorrectly skip IDs.  Make sure we jump to the
> +		 * beginning of the next layer using round_up().
> +		 */
> +		id = round_up(id + 1, 1 << n);
>  		while (n < fls(id)) {
>  			n += IDR_BITS;
>  			p = *--paa;
> --


From mgrac@redhat.com Mon Feb  4 05:13:09 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r14AD93w018140; Mon, 4 Feb 2013 05:13:09 -0500
Received: from [10.34.131.118] (dhcp131-118.brq.redhat.com [10.34.131.118])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r14AD8Mm006821; Mon, 4 Feb 2013 05:13:08 -0500
Message-ID: <510F89B2.1090904@redhat.com>
Date: Mon, 04 Feb 2013 11:13:06 +0100
From: Marek Grac <mgrac@redhat.com>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/17.0 Thunderbird/17.0
MIME-Version: 1.0
To: linux clustering <linux-cluster@redhat.com>, cluster-devel@redhat.com
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] fence-agents 3.1.12 stable release
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 04 Feb 2013 10:13:09 -0000

Welcome to the fence-agents 3.1.12 release.

This release includes these updates:
* support for Hitachi Compute Blade 2000
* UUID can be entered direcctly as a port-number (-n / --plug / port=)
* new options to set options for ssh connection (--ssh-options)
* fix regression in detection of EOL for Dell CMC and Dell DRAC5
* massive code clean-up

The new source tarball can be downloaded here:

https://fedorahosted.org/releases/f/e/fence-agents/fence-agents-3.1.12.tar.xz 


To report bugs or issues:

https://bugzilla.redhat.com/

Would you like to meet the cluster team or members of its community?

    Join us on IRC (irc.freenode.net #linux-cluster) and share your
    experience  with other sysadministrators or power users.

Thanks/congratulations to all people that contributed to achieve this
milestone.

m,


From htejun@gmail.com Mon Feb  4 12:45:13 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r14HjD37025031 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 4 Feb 2013 12:45:13 -0500
Received: from mx1.redhat.com (ext-mx13.extmail.prod.ext.phx2.redhat.com
	[10.5.110.18])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r14Hj5i4017830; Mon, 4 Feb 2013 12:45:07 -0500
Received: from mail-ve0-f179.google.com (mail-ve0-f179.google.com
	[209.85.128.179])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r14Hj1jw007995;
	Mon, 4 Feb 2013 12:45:01 -0500
Received: by mail-ve0-f179.google.com with SMTP id da11so3825647veb.38
	for <multiple recipients>; Mon, 04 Feb 2013 09:45:00 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:sender:date:from:to:cc:subject:message-id:references
	:mime-version:content-type:content-disposition:in-reply-to
	:user-agent; bh=N/aRGP5GbJ4YfLJzjZiQwMS+tNRUDGYXHbn+xUmRgQw=;
	b=jB4GjcUXCTh+B1+M8h/TX3z6YwRMBFK62FoXS34V4lsSZsnhfwHJd2S1T0thWVvu8F
	lLCQTM/SybJLsnMnmmp9zDBvbGFf/OLsCAgpEGopyqny7NJC74CCSQGu4EtS+eoyQ/Ii
	DYcPKpfrVe8vdfQKV2DuHjr7fjLto9WSUOFO4MWn4lO1KWPI41rmchev7zXwtWBWg+zW
	72pWIhxqJmQTfayFF4MmpYNWz0sLq7TgTXLC4aw0iyQnyp5YhopCrcfCNkK3PC5teBZv
	ZIdS95/nmeGB0yRjNXwk1XEkB/yS1SzIuiWriC0nD123ihMXotpg1AUnGs4xA4Mz/GKB
	yFPw==
X-Received: by 10.52.178.105 with SMTP id cx9mr20799294vdc.31.1359999900879;
	Mon, 04 Feb 2013 09:45:00 -0800 (PST)
Received: from mtj.dyndns.org (nat-pool-3-rdu.redhat.com. [66.187.233.203])
	by mx.google.com with ESMTPS id a19sm22738569vdh.9.2013.02.04.09.44.57
	(version=TLSv1 cipher=RC4-SHA bits=128/128);
	Mon, 04 Feb 2013 09:44:59 -0800 (PST)
Sender: Tejun Heo <htejun@gmail.com>
Date: Mon, 4 Feb 2013 09:44:55 -0800
From: Tejun Heo <tj@kernel.org>
To: Li Zefan <lizefan@huawei.com>
Message-ID: <20130204174455.GP27963@mtj.dyndns.org>
References: <1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
	<20130201180028.GC31863@mtj.dyndns.org>
	<20130202231048.GA3940@mtj.dyndns.org>
	<510F2D86.5050408@huawei.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <510F2D86.5050408@huawei.com>
User-Agent: Mutt/1.5.21 (2010-09-15)
X-RedHat-Spam-Score: -3  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	FREEMAIL_FROM, RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.18
X-loop: cluster-devel@redhat.com
Cc: rusty@rustcorp.com.au, linux-kernel@vger.kernel.org,
	cluster-devel@redhat.com, akpm@linux-foundation.org,
	KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: Re: [Cluster-devel] [PATCH] idr: fix a subtle bug in idr_get_next()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 04 Feb 2013 17:45:14 -0000

Hey, Li.

On Mon, Feb 04, 2013 at 11:39:50AM +0800, Li Zefan wrote:
> > Fix it by ensuring proceeding to the next slot doesn't carry over the
> > unaligned offset - ie. use round_up(id + 1, slot_distance) instead of
> > id += slot_distance.
> > 
> > Signed-off-by: Tejun Heo <tj@kernel.org>
> 
> Don't we need to cc stable?

I thought we didn't have idr_remove() inside idr_for_each_entry() in
kernel, which isn't true.  drbd already does that, so yeah, we need to
cc stable.

Thanks.

-- 
tejun


From lczerner@redhat.com Tue Feb  5 04:12:35 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r159CZQj029403 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 5 Feb 2013 04:12:35 -0500
Received: from dhcp-1-104.brq.redhat.com (dhcp-1-104.brq.redhat.com
	[10.34.1.104])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r159CKBT012377; Tue, 5 Feb 2013 04:12:34 -0500
From: Lukas Czerner <lczerner@redhat.com>
To: linux-mm@kvack.org
Date: Tue,  5 Feb 2013 10:12:01 +0100
Message-Id: <1360055531-26309-9-git-send-email-lczerner@redhat.com>
In-Reply-To: <1360055531-26309-1-git-send-email-lczerner@redhat.com>
References: <1360055531-26309-1-git-send-email-lczerner@redhat.com>
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Cc: linux-fsdevel@vger.kernel.org, Lukas Czerner <lczerner@redhat.com>,
	linux-ext4@vger.kernel.org, linux-kernel@vger.kernel.org,
	cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH v2 08/18] gfs2: use ->invalidatepage()
	length argument
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 05 Feb 2013 09:12:35 -0000

->invalidatepage() aop now accepts range to invalidate so we can make
use of it in gfs2_invalidatepage().

Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Cc: cluster-devel@redhat.com
---
 fs/gfs2/aops.c |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/fs/gfs2/aops.c b/fs/gfs2/aops.c
index 5bd558c..3cf3dc8 100644
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@ -949,24 +949,29 @@ static void gfs2_invalidatepage(struct page *page, unsigned int offset,
 				unsigned int length)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);
+	unsigned int stop = offset + length;
+	int partial_page = (offset || length < PAGE_CACHE_SIZE);
 	struct buffer_head *bh, *head;
 	unsigned long pos = 0;
 
 	BUG_ON(!PageLocked(page));
-	if (offset == 0)
+	if (!partial_page)
 		ClearPageChecked(page);
 	if (!page_has_buffers(page))
 		goto out;
 
 	bh = head = page_buffers(page);
 	do {
+		if (pos + bh->b_size > stop)
+			return;
+
 		if (offset <= pos)
 			gfs2_discard(sdp, bh);
 		pos += bh->b_size;
 		bh = bh->b_this_page;
 	} while (bh != head);
 out:
-	if (offset == 0)
+	if (!partial_page)
 		try_to_release_page(page, 0);
 }
 
-- 
1.7.7.6


From swhiteho@redhat.com Tue Feb  5 04:49:01 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r159n1A8011640 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 5 Feb 2013 04:49:01 -0500
Received: from [10.10.61.106] (vpn-61-106.rdu2.redhat.com [10.10.61.106])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r159mw8i030917; Tue, 5 Feb 2013 04:48:59 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: Lukas Czerner <lczerner@redhat.com>
In-Reply-To: <1360055531-26309-9-git-send-email-lczerner@redhat.com>
References: <1360055531-26309-1-git-send-email-lczerner@redhat.com>
	<1360055531-26309-9-git-send-email-lczerner@redhat.com>
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Tue, 05 Feb 2013 09:47:39 +0000
Message-ID: <1360057659.2717.14.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Cc: linux-fsdevel@vger.kernel.org, linux-mm@kvack.org,
	linux-ext4@vger.kernel.org, linux-kernel@vger.kernel.org,
	cluster-devel@redhat.com
Subject: Re: [Cluster-devel] [PATCH v2 08/18] gfs2: use ->invalidatepage()
 length argument
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 05 Feb 2013 09:49:01 -0000

Hi,

Acked-by: Steven Whitehouse <swhiteho@redhat.com>

Steve.

On Tue, 2013-02-05 at 10:12 +0100, Lukas Czerner wrote:
> ->invalidatepage() aop now accepts range to invalidate so we can make
> use of it in gfs2_invalidatepage().
> 
> Signed-off-by: Lukas Czerner <lczerner@redhat.com>
> Cc: cluster-devel@redhat.com
> ---
>  fs/gfs2/aops.c |    9 +++++++--
>  1 files changed, 7 insertions(+), 2 deletions(-)
> 
> diff --git a/fs/gfs2/aops.c b/fs/gfs2/aops.c
> index 5bd558c..3cf3dc8 100644
> --- a/fs/gfs2/aops.c
> +++ b/fs/gfs2/aops.c
> @@ -949,24 +949,29 @@ static void gfs2_invalidatepage(struct page *page, unsigned int offset,
>  				unsigned int length)
>  {
>  	struct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);
> +	unsigned int stop = offset + length;
> +	int partial_page = (offset || length < PAGE_CACHE_SIZE);
>  	struct buffer_head *bh, *head;
>  	unsigned long pos = 0;
>  
>  	BUG_ON(!PageLocked(page));
> -	if (offset == 0)
> +	if (!partial_page)
>  		ClearPageChecked(page);
>  	if (!page_has_buffers(page))
>  		goto out;
>  
>  	bh = head = page_buffers(page);
>  	do {
> +		if (pos + bh->b_size > stop)
> +			return;
> +
>  		if (offset <= pos)
>  			gfs2_discard(sdp, bh);
>  		pos += bh->b_size;
>  		bh = bh->b_this_page;
>  	} while (bh != head);
>  out:
> -	if (offset == 0)
> +	if (!partial_page)
>  		try_to_release_page(page, 0);
>  }
>  



From swhiteho@redhat.com Tue Feb  5 08:24:29 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r15DOTJo011354 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 5 Feb 2013 08:24:29 -0500
Received: from [10.10.61.106] (vpn-61-106.rdu2.redhat.com [10.10.61.106])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r15DOSR4004112; Tue, 5 Feb 2013 08:24:28 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: sbradley@redhat.com
In-Reply-To: <1359643290-21777-1-git-send-email-sbradley@redhat.com>
References: <1359643290-21777-1-git-send-email-sbradley@redhat.com>
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Tue, 05 Feb 2013 13:23:08 +0000
Message-ID: <1360070588.2717.15.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] [PATCH] gfs2_lockcapture: Capture the status of
 the cluster nodes and find the clusternode name and id.
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 05 Feb 2013 13:24:30 -0000

Hi,

Looks ok to me, so long as it does what you want it to do,

Steve.

On Thu, 2013-01-31 at 09:41 -0500, sbradley@redhat.com wrote:
> From: Shane Bradley <sbradley@redhat.com>
> 
> The status of the cluster will be captured and written to the file with respect
> to version: cman_tool nodes, corosync-quorumtool -l. Added two new configuration
> variables to the hostinformation.txt for the clusternode name and id.
> 
> Signed-off-by: Shane Bradley <sbradley@redhat.com>
> ---
>  gfs2/scripts/gfs2_lockcapture | 102 +++++++++++++++++++++++++++++++-----------
>  1 file changed, 76 insertions(+), 26 deletions(-)
> 
> diff --git a/gfs2/scripts/gfs2_lockcapture b/gfs2/scripts/gfs2_lockcapture
> index 2b3421c..6a63fc8 100644
> --- a/gfs2/scripts/gfs2_lockcapture
> +++ b/gfs2/scripts/gfs2_lockcapture
> @@ -45,12 +45,15 @@ class ClusterNode:
>      """
>      This class represents a cluster node that is a current memeber in a cluster.
>      """
> -    def __init__(self, clusternodeName, clusterName, mapOfMountedFilesystemLabels):
> +    def __init__(self, clusternodeName, clusternodeID, clusterName, mapOfMountedFilesystemLabels):
>          """
>          @param clusternodeName: The name of the cluster node.
>          @type clusternodeName: String
>          @param clusterName: The name of the cluster that this cluster node is a
>          member of.
> +        @param clusternodeID: The id of the cluster node.
> +        @type clusternodeID: Int
> +        @param clusterName: The name of the cluster that this cluster node is a
>          @type clusterName: String
>          @param mapOfMountedFilesystemLabels: A map of filesystem labels(key) for
>          a mounted filesystem. The value is the line for the matching mounted
> @@ -58,6 +61,7 @@ class ClusterNode:
>          @type mapOfMountedFilesystemLabels: Dict
>          """
>          self.__clusternodeName = clusternodeName
> +        self.__clusternodeID  = clusternodeID
>          self.__clusterName = clusterName
>          self.__mapOfMountedFilesystemLabels = mapOfMountedFilesystemLabels
>  
> @@ -69,7 +73,7 @@ class ClusterNode:
>          @rtype: String
>          """
>          rString = ""
> -        rString += "%s:%s" %(self.getClusterName(), self.getClusterNodeName())
> +        rString += "%s:%s(id:%d)" %(self.getClusterName(), self.getClusterNodeName(), self.getClusterNodeID())
>          fsLabels = self.__mapOfMountedFilesystemLabels.keys()
>          fsLabels.sort()
>          for fsLabel in fsLabels:
> @@ -85,6 +89,14 @@ class ClusterNode:
>          """
>          return self.__clusternodeName
>  
> +    def getClusterNodeID(self):
> +        """
> +        Returns the id of the cluster node.
> +        @return: Returns the id of the cluster node.
> +        @rtype: String
> +        """
> +        return self.__clusternodeID
> +
>      def getClusterName(self):
>          """
>          Returns the name of cluster that this cluster node is a member of.
> @@ -539,6 +551,7 @@ def getClusterNode(listOfGFS2Names):
>      # in the output, else return None.
>      clusterName = ""
>      clusternodeName = ""
> +    clusternodeID = ""
>      if (runCommand("which", ["cman_tool"])):
>          stdout = runCommandOutput("cman_tool", ["status"])
>          if (not stdout == None):
> @@ -550,6 +563,8 @@ def getClusterNode(listOfGFS2Names):
>                      clusterName = line.split("Cluster Name:")[1].strip().rstrip()
>                  if (line.startswith("Node name: ")):
>                      clusternodeName = line.split("Node name:")[1].strip().rstrip()
> +                if (line.startswith("Node ID: ")):
> +                    clusternodeID = line.split("Node ID: ")[1].strip().rstrip()
>      elif (runCommand("which", ["corosync-cmapctl"])):
>          # Another way to get the local cluster node is: $ crm_node -i; crm_node -l
>          # Get the name of the cluster.
> @@ -559,14 +574,14 @@ def getClusterNode(listOfGFS2Names):
>              if (len(stdoutSplit) == 2):
>                  clusterName = stdoutSplit[1].strip().rstrip()
>          # Get the id of the local cluster node so we can get the clusternode name
> -        thisNodeID = ""
> +        clusternodeID = ""
>          stdout = runCommandOutput("corosync-cmapctl", ["-g", "runtime.votequorum.this_node_id"])
>          if (not stdout == None):
>              stdoutSplit = stdout.split("=")
>              if (len(stdoutSplit) == 2):
> -               thisNodeID = stdoutSplit[1].strip().rstrip()
> +               clusternodeID = stdoutSplit[1].strip().rstrip()
>          # Now that we the nodeid then we can get the clusternode name.
> -        if (len(thisNodeID) > 0):
> +        if (len(clusternodeID) > 0):
>              stdout = runCommandOutput("corosync-quorumtool", ["-l"])
>              if (not stdout == None):
>                  for line in stdout.split("\n"):
> @@ -588,7 +603,15 @@ def getClusterNode(listOfGFS2Names):
>                          break
>                  if ((not foundMatch) and (mapOfMountedFilesystemLabels.has_key(label))):
>                      del(mapOfMountedFilesystemLabels[label])
> -        return ClusterNode(clusternodeName, clusterName, mapOfMountedFilesystemLabels)
> +        # Cast the node id to an int, and default is 0 if node is not found or
> +        # not castable.
> +        clusternodeIDInt = 0
> +        if (clusternodeID.isalnum()):
> +            try:
> +                clusternodeIDInt = int(clusternodeID)
> +            except(ValueError):
> +                pass
> +        return ClusterNode(clusternodeName, clusternodeIDInt, clusterName, mapOfMountedFilesystemLabels)
>      else:
>          return None
>  
> @@ -701,6 +724,28 @@ def gatherGeneralInformation(pathToDSTDir):
>          message = "There was an error the command output for %s to the file %s." %(command, pathToCommandOutput)
>          logging.getLogger(MAIN_LOGGER_NAME).error(message)
>  
> +    # Write the status of all the nodes in the cluster out.
> +    if (runCommand("which", ["cman_tool"])):
> +        command = "cman_tool"
> +        pathToCommandOutput = os.path.join(pathToDSTDir, "cman_tool_status")
> +        try:
> +            fout = open(pathToCommandOutput, "w")
> +            runCommand(command, ["status"], standardOut=fout)
> +            fout.close()
> +        except IOError:
> +            message = "There was an error the command output for %s to the file %s." %(command, pathToCommandOutput)
> +            logging.getLogger(MAIN_LOGGER_NAME).error(message)
> +    elif (runCommand("which", ["corosync-cmapctl"])):
> +        command = "corosync-quorumtool"
> +        pathToCommandOutput = os.path.join(pathToDSTDir, "corosync-quorumtool_l")
> +        try:
> +            fout = open(pathToCommandOutput, "w")
> +            runCommand(command, ["-l"], standardOut=fout)
> +            fout.close()
> +        except IOError:
> +            message = "There was an error the command output for %s to the file %s." %(command, pathToCommandOutput)
> +            logging.getLogger(MAIN_LOGGER_NAME).error(message)
> +
>  
>  def isProcPidStackEnabled(pathToPidData):
>      """
> @@ -1067,26 +1112,6 @@ if __name__ == "__main__":
>              # script running.
>              writeToFile(PATH_TO_PID_FILENAME, str(os.getpid()), createFile=True)
>          # #######################################################################
> -        # Verify they want to continue because this script will trigger sysrq events.
> -        # #######################################################################
> -        if (not cmdLineOpts.disableQuestions):
> -            valid = {"yes":True, "y":True, "no":False, "n":False}
> -            question = "This script will trigger a sysrq -t event or collect the data for each pid directory located in /proc for each run. Are you sure you want to continue?"
> -            prompt = " [y/n] "
> -            while True:
> -                sys.stdout.write(question + prompt)
> -                choice = raw_input().lower()
> -                if (choice in valid):
> -                    if (valid.get(choice)):
> -                        # If yes, or y then exit loop and continue.
> -                        break
> -                    else:
> -                        message = "The script will not continue since you chose not to continue."
> -                        logging.getLogger(MAIN_LOGGER_NAME).error(message)
> -                        exitScript(removePidFile=True, errorCode=1)
> -                else:
> -                    sys.stdout.write("Please respond with '(y)es' or '(n)o'.\n")
> -        # #######################################################################
>          # Get the clusternode name and verify that mounted GFS2 filesystems were
>          # found.
>          # #######################################################################
> @@ -1110,6 +1135,26 @@ if __name__ == "__main__":
>              print clusternode
>              exitScript()
>          # #######################################################################
> +        # Verify they want to continue because this script will trigger sysrq events.
> +        # #######################################################################
> +        if (not cmdLineOpts.disableQuestions):
> +            valid = {"yes":True, "y":True, "no":False, "n":False}
> +            question = "This script will trigger a sysrq -t event or collect the data for each pid directory located in /proc for each run. Are you sure you want to continue?"
> +            prompt = " [y/n] "
> +            while True:
> +                sys.stdout.write(question + prompt)
> +                choice = raw_input().lower()
> +                if (choice in valid):
> +                    if (valid.get(choice)):
> +                        # If yes, or y then exit loop and continue.
> +                        break
> +                    else:
> +                        message = "The script will not continue since you chose not to continue."
> +                        logging.getLogger(MAIN_LOGGER_NAME).error(message)
> +                        exitScript(removePidFile=True, errorCode=1)
> +                else:
> +                    sys.stdout.write("Please respond with '(y)es' or '(n)o'.\n")
> +        # #######################################################################
>          # Create the output directory to verify it can be created before
>          # proceeding unless it is already created from a previous run data needs
>          # to be analyzed. Probably could add more debugging on if file or dir.
> @@ -1178,6 +1223,11 @@ if __name__ == "__main__":
>              message = "Pass (%d/%d): Gathering general information about the host." %(i, cmdLineOpts.numberOfRuns)
>              logging.getLogger(MAIN_LOGGER_NAME).debug(message)
>              gatherGeneralInformation(pathToOutputRunDir)
> +            # Write the clusternode name and id to the general information file.
> +            writeToFile(os.path.join(pathToOutputRunDir, "hostinformation.txt"),
> +                        "NODE_NAME=%s\nNODE_ID=%d" %(clusternode.getClusterNodeName(), clusternode.getClusterNodeID()),
> +                        appendToFile=True, createFile=True)
> +
>              # Going to sleep for 2 seconds, so that TIMESTAMP should be in the
>              # past in the logs so that capturing sysrq data will be guaranteed.
>              time.sleep(2)



From teigland@redhat.com Tue Feb  5 10:36:17 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r15FaHfV010360 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 5 Feb 2013 10:36:17 -0500
Received: from redhat.com (s01.msp.redhat.com [10.15.95.15])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r15FaEKq018430
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES128-SHA bits=128 verify=NO);
	Tue, 5 Feb 2013 10:36:16 -0500
Date: Tue, 5 Feb 2013 10:36:14 -0500
From: David Teigland <teigland@redhat.com>
To: Tejun Heo <tj@kernel.org>
Message-ID: <20130205153614.GA1508@redhat.com>
References: <1359163872-1949-11-git-send-email-tj@kernel.org>
	<20130128155723.GC16789@redhat.com>
	<20130129151317.GA11609@redhat.com>
	<20130130212417.GJ24014@redhat.com>
	<20130131235320.GN6824@mtj.dyndns.org>
	<20130201001841.GP6824@mtj.dyndns.org>
	<20130201174443.GC3812@redhat.com>
	<20130201180028.GC31863@mtj.dyndns.org>
	<20130202231048.GA3940@mtj.dyndns.org>
	<20130202231135.GB3940@mtj.dyndns.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20130202231135.GB3940@mtj.dyndns.org>
User-Agent: Mutt/1.5.20 (2009-12-10)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-loop: cluster-devel@redhat.com
Cc: rusty@rustcorp.com.au, linux-kernel@vger.kernel.org,
	cluster-devel@redhat.com, akpm@linux-foundation.org,
	KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: Re: [Cluster-devel] [PATCH] idr: fix a subtle bug in idr_get_next()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 05 Feb 2013 15:36:17 -0000

On Sat, Feb 02, 2013 at 03:11:35PM -0800, Tejun Heo wrote:
> On Sat, Feb 02, 2013 at 03:10:48PM -0800, Tejun Heo wrote:
> > Fix it by ensuring proceeding to the next slot doesn't carry over the
> > unaligned offset - ie. use round_up(id + 1, slot_distance) instead of
> > id += slot_distance.
> > 
> > Signed-off-by: Tejun Heo <tj@kernel.org>
> > Reported-by: David Teigland <teigland@redhat.com>
> > Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
> 
> David, can you please test whether the patch makes the skipped
> deletion bug go away?

Yes, I've tested, and it works fine now.
Thanks,
Dave


From htejun@gmail.com Wed Feb  6 14:49:40 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r16JneCO025098 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 6 Feb 2013 14:49:40 -0500
Received: from mx1.redhat.com (ext-mx11.extmail.prod.ext.phx2.redhat.com
	[10.5.110.16])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r16JnetJ018812; Wed, 6 Feb 2013 14:49:40 -0500
Received: from mail-oa0-f42.google.com (mail-oa0-f42.google.com
	[209.85.219.42])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r16JndIv019084;
	Wed, 6 Feb 2013 14:49:39 -0500
Received: by mail-oa0-f42.google.com with SMTP id i18so1958579oag.15
	for <multiple recipients>; Wed, 06 Feb 2013 11:49:39 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:sender:from:to:cc:subject:date:message-id:x-mailer
	:in-reply-to:references;
	bh=GUVI/r++UMOM8b6zU8SYifMlQKtu58MLivS3sGA0Gsc=;
	b=OK4MGT9hxgElvUNp7ZOLHwH5cQHjd0uybcoqYwWjD8nhYNdSM+S7wa0hsvEihwpkTD
	yyOyWYS97WEyDAEvRVspUa/ZpJMwWGVDMzxxAljLcAxdch5JpiJ61XGT+Slp6N4zKQSs
	3s5bYDLs3A8wlZFlO6zbwXFuFbgVyaWUD0BuTyE0BPsG6MYf0mqnymsayS6c5cwFROG6
	H7W6h8CKz1/K+WK0wga81F2A8PWFosLsfQuYaXWvLpe3VPn7VlYEUl9QCi54q5LQWuSx
	Ulk6ZJ57zNz3KpNtARGrzlkzgkjQfpHAt4u/dd3/Xu4LG1F8Z9RYImyc6dpbebkH2FDH
	9wgw==
X-Received: by 10.182.0.19 with SMTP id 19mr22345469oba.15.1360180179052;
	Wed, 06 Feb 2013 11:49:39 -0800 (PST)
Received: from htj.dyndns.org (c-69-181-251-227.hsd1.ca.comcast.net.
	[69.181.251.227])
	by mx.google.com with ESMTPS id l5sm39989590pax.10.2013.02.06.11.49.37
	(version=TLSv1.2 cipher=RC4-SHA bits=128/128);
	Wed, 06 Feb 2013 11:49:38 -0800 (PST)
Sender: Tejun Heo <htejun@gmail.com>
From: Tejun Heo <tj@kernel.org>
To: akpm@linux-foundation.org
Date: Wed,  6 Feb 2013 11:39:43 -0800
Message-Id: <1360179649-22465-12-git-send-email-tj@kernel.org>
In-Reply-To: <1360179649-22465-1-git-send-email-tj@kernel.org>
References: <1360179649-22465-1-git-send-email-tj@kernel.org>
X-RedHat-Spam-Score: -3  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	FREEMAIL_FROM, RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.16
X-loop: cluster-devel@redhat.com
Cc: Tejun Heo <tj@kernel.org>, cluster-devel@redhat.com,
	linux-kernel@vger.kernel.org
Subject: [Cluster-devel] [PATCH 11/77] dlm: don't use idr_remove_all()
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 06 Feb 2013 19:49:40 -0000

idr_destroy() can destroy idr by itself and idr_remove_all() is being
deprecated.

The conversion isn't completely trivial for recover_idr_clear() as
it's the only place in kernel which makes legitimate use of
idr_remove_all() w/o idr_destroy().  Replace it with idr_remove() call
inside idr_for_each_entry() loop.  It goes on top so that it matches
the operation order in recover_idr_del().

Only compile tested.

Signed-off-by: Tejun Heo <tj@kernel.org>
Cc: Christine Caulfield <ccaulfie@redhat.com>
Cc: David Teigland <teigland@redhat.com>
Cc: cluster-devel@redhat.com
---
 fs/dlm/lockspace.c | 1 -
 fs/dlm/recover.c   | 2 +-
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/fs/dlm/lockspace.c b/fs/dlm/lockspace.c
index 2e99fb0..3ca79d3 100644
--- a/fs/dlm/lockspace.c
+++ b/fs/dlm/lockspace.c
@@ -796,7 +796,6 @@ static int release_lockspace(struct dlm_ls *ls, int force)
 	 */
 
 	idr_for_each(&ls->ls_lkbidr, lkb_idr_free, ls);
-	idr_remove_all(&ls->ls_lkbidr);
 	idr_destroy(&ls->ls_lkbidr);
 
 	/*
diff --git a/fs/dlm/recover.c b/fs/dlm/recover.c
index b2856e7..236d108 100644
--- a/fs/dlm/recover.c
+++ b/fs/dlm/recover.c
@@ -359,13 +359,13 @@ static void recover_idr_clear(struct dlm_ls *ls)
 	spin_lock(&ls->ls_recover_idr_lock);
 
 	idr_for_each_entry(&ls->ls_recover_idr, r, id) {
+		idr_remove(&ls->ls_recover_idr, id);
 		r->res_id = 0;
 		r->res_recover_locks_count = 0;
 		ls->ls_recover_list_count--;
 
 		dlm_put_rsb(r);
 	}
-	idr_remove_all(&ls->ls_recover_idr);
 
 	if (ls->ls_recover_list_count != 0) {
 		log_error(ls, "warning: recover_list_count %d",
-- 
1.8.1


From htejun@gmail.com Wed Feb  6 15:02:54 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r16K2s4A030479 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 6 Feb 2013 15:02:54 -0500
Received: from mx1.redhat.com (ext-mx14.extmail.prod.ext.phx2.redhat.com
	[10.5.110.19])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r16K2sh2021509; Wed, 6 Feb 2013 15:02:54 -0500
Received: from mail-da0-f44.google.com (mail-da0-f44.google.com
	[209.85.210.44])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r16K2ruC027888;
	Wed, 6 Feb 2013 15:02:53 -0500
Received: by mail-da0-f44.google.com with SMTP id z20so820806dae.31
	for <multiple recipients>; Wed, 06 Feb 2013 12:02:53 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:sender:from:to:cc:subject:date:message-id:x-mailer
	:in-reply-to:references;
	bh=XkZaQ1snVBilWWAWeOs/55dMJpe95OwpfWnVxmXb5K0=;
	b=SI7bWiKWh8SlNkP1tj8O+kY1x3bq1PVwOKSsR9Xz6KKTirmehj7YCS0wpQtq981hy3
	dGhL2nf6qEmKsWQLxGKoxMkhvdb5aUUlyHiWvjqxBw71Aen8HhP00mjd62DbcOfR0SLr
	cZmMNjpcFwClSm9LMXIplOUxujlIV5klqQ9lwCVOwRj+ulBnNlk9whRc7a8ZI6TrHU7S
	YMCfRvb+GhcZpclUQVfPqFphcyLWfT8Fp9uKladL9aneGYRsFrWkKB1vnL52Qoq1wxzH
	Gv3A4tpkn4FUN1P3RSqtf5XDseWKifrSHJuR7f9Q+YukmaIzKCvP8KivsQ/Js8DlZqZI
	mWOA==
X-Received: by 10.66.73.164 with SMTP id m4mr78938591pav.12.1360180177283;
	Wed, 06 Feb 2013 11:49:37 -0800 (PST)
Received: from htj.dyndns.org (c-69-181-251-227.hsd1.ca.comcast.net.
	[69.181.251.227])
	by mx.google.com with ESMTPS id l5sm39989590pax.10.2013.02.06.11.49.35
	(version=TLSv1.2 cipher=RC4-SHA bits=128/128);
	Wed, 06 Feb 2013 11:49:36 -0800 (PST)
Sender: Tejun Heo <htejun@gmail.com>
From: Tejun Heo <tj@kernel.org>
To: akpm@linux-foundation.org
Date: Wed,  6 Feb 2013 11:39:42 -0800
Message-Id: <1360179649-22465-11-git-send-email-tj@kernel.org>
In-Reply-To: <1360179649-22465-1-git-send-email-tj@kernel.org>
References: <1360179649-22465-1-git-send-email-tj@kernel.org>
X-RedHat-Spam-Score: -3  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	FREEMAIL_FROM, RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.19
X-loop: cluster-devel@redhat.com
Cc: Tejun Heo <tj@kernel.org>, cluster-devel@redhat.com,
	linux-kernel@vger.kernel.org
Subject: [Cluster-devel] [PATCH 10/77] dlm: use idr_for_each_entry() in
	recover_idr_clear() error path
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 06 Feb 2013 20:02:54 -0000

Convert recover_idr_clear() to use idr_for_each_entry() instead of
idr_for_each().  It's somewhat less efficient this way but it
shouldn't matter in an error path.  This is to help with deprecation
of idr_remove_all().

Only compile tested.

Signed-off-by: Tejun Heo <tj@kernel.org>
Cc: Christine Caulfield <ccaulfie@redhat.com>
Cc: David Teigland <teigland@redhat.com>
Cc: cluster-devel@redhat.com
---
 fs/dlm/recover.c | 23 ++++++++++-------------
 1 file changed, 10 insertions(+), 13 deletions(-)

diff --git a/fs/dlm/recover.c b/fs/dlm/recover.c
index aedea28..b2856e7 100644
--- a/fs/dlm/recover.c
+++ b/fs/dlm/recover.c
@@ -351,23 +351,20 @@ static struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)
 	return r;
 }
 
-static int recover_idr_clear_rsb(int id, void *p, void *data)
+static void recover_idr_clear(struct dlm_ls *ls)
 {
-	struct dlm_ls *ls = data;
-	struct dlm_rsb *r = p;
+	struct dlm_rsb *r;
+	int id;
 
-	r->res_id = 0;
-	r->res_recover_locks_count = 0;
-	ls->ls_recover_list_count--;
+	spin_lock(&ls->ls_recover_idr_lock);
 
-	dlm_put_rsb(r);
-	return 0;
-}
+	idr_for_each_entry(&ls->ls_recover_idr, r, id) {
+		r->res_id = 0;
+		r->res_recover_locks_count = 0;
+		ls->ls_recover_list_count--;
 
-static void recover_idr_clear(struct dlm_ls *ls)
-{
-	spin_lock(&ls->ls_recover_idr_lock);
-	idr_for_each(&ls->ls_recover_idr, recover_idr_clear_rsb, ls);
+		dlm_put_rsb(r);
+	}
 	idr_remove_all(&ls->ls_recover_idr);
 
 	if (ls->ls_recover_list_count != 0) {
-- 
1.8.1


From jpokorny@redhat.com Wed Feb  6 15:47:16 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r16KlGVH011859 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 6 Feb 2013 15:47:16 -0500
Received: from poki.brq.redhat.com (poki.brq.redhat.com [10.34.129.84])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r16KlEAO002210; Wed, 6 Feb 2013 15:47:15 -0500
From: =?UTF-8?q?Jan=20Pokorn=C3=BD?= <jpokorny@redhat.com>
To: cluster-devel@redhat.com
Date: Wed,  6 Feb 2013 21:47:11 +0100
Message-Id: <1360183631-22334-1-git-send-email-jpokorny@redhat.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH] config/tools/xml: validate resulting
	cluster.rng with relaxng.rng
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 06 Feb 2013 20:47:16 -0000

Doing so will guarantee the file is valid RELAX NG schema, not just
a valid XML.

Validating schema, relaxng.rng, was obtained directly from [1] and
matches directly to a version bundled with xmlcopyeditor in Fedora 17.
The same (modulo VCS headers, comments and spacing details) can be
obtained by combining schema as in the specification [2] and its
errata [3].

[1] http://relaxng.org/relaxng.rng
[2] http://relaxng.org/spec-20011203.html
[3] http://relaxng.org/spec-20011203-errata.html

Signed-off-by: Jan Pokorný <jpokorny@redhat.com>
---
 config/tools/xml/Makefile             |   2 +-
 config/tools/xml/ccs_update_schema.in |   3 +-
 config/tools/xml/relaxng.rng          | 335 ++++++++++++++++++++++++++++++++++
 3 files changed, 338 insertions(+), 2 deletions(-)
 create mode 100644 config/tools/xml/relaxng.rng

diff --git a/config/tools/xml/Makefile b/config/tools/xml/Makefile
index 3c9e97c..a86eb01 100644
--- a/config/tools/xml/Makefile
+++ b/config/tools/xml/Makefile
@@ -7,7 +7,7 @@ TARGET4 = cluster.rng
 
 SBINDIRT = $(TARGET1) $(TARGET2) $(TARGET3)
 SHAREDIRSYMT = $(TARGET4)
-RELAXNGDIRT = cluster.rng.in.head cluster.rng.in.tail
+RELAXNGDIRT = cluster.rng.in.head cluster.rng.in.tail relaxng.rng
 
 all: $(TARGET1) $(TARGET2) $(TARGET3) $(TARGET4)
 
diff --git a/config/tools/xml/ccs_update_schema.in b/config/tools/xml/ccs_update_schema.in
index a5aa351..16ce9f7 100644
--- a/config/tools/xml/ccs_update_schema.in
+++ b/config/tools/xml/ccs_update_schema.in
@@ -316,7 +316,8 @@ build_schema() {
 		return 1
 	}
 
-	xmllint --noout $outputdir/cluster.rng || {
+	xmllint --noout --relaxng $rngdir/relaxng.rng $outputdir/cluster.rng \
+	  || {
 		echo "generated schema does not pass xmllint validation" >&2
 		return 1
 	}
diff --git a/config/tools/xml/relaxng.rng b/config/tools/xml/relaxng.rng
new file mode 100644
index 0000000..ee6fbde
--- /dev/null
+++ b/config/tools/xml/relaxng.rng
@@ -0,0 +1,335 @@
+<?xml version="1.0"?>
+<!-- RELAX NG for RELAX NG -->
+<!-- $Id: relaxng.rng,v 1.31 2002/05/30 06:07:43 jjc Exp $ -->
+<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
+         ns="http://relaxng.org/ns/structure/1.0"
+         xmlns="http://relaxng.org/ns/structure/1.0">
+  <start>
+    <ref name="pattern"/>
+  </start>
+
+  <define name="pattern">
+    <choice>
+      <element name="element">
+        <choice>
+          <attribute name="name">
+            <data type="QName"/>
+          </attribute>
+          <ref name="open-name-class"/>
+        </choice>
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="attribute">
+        <ref name="common-atts"/>
+        <choice>
+	  <attribute name="name">
+	    <data type="QName"/>
+	  </attribute>
+          <ref name="open-name-class"/>
+        </choice>
+        <interleave>
+          <ref name="other"/>
+          <optional>
+            <ref name="pattern"/>
+          </optional>
+        </interleave>
+      </element>
+      <element name="group">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="interleave">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="choice">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="optional">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="zeroOrMore">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="oneOrMore">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="list">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="mixed">
+        <ref name="common-atts"/>
+        <ref name="open-patterns"/>
+      </element>
+      <element name="ref">
+        <attribute name="name">
+          <data type="NCName"/>
+        </attribute>
+        <ref name="common-atts"/>
+        <ref name="other"/>
+      </element>
+      <element name="parentRef">
+        <attribute name="name">
+          <data type="NCName"/>
+        </attribute>
+        <ref name="common-atts"/>
+        <ref name="other"/>
+      </element>
+      <element name="empty">
+        <ref name="common-atts"/>
+        <ref name="other"/>
+      </element>
+      <element name="text">
+        <ref name="common-atts"/>
+        <ref name="other"/>
+      </element>
+      <element name="value">
+        <optional>
+          <attribute name="type">
+            <data type="NCName"/>
+          </attribute>
+        </optional>
+        <ref name="common-atts"/>
+        <text/>
+      </element>
+      <element name="data">
+        <attribute name="type">
+          <data type="NCName"/>
+        </attribute>
+        <ref name="common-atts"/>
+        <interleave>
+          <ref name="other"/>
+          <group>
+	    <zeroOrMore>
+	      <element name="param">
+		<attribute name="name">
+		  <data type="NCName"/>
+		</attribute>
+                <ref name="common-atts"/>
+		<text/>
+	      </element>
+	    </zeroOrMore>
+            <optional>
+              <element name="except">
+		<ref name="common-atts"/>
+		<ref name="open-patterns"/>
+              </element>
+            </optional>
+          </group>
+        </interleave>
+      </element>
+      <element name="notAllowed">
+        <ref name="common-atts"/>
+        <ref name="other"/>
+      </element>
+      <element name="externalRef">
+        <attribute name="href">
+          <data type="anyURI"/>
+        </attribute>
+        <ref name="common-atts"/>
+        <ref name="other"/>
+      </element>
+      <element name="grammar">
+        <ref name="common-atts"/>
+        <ref name="grammar-content"/>
+      </element>
+    </choice>
+  </define>
+
+  <define name="grammar-content">
+    <interleave>
+      <ref name="other"/>
+      <zeroOrMore>
+        <choice>
+          <ref name="start-element"/>
+          <ref name="define-element"/>
+          <element name="div">
+            <ref name="common-atts"/>
+            <ref name="grammar-content"/>
+          </element>
+          <element name="include">
+            <attribute name="href">
+              <data type="anyURI"/>
+            </attribute>
+            <ref name="common-atts"/>
+            <ref name="include-content"/>
+          </element>
+        </choice>
+      </zeroOrMore>
+    </interleave>
+  </define>
+
+  <define name="include-content">
+    <interleave>
+      <ref name="other"/>
+      <zeroOrMore>
+        <choice>
+          <ref name="start-element"/>
+          <ref name="define-element"/>
+          <element name="div">
+            <ref name="common-atts"/>
+            <ref name="include-content"/>
+          </element>
+        </choice>
+      </zeroOrMore>
+    </interleave>
+  </define>
+
+  <define name="start-element">
+    <element name="start">
+      <ref name="combine-att"/>
+      <ref name="common-atts"/>
+      <ref name="open-pattern"/>
+    </element>
+  </define>
+
+  <define name="define-element">
+    <element name="define">
+      <attribute name="name">
+        <data type="NCName"/>
+      </attribute>
+      <ref name="combine-att"/>
+      <ref name="common-atts"/>
+      <ref name="open-patterns"/>
+    </element>
+  </define>
+
+  <define name="combine-att">
+    <optional>
+      <attribute name="combine">
+        <choice>
+          <value>choice</value>
+          <value>interleave</value>
+        </choice>
+      </attribute>
+    </optional>
+  </define>
+  
+  <define name="open-patterns">
+    <interleave>
+      <ref name="other"/>
+      <oneOrMore>
+        <ref name="pattern"/>
+      </oneOrMore>
+    </interleave>
+  </define>
+
+  <define name="open-pattern">
+    <interleave>
+      <ref name="other"/>
+      <ref name="pattern"/>
+    </interleave>
+  </define>
+
+  <define name="name-class">
+    <choice>
+      <element name="name">
+        <ref name="common-atts"/>
+        <data type="QName"/>
+      </element>
+      <element name="anyName">
+        <ref name="common-atts"/>
+        <ref name="except-name-class"/>
+      </element>
+      <element name="nsName">
+        <ref name="common-atts"/>
+        <ref name="except-name-class"/>
+      </element>
+      <element name="choice">
+        <ref name="common-atts"/>
+        <ref name="open-name-classes"/>
+      </element>
+    </choice>
+  </define>
+
+  <define name="except-name-class">
+    <interleave>
+      <ref name="other"/>
+      <optional>
+        <element name="except">
+          <ref name="open-name-classes"/>
+        </element>
+      </optional>
+    </interleave>
+  </define>
+
+  <define name="open-name-classes">
+    <interleave>
+      <ref name="other"/>
+      <oneOrMore>
+        <ref name="name-class"/>
+      </oneOrMore>
+    </interleave>
+  </define>
+
+  <define name="open-name-class">
+    <interleave>
+      <ref name="other"/>
+      <ref name="name-class"/>
+    </interleave>
+  </define>
+
+  <define name="common-atts">
+    <optional>
+      <attribute name="ns"/>
+    </optional>
+    <optional>
+      <attribute name="datatypeLibrary">
+        <data type="anyURI"/>
+      </attribute>
+    </optional>
+    <zeroOrMore>
+      <attribute>
+        <anyName>
+          <except>
+            <nsName/>
+            <nsName ns=""/>
+          </except>
+        </anyName>
+      </attribute>
+    </zeroOrMore>
+  </define>
+
+  <define name="other">
+    <zeroOrMore>
+      <element>
+        <anyName>
+          <except>
+            <nsName/>
+          </except>
+        </anyName>
+        <zeroOrMore>
+          <choice>
+            <attribute>
+              <anyName/>
+            </attribute>
+            <text/>
+            <ref name="any"/>
+          </choice>
+        </zeroOrMore>
+      </element>
+    </zeroOrMore>
+  </define>
+
+  <define name="any">
+    <element>
+      <anyName/>
+      <zeroOrMore>
+        <choice>
+          <attribute>
+            <anyName/>
+          </attribute>
+          <text/>
+          <ref name="any"/>
+        </choice>
+      </zeroOrMore>
+    </element>
+  </define>
+
+</grammar>
-- 
1.7.11.7


From fdinitto@redhat.com Thu Feb  7 03:24:26 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r178OQPH013507 for <cluster-devel@listman.util.phx.redhat.com>;
	Thu, 7 Feb 2013 03:24:26 -0500
Received: from [192.168.0.11] (ovpn-116-19.ams2.redhat.com [10.36.116.19])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r178OPHr030267
	for <cluster-devel@redhat.com>; Thu, 7 Feb 2013 03:24:25 -0500
Message-ID: <511364C5.9010607@redhat.com>
Date: Thu, 07 Feb 2013 09:24:37 +0100
From: "Fabio M. Di Nitto" <fdinitto@redhat.com>
User-Agent: Mozilla/5.0 (Windows NT 6.1;
	rv:17.0) Gecko/20130107 Thunderbird/17.0.2
MIME-Version: 1.0
To: cluster-devel@redhat.com
References: <1360183631-22334-1-git-send-email-jpokorny@redhat.com>
In-Reply-To: <1360183631-22334-1-git-send-email-jpokorny@redhat.com>
X-Enigmail-Version: 1.5
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-loop: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] [PATCH] config/tools/xml: validate resulting
 cluster.rng with relaxng.rng
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Thu, 07 Feb 2013 08:24:26 -0000

Hi Jan,

On 2/6/2013 9:47 PM, Jan Pokorný wrote:
> Doing so will guarantee the file is valid RELAX NG schema, not just
> a valid XML.
> 
> Validating schema, relaxng.rng, was obtained directly from [1] and
> matches directly to a version bundled with xmlcopyeditor in Fedora 17.
> The same (modulo VCS headers, comments and spacing details) can be
> obtained by combining schema as in the specification [2] and its
> errata [3].
> 
> [1] http://relaxng.org/relaxng.rng
> [2] http://relaxng.org/spec-20011203.html
> [3] http://relaxng.org/spec-20011203-errata.html

this looks like a good idea, but i have one question.

Is there a specific reason why we need to ship/embed the file with our
tarball? How bad is it to require the one installed on a system?

I can see it´s rather stable and hardly updated, but i prefer to avoid
duplication if we can.

Fabio

> 
> Signed-off-by: Jan Pokorný <jpokorny@redhat.com>
> ---
>  config/tools/xml/Makefile             |   2 +-
>  config/tools/xml/ccs_update_schema.in |   3 +-
>  config/tools/xml/relaxng.rng          | 335 ++++++++++++++++++++++++++++++++++
>  3 files changed, 338 insertions(+), 2 deletions(-)
>  create mode 100644 config/tools/xml/relaxng.rng
> 
> diff --git a/config/tools/xml/Makefile b/config/tools/xml/Makefile
> index 3c9e97c..a86eb01 100644
> --- a/config/tools/xml/Makefile
> +++ b/config/tools/xml/Makefile
> @@ -7,7 +7,7 @@ TARGET4 = cluster.rng
>  
>  SBINDIRT = $(TARGET1) $(TARGET2) $(TARGET3)
>  SHAREDIRSYMT = $(TARGET4)
> -RELAXNGDIRT = cluster.rng.in.head cluster.rng.in.tail
> +RELAXNGDIRT = cluster.rng.in.head cluster.rng.in.tail relaxng.rng
>  
>  all: $(TARGET1) $(TARGET2) $(TARGET3) $(TARGET4)
>  
> diff --git a/config/tools/xml/ccs_update_schema.in b/config/tools/xml/ccs_update_schema.in
> index a5aa351..16ce9f7 100644
> --- a/config/tools/xml/ccs_update_schema.in
> +++ b/config/tools/xml/ccs_update_schema.in
> @@ -316,7 +316,8 @@ build_schema() {
>  		return 1
>  	}
>  
> -	xmllint --noout $outputdir/cluster.rng || {
> +	xmllint --noout --relaxng $rngdir/relaxng.rng $outputdir/cluster.rng \
> +	  || {
>  		echo "generated schema does not pass xmllint validation" >&2
>  		return 1
>  	}


From jpokorny@redhat.com Thu Feb  7 05:49:44 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r17AninL012418 for <cluster-devel@listman.util.phx.redhat.com>;
	Thu, 7 Feb 2013 05:49:44 -0500
Received: from redhat.com (poki.brq.redhat.com [10.34.129.84])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r17Anfv9029215
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Thu, 7 Feb 2013 05:49:43 -0500
Date: Thu, 7 Feb 2013 11:49:40 +0100
From: Jan =?utf-8?Q?Pokorn=C3=BD?= <jpokorny@redhat.com>
To: cluster-devel@redhat.com
Message-ID: <20130207104940.GB28345@redhat.com>
References: <1360183631-22334-1-git-send-email-jpokorny@redhat.com>
	<511364C5.9010607@redhat.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <511364C5.9010607@redhat.com>
User-Agent: Mutt/1.5.21 (2011-07-01)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] [PATCH] config/tools/xml: validate resulting
 cluster.rng with relaxng.rng
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Thu, 07 Feb 2013 10:49:44 -0000

Hello ,

On 07/02/13 09:24 +0100, Fabio M. Di Nitto wrote:
> Hi Jan,
> 
> On 2/6/2013 9:47 PM, Jan Pokorný wrote:
>> Doing so will guarantee the file is valid RELAX NG schema, not just
>> a valid XML.
>> 
>> Validating schema, relaxng.rng, was obtained directly from [1] and
>> matches directly to a version bundled with xmlcopyeditor in Fedora 17.
>> The same (modulo VCS headers, comments and spacing details) can be
>> obtained by combining schema as in the specification [2] and its
>> errata [3].
>> 
>> [1] http://relaxng.org/relaxng.rng
>> [2] http://relaxng.org/spec-20011203.html
>> [3] http://relaxng.org/spec-20011203-errata.html
> 
> this looks like a good idea, but i have one question.
> 
> Is there a specific reason why we need to ship/embed the file with our
> tarball? How bad is it to require the one installed on a system?

It is not bad at all, but you can hardly find it system-wide.  AFAIK
there is no standard in packaging such standalone single files
anywhere yet (see also, e.g., JavaScript libraries, everything is
usually bundled).  Once there is a wide-spread standard (if ever)
where such files are located within the distributions, relaxng.rng
can be dropped and dependency can be added.

> I can see it´s rather stable and hardly updated, but i prefer to avoid
> duplication if we can.

I share the same intention, however current situation does not seem
to be offering any other choice.

-- 
Jan


From dejan@suse.de Thu Feb  7 10:06:48 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r17F6m4Y007796 for <cluster-devel@listman.util.phx.redhat.com>;
	Thu, 7 Feb 2013 10:06:48 -0500
Received: from mx1.redhat.com (ext-mx12.extmail.prod.ext.phx2.redhat.com
	[10.5.110.17])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r17F6m4X031220
	for <cluster-devel@redhat.com>; Thu, 7 Feb 2013 10:06:48 -0500
Received: from mx2.suse.de (cantor2.suse.de [195.135.220.15])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r17F6k0g006444
	for <cluster-devel@redhat.com>; Thu, 7 Feb 2013 10:06:47 -0500
Received: from relay1.suse.de (unknown [195.135.220.254])
	(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx2.suse.de (Postfix) with ESMTP id 763FEA3E1C;
	Thu,  7 Feb 2013 16:06:46 +0100 (CET)
Received: from dejan by squib.homenet with local (Exim 4.69)
	(envelope-from <dejan@suse.de>)
	id 1U3T3V-0000xe-8Q; Thu, 07 Feb 2013 16:06:29 +0100
Date: Thu, 7 Feb 2013 16:06:29 +0100
From: Dejan Muhamedagic <dejan@suse.de>
To: cluster-devel@redhat.com, linux-ha-dev@lists.linux-ha.org,
	linux-ha@lists.linux-ha.org, ha-wg-technical@lists.linux-foundation.org
Message-ID: <20130207150628.GA3655@squib>
Mail-Followup-To: cluster-devel@redhat.com,
	linux-ha-dev@lists.linux-ha.org, linux-ha@lists.linux-ha.org,
	ha-wg-technical@lists.linux-foundation.org
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.18 (2008-05-17)
X-RedHat-Spam-Score: -7.301  (BAYES_00, DCC_REPUT_00_12, RCVD_IN_DNSWL_HI,
	RP_MATCHES_RCVD)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.17
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] announcement: resource-agents release 3.9.5
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Thu, 07 Feb 2013 15:06:49 -0000

Hello,

We've tagged today (Feb 7) a new stable resource-agents release
(3.9.5) in the upstream repository.

Big thanks go to all contributors! Needless to say, without you
this release would not be possible.

The Linux-HA resource agents set changes consist mainly of bug
fixes and a few improvements and new features. The most
important fix is for the missing unsolicited ARPs issue in
IPaddr2.

The following two features are worth mentioning too:

- support for RA tracing (see the README file for more details);
  your favourite UI should provide a way to turn trace on/off

- pgsql: support starting as Hot Standby

The full list of changes for the linux-ha RA set is available in
ChangeLog:

https://github.com/ClusterLabs/resource-agents/blob/master/ChangeLog

The rgmanager resource agents set received mainly bug fixes.

Please upgrade at the earliest opportunity.

Best,

The resource-agents maintainers


From rientjes@google.com Mon Feb 11 16:48:47 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1BLml25016584 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 11 Feb 2013 16:48:47 -0500
Received: from mx1.redhat.com (ext-mx13.extmail.prod.ext.phx2.redhat.com
	[10.5.110.18])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1BLmllB009307
	for <cluster-devel@redhat.com>; Mon, 11 Feb 2013 16:48:47 -0500
Received: from mail-pa0-f50.google.com (mail-pa0-f50.google.com
	[209.85.220.50])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1BLmkWC014687
	for <cluster-devel@redhat.com>; Mon, 11 Feb 2013 16:48:46 -0500
Received: by mail-pa0-f50.google.com with SMTP id fa11so3330647pad.23
	for <cluster-devel@redhat.com>; Mon, 11 Feb 2013 13:48:45 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:message-id:user-agent
	:mime-version:content-type;
	bh=f/y3TxtbCq8W8fNQkEb2lV3EUDilJ3cC/f/ZdVrjEbk=;
	b=CvhscVIY0LjeuS7lcPljq9QMoq/Ay+QZbz7A4gLKt9mPzPb87E9VVxkhwax04ScG/y
	cNNCengl0kxnOjqdpbaITcnG5ZWTk1TwDN7tzqvtB1jGjiLgbJCjlXUCKVDiJDwUeNlF
	0qnGzb8VtUOyPdTaFTGnnEDdfAvqwqASmK7azTs4UHiJ8S/4hKPuMCr7TARhobQ/uoOz
	jGgfXH9HZVSVNICmHr0tNGSW9OaFh0PJX9NroSD32Yy4bzaq9fmAVYo+xR/uKV9I8jBV
	IS/fdj5XxS3eceF/8hTMsAxfN2AHzEiY4lI9ad9ToXJOHH542LD4f8Z6gortnKuwDDTY
	mb2A==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:message-id:user-agent
	:mime-version:content-type:x-gm-message-state;
	bh=f/y3TxtbCq8W8fNQkEb2lV3EUDilJ3cC/f/ZdVrjEbk=;
	b=Fqivhsd5CfvfIWYOZC8P259h9EapXsJqaFnZ5gK/+9moftSIngU42FYFu9BrSVu6J9
	kFrVCtnM8X4ZAVRKC97UGCSen5C60+6/ZqjC6MRBJ0TkPq33cjEy1dqV7KdSgGeW2cXZ
	oXlKvjhdPz5KXJCBVqRY9yYfNAIg7WJYn/Mm3etQep11+SjH+gEkONCNFfAX+dvt1zTD
	6A80yTQdgcPLRt5SSL4BbrLhuCV5cCB4ysgX77z7nvz3fMci+6hnHzMyxDLZlnRqxz3k
	33lVAhuzMjS96FUQ6eYkeRqSaQ2eSWYh68kisGKAP3Xz458Z4XaZBtrormK8Nq366wkZ
	RiGA==
X-Received: by 10.66.74.197 with SMTP id w5mr44804756pav.60.1360619325582;
	Mon, 11 Feb 2013 13:48:45 -0800 (PST)
Received: from [2620:0:1008:1101:be30:5bff:fed8:5e64]
	([2620:0:1008:1101:be30:5bff:fed8:5e64])
	by mx.google.com with ESMTPS id o5sm69439421pay.5.2013.02.11.13.48.44
	(version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);
	Mon, 11 Feb 2013 13:48:44 -0800 (PST)
Date: Mon, 11 Feb 2013 13:48:43 -0800 (PST)
From: David Rientjes <rientjes@google.com>
X-X-Sender: rientjes@chino.kir.corp.google.com
To: Linus Torvalds <torvalds@linux-foundation.org>,
	Christine Caulfield <ccaulfie@redhat.com>,
	David Teigland <teigland@redhat.com>
Message-ID: <alpine.DEB.2.02.1302111344140.14071@chino.kir.corp.google.com>
User-Agent: Alpine 2.02 (DEB 1266 2009-07-14)
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
X-Gm-Message-State: ALoCoQkpKfH0YM6w8BTVwBcMdkEV+PbsnrAfcfVBtHiETIymMOQPrl4/fGykiiABTqCFLyuDH5qZOdYIUOdogcWX1W6BsESB8yhMfw1z0L7LW+jGCFtGAgnBhhVB4c+cCD/3iVLmb8Gpnm/2Pa7LwXsiJ2Wa1FAfWr80A9uSc05OEcIqaICcPx3nye6rBpGcEWiOTmpByn2D
X-RedHat-Spam-Score: -2.702  (BAYES_00, DKIM_SIGNED, DKIM_VALID, DKIM_VALID_AU,
	RCVD_IN_DNSWL_LOW, RP_MATCHES_RCVD, SPF_PASS)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.18
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Tue, 12 Feb 2013 04:43:52 -0500
Cc: cluster-devel@redhat.com, linux-kernel@vger.kernel.org
Subject: [Cluster-devel] [patch for-3.8] fs,
 dlm: fix build error when EXPERIMENTAL is disabled
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 11 Feb 2013 21:48:47 -0000

CONFIG_IP_SCTP relies on being able to select things like CONFIG_CRC32C to 
build.  Thus, nothing should be selecting CONFIG_IP_SCTP that does not 
meet its requirements.

For example, if CONFIG_EXPERIMENTAL is disabled and CONFIG_DLM is enabled, 
the build fails at link time:

	net/built-in.o: In function `sctp_crc32c':
	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
	net/built-in.o:include/net/sctp/checksum.h:51: more undefined references to `crc32c' follow

Fix this by making CONFIG_DLM depend on CONFIG_EXPERIMENTAL so that 
CONFIG_IP_SCTP properly builds.

Signed-off-by: David Rientjes <rientjes@google.com>
---
 fs/dlm/Kconfig | 1 +
 1 file changed, 1 insertion(+)

diff --git a/fs/dlm/Kconfig b/fs/dlm/Kconfig
--- a/fs/dlm/Kconfig
+++ b/fs/dlm/Kconfig
@@ -2,6 +2,7 @@ menuconfig DLM
 	tristate "Distributed Lock Manager (DLM)"
 	depends on INET
 	depends on SYSFS && CONFIGFS_FS && (IPV6 || IPV6=n)
+	depends on EXPERIMENTAL
 	select IP_SCTP
 	help
 	A general purpose distributed lock manager for kernel or userspace


From swhiteho@redhat.com Tue Feb 12 04:51:26 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1C9pQag019339 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 12 Feb 2013 04:51:26 -0500
Received: from [10.10.50.118] (vpn-50-118.rdu2.redhat.com [10.10.50.118])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1C9pOFT006398; Tue, 12 Feb 2013 04:51:24 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: David Rientjes <rientjes@google.com>
In-Reply-To: <alpine.DEB.2.02.1302111344140.14071@chino.kir.corp.google.com>
References: <alpine.DEB.2.02.1302111344140.14071@chino.kir.corp.google.com>
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Tue, 12 Feb 2013 09:50:05 +0000
Message-ID: <1360662605.2719.13.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com, Linus Torvalds <torvalds@linux-foundation.org>,
	linux-kernel@vger.kernel.org
Subject: Re: [Cluster-devel] [patch for-3.8] fs,
 dlm: fix build error when EXPERIMENTAL is disabled
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 12 Feb 2013 09:51:26 -0000

Hi,

On Mon, 2013-02-11 at 13:48 -0800, David Rientjes wrote:
> CONFIG_IP_SCTP relies on being able to select things like CONFIG_CRC32C to 
> build.  Thus, nothing should be selecting CONFIG_IP_SCTP that does not 
> meet its requirements.
> 
> For example, if CONFIG_EXPERIMENTAL is disabled and CONFIG_DLM is enabled, 
> the build fails at link time:
> 
> 	net/built-in.o: In function `sctp_crc32c':
> 	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
> 	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
> 	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
> 	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
> 	include/net/sctp/checksum.h:51: undefined reference to `crc32c'
> 	net/built-in.o:include/net/sctp/checksum.h:51: more undefined references to `crc32c' follow
> 
> Fix this by making CONFIG_DLM depend on CONFIG_EXPERIMENTAL so that 
> CONFIG_IP_SCTP properly builds.
> 
That doesn't seem right to me... DLM has not been experimental for a
long time now. Why not just select CRC32 in addition to IP_SCTP ?

Steve.

> Signed-off-by: David Rientjes <rientjes@google.com>
> ---
>  fs/dlm/Kconfig | 1 +
>  1 file changed, 1 insertion(+)
> 
> diff --git a/fs/dlm/Kconfig b/fs/dlm/Kconfig
> --- a/fs/dlm/Kconfig
> +++ b/fs/dlm/Kconfig
> @@ -2,6 +2,7 @@ menuconfig DLM
>  	tristate "Distributed Lock Manager (DLM)"
>  	depends on INET
>  	depends on SYSFS && CONFIGFS_FS && (IPV6 || IPV6=n)
> +	depends on EXPERIMENTAL
>  	select IP_SCTP
>  	help
>  	A general purpose distributed lock manager for kernel or userspace
> --
> To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> Please read the FAQ at  http://www.tux.org/lkml/



From linus971@gmail.com Tue Feb 12 11:57:19 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1CGvJHi014388 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 12 Feb 2013 11:57:19 -0500
Received: from mx1.redhat.com (ext-mx15.extmail.prod.ext.phx2.redhat.com
	[10.5.110.20])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1CGvJU3026481; Tue, 12 Feb 2013 11:57:19 -0500
Received: from mail-vc0-f172.google.com (mail-vc0-f172.google.com
	[209.85.220.172])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1CGvHWP020980;
	Tue, 12 Feb 2013 11:57:18 -0500
Received: by mail-vc0-f172.google.com with SMTP id l6so186494vcl.3
	for <multiple recipients>; Tue, 12 Feb 2013 08:57:17 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
	h=x-received:mime-version:sender:in-reply-to:references:from:date
	:x-google-sender-auth:message-id:subject:to:cc:content-type;
	bh=ORUqdgJl0jc1mJvtKpYwRlbax3nwrbJDFPHbFFyd4u0=;
	b=BR+ES+LqAOfGTGw7W4iLLmgakbyHKGJGo0VODrTYmwBjtUPogypu8k4cxlx/fbFqqo
	QzoiBBtKcw3cjcr04L2AXnrtMIJR6hnBnJIWvpROxhUmZh/AVOlLreUahTSQq+mX//Js
	P+5JMNfty/lxGvLkROvuRA292rZ1TlzhCCYb3db+Ows3dSoPDjYhtfd2ugauUkPT5nk1
	fgMxNz4EoYwDLaUW5oo2ULB4pd96eoyNBlrWveqosfq6QaxYjJ9LILu9xOPP4M06cpJI
	j0CU04u/8SqN57fch4CcQlj+ICawSJnr/hni2h4QcraSX4rI/GbsR1BzPXXnE98O5p8n
	o8Cg==
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=linux-foundation.org; s=google;
	h=x-received:mime-version:sender:in-reply-to:references:from:date
	:x-google-sender-auth:message-id:subject:to:cc:content-type;
	bh=ORUqdgJl0jc1mJvtKpYwRlbax3nwrbJDFPHbFFyd4u0=;
	b=bgj8mbxCZwK88uH4iwqTrqvBgeVJEVTa/pAZSDEPmczwgCcqMItKgqYv03kdnZzUzB
	p1Alm8A1Jm92vu8JBzuKija+AFzsnUv4mSBws+862Xi0pDu810q4BjeeZn0j62fOgkr6
	PdAC0ClnD5YJlN2lkMr4ShAMRY9To9dwsidE8=
X-Received: by 10.52.26.229 with SMTP id o5mr15451281vdg.66.1360688237631;
	Tue, 12 Feb 2013 08:57:17 -0800 (PST)
MIME-Version: 1.0
Sender: linus971@gmail.com
Received: by 10.220.231.73 with HTTP; Tue, 12 Feb 2013 08:56:56 -0800 (PST)
In-Reply-To: <1360662605.2719.13.camel@menhir>
References: <alpine.DEB.2.02.1302111344140.14071@chino.kir.corp.google.com>
	<1360662605.2719.13.camel@menhir>
From: Linus Torvalds <torvalds@linux-foundation.org>
Date: Tue, 12 Feb 2013 08:56:56 -0800
X-Google-Sender-Auth: qD0f4U1MESOyYBHWwYrbZyccHJs
Message-ID: <CA+55aFzCRLy5AN24rJUvbLf5HNeumn=qtS0dA9f9+2CKOLgu7A@mail.gmail.com>
To: Steven Whitehouse <swhiteho@redhat.com>
Content-Type: text/plain; charset=UTF-8
X-RedHat-Spam-Score: -2.85  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED, DKIM_VALID,
	DKIM_VALID_AU, FREEMAIL_ENVFROM_END_DIGIT, FREEMAIL_FROM,
	RCVD_IN_DNSWL_LOW, SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.20
X-loop: cluster-devel@redhat.com
Cc: Michal Marek <mmarek@suse.cz>,
	Linux Kernel Mailing List <linux-kernel@vger.kernel.org>,
	cluster-devel@redhat.com, David Rientjes <rientjes@google.com>
Subject: Re: [Cluster-devel] [patch for-3.8] fs,
	dlm: fix build error when EXPERIMENTAL is disabled
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 12 Feb 2013 16:57:19 -0000

On Tue, Feb 12, 2013 at 1:50 AM, Steven Whitehouse <swhiteho@redhat.com> wrote:
>
> That doesn't seem right to me... DLM has not been experimental for a
> long time now. Why not just select CRC32 in addition to IP_SCTP ?

Hmm. IP_SCTP already does a "select libcrc32c". So why doesn't that
end up working?

                    Linus


From rientjes@google.com Tue Feb 12 15:13:28 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1CKDSt1014646 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 12 Feb 2013 15:13:28 -0500
Received: from mx1.redhat.com (ext-mx16.extmail.prod.ext.phx2.redhat.com
	[10.5.110.21])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1CKDSLw002857
	for <cluster-devel@redhat.com>; Tue, 12 Feb 2013 15:13:28 -0500
Received: from mail-pa0-f47.google.com (mail-pa0-f47.google.com
	[209.85.220.47])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1CKDQJY001560
	for <cluster-devel@redhat.com>; Tue, 12 Feb 2013 15:13:27 -0500
Received: by mail-pa0-f47.google.com with SMTP id bj3so280212pad.20
	for <cluster-devel@redhat.com>; Tue, 12 Feb 2013 12:13:26 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:in-reply-to
	:message-id:references:user-agent:mime-version:content-type;
	bh=RIVExHNHsQQUlm+GjFp2qvXPPFqZZfIvThGiU7Ju8R4=;
	b=IEAm26piJRbxp8nnThQ0XK2Aac/CtMhKMwzPBHDPWsBYOt53LjJ2y+xBPYLRTB1QNp
	MWiwdp1+w+7IAsRM1bj8AqgD8ZTxjt+i3hVqROd9Pd4NUn/4WF/85AsXPDevLgv+agaI
	Ag2sG1+59WnYWSoMTOi40SaFVC1G4tWiPBB/aCMadDb1vMpntBdktUteqOKTYY5u0WK2
	9n0kTxqrbqi6c+vNCPyoC6wwfSEXFnEG4PDt759CmFbmwZpE5Sw0LZdb7UxwwYgW44Bm
	ChFBuyQ6kp14ubM7ZxwT9U2bWhvBp7O5hifqVFLsOFNpaG2n2upZ5ig3DD4FJDjDQZl8
	zLLQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:in-reply-to
	:message-id:references:user-agent:mime-version:content-type
	:x-gm-message-state;
	bh=RIVExHNHsQQUlm+GjFp2qvXPPFqZZfIvThGiU7Ju8R4=;
	b=D4PhJVKCP9yjSxb1YVCM4M3BKnH9ARpCgjXdEC8a/6tKOIAQwj3aeGIlZiRGchYBOF
	Q8CUKXDGamSVKyTA6mENDQPjBTX2ybGPjD0RxqTKah7IHjY0cuPyWYipzkPilg4jVDoe
	F3P/9g9+2CmEsBgus61NyRjkhxAby0l0/6VDxY2bJpkDMaYzpwxHxDQ3v66G2Ydc4gZj
	wJKL1f1YeyqE7R60iT8fMeTOxUOEeH/AIGuAkKYx51PqqIBx2vqlvWOx+n5CTRaKhXLA
	Fk7UtcsHtoWsIzXjbIGAh91FxtSO1zsFeHWY2Tr1CDhmgEirseQ11RazDlzVk7BsR27N
	s4ew==
X-Received: by 10.66.245.14 with SMTP id xk14mr28207309pac.63.1360700006325;
	Tue, 12 Feb 2013 12:13:26 -0800 (PST)
Received: from [2620:0:1008:1101:be30:5bff:fed8:5e64]
	([2620:0:1008:1101:be30:5bff:fed8:5e64])
	by mx.google.com with ESMTPS id bi2sm77447769pab.18.2013.02.12.12.13.25
	(version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);
	Tue, 12 Feb 2013 12:13:25 -0800 (PST)
Date: Tue, 12 Feb 2013 12:13:24 -0800 (PST)
From: David Rientjes <rientjes@google.com>
X-X-Sender: rientjes@chino.kir.corp.google.com
To: Linus Torvalds <torvalds@linux-foundation.org>
In-Reply-To: <CA+55aFzCRLy5AN24rJUvbLf5HNeumn=qtS0dA9f9+2CKOLgu7A@mail.gmail.com>
Message-ID: <alpine.DEB.2.02.1302121207250.25566@chino.kir.corp.google.com>
References: <alpine.DEB.2.02.1302111344140.14071@chino.kir.corp.google.com>
	<1360662605.2719.13.camel@menhir>
	<CA+55aFzCRLy5AN24rJUvbLf5HNeumn=qtS0dA9f9+2CKOLgu7A@mail.gmail.com>
User-Agent: Alpine 2.02 (DEB 1266 2009-07-14)
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
X-Gm-Message-State: ALoCoQns+U7b7leCRi5H0w4LEIx0Kc3ADedY7DgSUdW03E2q9wqNdKrDNWM6uADE5k1BD/9fCNkFKExpA4LnH8wb0UGdSuYgxx4Wrc39j3PCBVc073mf/L5JWN4Hpm16FlizBXyA5Gh4rI9/VKVyPF1wsSJYdwXm30X44EvTyLBLrR/Rj36Afcm8iR5TGfInX4ngv400F+V6
X-RedHat-Spam-Score: -3.102  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, RCVD_IN_DNSWL_LOW, RP_MATCHES_RCVD,
	SPF_PASS)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.21
X-loop: cluster-devel@redhat.com
Cc: Michal Marek <mmarek@suse.cz>,
	Linux Kernel Mailing List <linux-kernel@vger.kernel.org>,
	cluster-devel@redhat.com
Subject: Re: [Cluster-devel] [patch for-3.8] fs,
 dlm: fix build error when EXPERIMENTAL is disabled
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 12 Feb 2013 20:13:28 -0000

On Tue, 12 Feb 2013, Linus Torvalds wrote:

> On Tue, Feb 12, 2013 at 1:50 AM, Steven Whitehouse <swhiteho@redhat.com> wrote:
> >
> > That doesn't seem right to me... DLM has not been experimental for a
> > long time now. Why not just select CRC32 in addition to IP_SCTP ?
> 
> Hmm. IP_SCTP already does a "select libcrc32c". So why doesn't that
> end up working?
> 

Kconfig won't select things that CONFIG_IP_SCTP select unless its "depends 
on" are satisfied, which is why I made CONFIG_DLM depend on 
CONFIG_EXPERIMENTAL.

Steven says DLM hasn't been experimental for a long time; sorry, but if an 
option you select is experimental then you're experimental as well.

If you'd like to push a patch that removes EXPERIMENTAL from IP_SCTP to 
David Miller, that works too.  But that is a completely separate topic 
from dlm.  For 3.8, I suggest respecting CONFIG_IP_SCTP's requirements and 
then removing EXPERIMENTAL from both if the networking guys agree.


From rientjes@google.com Tue Feb 12 19:24:59 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1D0OxLi023529 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 12 Feb 2013 19:24:59 -0500
Received: from mx1.redhat.com (ext-mx16.extmail.prod.ext.phx2.redhat.com
	[10.5.110.21])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1D0OxTl014033
	for <cluster-devel@redhat.com>; Tue, 12 Feb 2013 19:24:59 -0500
Received: from mail-da0-f49.google.com (mail-da0-f49.google.com
	[209.85.210.49])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1D0Ow9K023723
	for <cluster-devel@redhat.com>; Tue, 12 Feb 2013 19:24:58 -0500
Received: by mail-da0-f49.google.com with SMTP id t11so284146daj.36
	for <cluster-devel@redhat.com>; Tue, 12 Feb 2013 16:24:58 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:in-reply-to
	:message-id:references:user-agent:mime-version:content-type;
	bh=oyV6k7Fbu/jKRQkppPcUl6Q0L20DqJEswMjN6fcVdaI=;
	b=obtpvTxQ4VMupv0ZAhkgiYRobIt3nWSGpCIdgsgdwVcXqi3kUvkVsYD/loSAl4gr58
	huq1nZpIWT4GQq1gB18uolW/g3SCwzKM8C7TsSQfJo5e3Jf1l4S3pr0+2GDUPZk8tEaj
	s3W3ah36QdIWklbmHGKLn/KTrJsXiobG/WCCAFjIO7PN+ie3UQUmFhcDkZ+8sLwW6MJb
	jCbmvEOW+Uz/5lTF7IBjw+knyI7NYpjowHjZoV7joN5zuBOLxaKS0d3FHqDsdv0FSEV2
	z7fZzh7Vbdey7Zd7MWYB6GdgkbKxnLoRdp3UJSklca8P4Cwdy+UvGtZDlt1oebwl/1vV
	rKjg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=google.com; s=20120113;
	h=x-received:date:from:x-x-sender:to:cc:subject:in-reply-to
	:message-id:references:user-agent:mime-version:content-type
	:x-gm-message-state;
	bh=oyV6k7Fbu/jKRQkppPcUl6Q0L20DqJEswMjN6fcVdaI=;
	b=O+u72hGiq8pxwAOPz3nOobiackNpzqZGtyrAAdZ7+K+CQbjTdXWYEE9HDabEpmBwhP
	MpKhtYdAX8Xe8hav0B3NxFvvMiWn2+1E3ZDpkURqiOZpiFSYnUL9fQskVMItK0Hn40R4
	ap016sR+rNRAlUU4UFfVhCQjvxRPXZwhj527SrOzmkiHtrRbvvMgczE/Xev2RPLuf68J
	EZgtUwkmOEq6YGPt0avZYkb49IzoVWAYFM6FLrcYbzVChgK6cVBP2LHGkdn4wgm4Afkx
	hd7DkfPl40v1RnFzwEdf496TdsXABiMWCVPYU6GrEITatCOWEEtdPK8PQF8L2x4OLCY3
	O1Gw==
X-Received: by 10.66.89.199 with SMTP id bq7mr57599889pab.26.1360715098103;
	Tue, 12 Feb 2013 16:24:58 -0800 (PST)
Received: from [2620:0:1008:1101:be30:5bff:fed8:5e64]
	([2620:0:1008:1101:be30:5bff:fed8:5e64])
	by mx.google.com with ESMTPS id o5sm78779747pay.5.2013.02.12.16.24.56
	(version=TLSv1 cipher=ECDHE-RSA-RC4-SHA bits=128/128);
	Tue, 12 Feb 2013 16:24:57 -0800 (PST)
Date: Tue, 12 Feb 2013 16:24:56 -0800 (PST)
From: David Rientjes <rientjes@google.com>
X-X-Sender: rientjes@chino.kir.corp.google.com
To: Linus Torvalds <torvalds@linux-foundation.org>
In-Reply-To: <alpine.DEB.2.02.1302121207250.25566@chino.kir.corp.google.com>
Message-ID: <alpine.DEB.2.02.1302121619340.3805@chino.kir.corp.google.com>
References: <alpine.DEB.2.02.1302111344140.14071@chino.kir.corp.google.com>
	<1360662605.2719.13.camel@menhir>
	<CA+55aFzCRLy5AN24rJUvbLf5HNeumn=qtS0dA9f9+2CKOLgu7A@mail.gmail.com>
	<alpine.DEB.2.02.1302121207250.25566@chino.kir.corp.google.com>
User-Agent: Alpine 2.02 (DEB 1266 2009-07-14)
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
X-Gm-Message-State: ALoCoQmv7DWjFd3tqdJVOSbcQWQHsHHrXoW+3Ui+luTWmdh43BWxGPPqER5uG1ehcvp2n1b5S6AwrkkQ8u2z0IlkZ3FAvMDbfi7WDyFF3Crp48mcgo0EOD94QCYcHxh2BWKC4+2h/qZHgdmIbD+7+oqn2Wn5aPHJx5/v/oFknMFl4EWgh39LEyvgM8DHGQhAYjmonSFiHL++
X-RedHat-Spam-Score: -3.102  (BAYES_00, DCC_REPUT_00_12, DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, RCVD_IN_DNSWL_LOW, RP_MATCHES_RCVD,
	SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.21
X-loop: cluster-devel@redhat.com
Cc: Michal Marek <mmarek@suse.cz>, Kees Cook <keescook@chromium.org>,
	Vlad Yasevich <vyasevich@gmail.com>,
	Linux Kernel Mailing List <linux-kernel@vger.kernel.org>,
	"David S. Miller" <davem@davemloft.net>, cluster-devel@redhat.com
Subject: [Cluster-devel] [patch for-3.8] net,
	sctp: remove CONFIG_EXPERIMENTAL
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 13 Feb 2013 00:25:00 -0000

From: Kees Cook <keescook@chromium.org>

This config item has not carried much meaning for a while now and is
almost always enabled by default. As agreed during the Linux kernel
summit, remove it.

Acked-by: David S. Miller <davem@davemloft.net>
Acked-by: Vlad Yasevich <vyasevich@gmail.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Signed-off-by: David Rientjes <rientjes@google.com>
---
 Ah, look what I found in my mailbox from October 23.  The patch for dlm
 was merged, but this wasn't for some reason.  It's acked by the 
 maintainer so it should be good to go and fixes the reported build error:

        net/built-in.o: In function `sctp_crc32c':
        include/net/sctp/checksum.h:51: undefined reference to `crc32c'
        include/net/sctp/checksum.h:51: undefined reference to `crc32c'
        include/net/sctp/checksum.h:51: undefined reference to `crc32c'
        include/net/sctp/checksum.h:51: undefined reference to `crc32c'
        include/net/sctp/checksum.h:51: undefined reference to `crc32c'
        net/built-in.o:include/net/sctp/checksum.h:51: more undefined references to `crc32c' follow

 And I guess "dlm not being marked experimental for a long time" meant
 three months.

 net/sctp/Kconfig | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/sctp/Kconfig b/net/sctp/Kconfig
--- a/net/sctp/Kconfig
+++ b/net/sctp/Kconfig
@@ -3,8 +3,8 @@
 #
 
 menuconfig IP_SCTP
-	tristate "The SCTP Protocol (EXPERIMENTAL)"
-	depends on INET && EXPERIMENTAL
+	tristate "The SCTP Protocol"
+	depends on INET
 	depends on IPV6 || IPV6=n
 	select CRYPTO
 	select CRYPTO_HMAC


From swhiteho@redhat.com Wed Feb 13 04:54:58 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1D9swtH023892 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 13 Feb 2013 04:54:58 -0500
Received: from [10.10.50.220] (vpn-50-220.rdu2.redhat.com [10.10.50.220])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1D9stQP031114; Wed, 13 Feb 2013 04:54:55 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: David Rientjes <rientjes@google.com>
In-Reply-To: <alpine.DEB.2.02.1302121619340.3805@chino.kir.corp.google.com>
References: <alpine.DEB.2.02.1302111344140.14071@chino.kir.corp.google.com>
	<1360662605.2719.13.camel@menhir>
	<CA+55aFzCRLy5AN24rJUvbLf5HNeumn=qtS0dA9f9+2CKOLgu7A@mail.gmail.com>
	<alpine.DEB.2.02.1302121207250.25566@chino.kir.corp.google.com>
	<alpine.DEB.2.02.1302121619340.3805@chino.kir.corp.google.com>
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Wed, 13 Feb 2013 09:53:34 +0000
Message-ID: <1360749214.2762.9.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Cc: Michal Marek <mmarek@suse.cz>, Vlad, Kees Cook <keescook@chromium.org>,
	Yasevich <vyasevich@gmail.com>,
	Linux Kernel Mailing List <linux-kernel@vger.kernel.org>,
	cluster-devel@redhat.com, Linus Torvalds <torvalds@linux-foundation.org>,
	"David S. Miller" <davem@davemloft.net>
Subject: Re: [Cluster-devel] [patch for-3.8] net,
	sctp: remove CONFIG_EXPERIMENTAL
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 13 Feb 2013 09:54:58 -0000

Hi,

On Tue, 2013-02-12 at 16:24 -0800, David Rientjes wrote:
> From: Kees Cook <keescook@chromium.org>
> 
> This config item has not carried much meaning for a while now and is
> almost always enabled by default. As agreed during the Linux kernel
> summit, remove it.
> 
> Acked-by: David S. Miller <davem@davemloft.net>
> Acked-by: Vlad Yasevich <vyasevich@gmail.com>
> Signed-off-by: Kees Cook <keescook@chromium.org>
> Signed-off-by: David Rientjes <rientjes@google.com>
> ---
>  Ah, look what I found in my mailbox from October 23.  The patch for dlm
>  was merged, but this wasn't for some reason.  It's acked by the 
>  maintainer so it should be good to go and fixes the reported build error:
> 
>         net/built-in.o: In function `sctp_crc32c':
>         include/net/sctp/checksum.h:51: undefined reference to `crc32c'
>         include/net/sctp/checksum.h:51: undefined reference to `crc32c'
>         include/net/sctp/checksum.h:51: undefined reference to `crc32c'
>         include/net/sctp/checksum.h:51: undefined reference to `crc32c'
>         include/net/sctp/checksum.h:51: undefined reference to `crc32c'
>         net/built-in.o:include/net/sctp/checksum.h:51: more undefined references to `crc32c' follow
> 
>  And I guess "dlm not being marked experimental for a long time" meant
>  three months.
> 
Yes, I was surprised about that. We removed that tag from GFS2 back in
2010 it seems and I'm surprised that it didn't get removed from DLM at
around the same time. Either way though, it is a long time since either
have been experimental in reality, as both are stable and have many
users.

Also SCTP is only a (run time) option for DLM, and few users will
actually use it, since most people will use the TCP transport instead.

Anyway, this patch looks ok to me, so:
Acked-by: Steven Whitehouse <swhiteho@redhat.com>

Steve.


>  net/sctp/Kconfig | 4 ++--
>  1 file changed, 2 insertions(+), 2 deletions(-)
> 
> diff --git a/net/sctp/Kconfig b/net/sctp/Kconfig
> --- a/net/sctp/Kconfig
> +++ b/net/sctp/Kconfig
> @@ -3,8 +3,8 @@
>  #
>  
>  menuconfig IP_SCTP
> -	tristate "The SCTP Protocol (EXPERIMENTAL)"
> -	depends on INET && EXPERIMENTAL
> +	tristate "The SCTP Protocol"
> +	depends on INET
>  	depends on IPV6 || IPV6=n
>  	select CRYPTO
>  	select CRYPTO_HMAC



From swhiteho@redhat.com Wed Feb 13 06:00:43 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1DB0hNF004688 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 13 Feb 2013 06:00:43 -0500
Received: from [10.10.50.220] (vpn-50-220.rdu2.redhat.com [10.10.50.220])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1DB0fSB023967
	for <cluster-devel@redhat.com>; Wed, 13 Feb 2013 06:00:42 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Wed, 13 Feb 2013 10:59:21 +0000
Message-ID: <1360753161.2762.24.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Subject: Message Redacted
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 13 Feb 2013 11:00:43 -0000

Message redacted per sender's request - per INC0014154 by Red Hat Mail adminstrator

From swhiteho@redhat.com Wed Feb 13 07:54:38 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1DCscQb030089 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 13 Feb 2013 07:54:38 -0500
Received: from [10.10.50.220] (vpn-50-220.rdu2.redhat.com [10.10.50.220])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1DCsbSK004378; Wed, 13 Feb 2013 07:54:37 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Wed, 13 Feb 2013 12:53:17 +0000
Message-ID: <1360759997.2762.42.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] GFS2: Reinstate withdraw ack system
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 13 Feb 2013 12:54:38 -0000

>From fd95e81cb1c74c9acd2356821faa9f24c2fec365 Mon Sep 17 00:00:00 2001
From: Steven Whitehouse <swhiteho@redhat.com>
Date: Wed, 13 Feb 2013 12:21:40 +0000
Subject: GFS2: Reinstate withdraw ack system

This patch reinstates the ack system which withdraw should be using. It
appears to have been accidentally forgotten when the lock module was
merged into GFS2, due to two different sysfs files having the same name.

Reported-by: David Teigland <teigland@redhat.com>
Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1533cf8..e2601ba 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -642,6 +642,7 @@ struct gfs2_sbd {
 	wait_queue_head_t sd_glock_wait;
 	atomic_t sd_glock_disposal;
 	struct completion sd_locking_init;
+	struct completion sd_wdack;
 	struct delayed_work sd_control_work;
 
 	/* Inode Stuff */
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index e063f22..1b612be 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -81,6 +81,7 @@ static struct gfs2_sbd *init_sbd(struct super_block *sb)
 	init_waitqueue_head(&sdp->sd_glock_wait);
 	atomic_set(&sdp->sd_glock_disposal, 0);
 	init_completion(&sdp->sd_locking_init);
+	init_completion(&sdp->sd_wdack);
 	spin_lock_init(&sdp->sd_statfs_spin);
 
 	spin_lock_init(&sdp->sd_rindex_spin);
diff --git a/fs/gfs2/sys.c b/fs/gfs2/sys.c
index 462e841..4fb9ad8 100644
--- a/fs/gfs2/sys.c
+++ b/fs/gfs2/sys.c
@@ -330,6 +330,28 @@ static ssize_t block_store(struct gfs2_sbd *sdp, const char *buf, size_t len)
 	return ret;
 }
 
+static ssize_t wdack_show(struct gfs2_sbd *sdp, char *buf)
+{
+	int val = completion_done(&sdp->sd_wdack) ? 1 : 0;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t wdack_store(struct gfs2_sbd *sdp, const char *buf, size_t len)
+{
+	ssize_t ret = len;
+	int val;
+
+	val = simple_strtol(buf, NULL, 0);
+
+	if ((val == 1) &&
+	    !strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, "lock_dlm"))
+		complete(&sdp->sd_wdack);
+	else
+		ret = -EINVAL;
+	return ret;
+}
+
 static ssize_t lkfirst_show(struct gfs2_sbd *sdp, char *buf)
 {
 	struct lm_lockstruct *ls = &sdp->sd_lockstruct;
@@ -461,7 +483,7 @@ static struct gfs2_attr gdlm_attr_##_name = __ATTR(_name,_mode,_show,_store)
 
 GDLM_ATTR(proto_name,		0444, proto_name_show,		NULL);
 GDLM_ATTR(block,		0644, block_show,		block_store);
-GDLM_ATTR(withdraw,		0644, withdraw_show,		withdraw_store);
+GDLM_ATTR(withdraw,		0644, wdack_show,		wdack_store);
 GDLM_ATTR(jid,			0644, jid_show,			jid_store);
 GDLM_ATTR(first,		0644, lkfirst_show,		lkfirst_store);
 GDLM_ATTR(first_done,		0444, first_done_show,		NULL);
diff --git a/fs/gfs2/util.c b/fs/gfs2/util.c
index f00d7c5..6402fb6 100644
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@ -54,6 +54,9 @@ int gfs2_lm_withdraw(struct gfs2_sbd *sdp, char *fmt, ...)
 
 		kobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);
 
+		if (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, "lock_dlm"))
+			wait_for_completion(&sdp->sd_wdack);
+
 		if (lm->lm_unmount) {
 			fs_err(sdp, "telling LM to unmount\n");
 			lm->lm_unmount(sdp);
-- 
1.7.4




From dietmar@proxmox.com Wed Feb 13 12:32:35 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1DHWZPe007180 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 13 Feb 2013 12:32:35 -0500
Received: from mx1.redhat.com (ext-mx16.extmail.prod.ext.phx2.redhat.com
	[10.5.110.21])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1DHWZAc002628
	for <cluster-devel@redhat.com>; Wed, 13 Feb 2013 12:32:35 -0500
Received: from proxmox.maurer-it.com (www.maurer-it.com [213.129.239.114])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1DHWVac023890
	for <cluster-devel@redhat.com>; Wed, 13 Feb 2013 12:32:31 -0500
Received: from proxmox.maurer-it.com (localhost.localdomain [127.0.0.1])
	by proxmox.maurer-it.com (Proxmox) with ESMTP id 2F81826A0913
	for <cluster-devel@redhat.com>; Wed, 13 Feb 2013 18:32:28 +0100 (CET)
From: Dietmar Maurer <dietmar@proxmox.com>
To: "cluster-devel@redhat.com" <cluster-devel@redhat.com>
Thread-Topic: qdisk and fence race
Thread-Index: Ac4KD50neRo8oXIRSy+902E5KCj8bw==
Date: Wed, 13 Feb 2013 17:32:25 +0000
Message-ID: <24E144B8C0207547AD09C467A8259F7557A510DA@lisa.maurer-it.com>
Accept-Language: en-US, de-AT
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
X-RedHat-Spam-Score: -0.702  (BAYES_20,RCVD_IN_DNSWL_LOW,SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.21
Content-Transfer-Encoding: 8bit
X-MIME-Autoconverted: from quoted-printable to 8bit by
	lists01.pubmisc.prod.ext.phx2.redhat.com id r1DHWZPe007180
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Thu, 14 Feb 2013 04:35:34 -0500
Subject: [Cluster-devel] qdisk and fence race
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 13 Feb 2013 17:32:35 -0000

The following example is copied from 'man qdisk':

       <cman two_node="0" expected_votes="3" .../>
        <clusternodes>
            <clusternode name="node1" votes="1" ... />
            <clusternode name="node2" votes="1" ... />
        </clusternodes>
        <quorumd interval="1" tko="10" votes="1" label="testing">
            <heuristic   program="ping  A  -c1  -w1"  score="1"  interval="2" tko="3"/>
        </quorumd>

Is it true that this can still result is a fence race?

If so, what is the suggested way to avoid that? Should I configure with  master_wins="1" instead?


From davem@davemloft.net Wed Feb 13 13:57:06 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1DIv5p3030588 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 13 Feb 2013 13:57:05 -0500
Received: from mx1.redhat.com (ext-mx15.extmail.prod.ext.phx2.redhat.com
	[10.5.110.20])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1DIv5F7013759; Wed, 13 Feb 2013 13:57:05 -0500
Received: from shards.monkeyblade.net (shards.monkeyblade.net [149.20.54.216])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1DIv4Ni028728;
	Wed, 13 Feb 2013 13:57:05 -0500
Received: from localhost (nat-pool-rdu.redhat.com [66.187.233.202])
	(Authenticated sender: davem-davemloft)
	by shards.monkeyblade.net (Postfix) with ESMTPSA id C5168585543;
	Wed, 13 Feb 2013 10:57:06 -0800 (PST)
Date: Wed, 13 Feb 2013 13:57:01 -0500 (EST)
Message-Id: <20130213.135701.1997724638641487624.davem@davemloft.net>
To: rientjes@google.com
From: David Miller <davem@davemloft.net>
In-Reply-To: <alpine.DEB.2.02.1302121619340.3805@chino.kir.corp.google.com>
References: <CA+55aFzCRLy5AN24rJUvbLf5HNeumn=qtS0dA9f9+2CKOLgu7A@mail.gmail.com>
	<alpine.DEB.2.02.1302121207250.25566@chino.kir.corp.google.com>
	<alpine.DEB.2.02.1302121619340.3805@chino.kir.corp.google.com>
Mime-Version: 1.0
Content-Type: Text/Plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
X-RedHat-Spam-Score: -1.1  (BAYES_00,RCVD_IN_ANBREP_L2)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.20
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Thu, 14 Feb 2013 04:35:34 -0500
Cc: mmarek@suse.cz, keescook@chromium.org, vyasevich@gmail.com,
	linux-kernel@vger.kernel.org, cluster-devel@redhat.com,
	torvalds@linux-foundation.org
Subject: Re: [Cluster-devel] [patch for-3.8] net,
	sctp: remove CONFIG_EXPERIMENTAL
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 13 Feb 2013 18:57:07 -0000

From: David Rientjes <rientjes@google.com>
Date: Tue, 12 Feb 2013 16:24:56 -0800 (PST)

> From: Kees Cook <keescook@chromium.org>
> 
> This config item has not carried much meaning for a while now and is
> almost always enabled by default. As agreed during the Linux kernel
> summit, remove it.
> 
> Acked-by: David S. Miller <davem@davemloft.net>
> Acked-by: Vlad Yasevich <vyasevich@gmail.com>
> Signed-off-by: Kees Cook <keescook@chromium.org>
> Signed-off-by: David Rientjes <rientjes@google.com>

Applied, thanks.

From anprice@redhat.com Fri Feb 15 08:18:38 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1FDIcDJ031552 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 15 Feb 2013 08:18:38 -0500
Received: from rhlaptop.andrewprice.me.uk (ovpn-116-60.ams2.redhat.com
	[10.36.116.60])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1FDIa7l021540
	(version=TLSv1/SSLv3 cipher=DHE-RSA-CAMELLIA256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Fri, 15 Feb 2013 08:18:38 -0500
Message-ID: <511E35AC.1060306@redhat.com>
Date: Fri, 15 Feb 2013 13:18:36 +0000
From: Andrew Price <anprice@redhat.com>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/20130110 Thunderbird/17.0.2
MIME-Version: 1.0
To: cluster-devel <cluster-devel@redhat.com>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] Heads-up: retiring gfs_controld
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 15 Feb 2013 13:18:38 -0000

Hi,

Now that Fedora 16 has EOL'd we have little reason to keep gfs_controld 
and gfs_control in gfs2-utils. They're currently disabled by default but 
can be enabled with configure option --enable-gfs_controld which adds 
additional dependencies on corosynclib, clusterlib (discontinued) and 
openaislib (discontinued).

My intention is to remove gfs_control* from gfs2-utils.git before the 
next release unless there are any good reasons to keep them around.

Andy

From fdinitto@redhat.com Sat Feb 16 11:36:12 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1GGZZDM007758 for <cluster-devel@listman.util.phx.redhat.com>;
	Sat, 16 Feb 2013 11:35:35 -0500
Received: from [10.36.116.25] (ovpn-116-25.ams2.redhat.com [10.36.116.25])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1GGZYpa016020
	for <cluster-devel@redhat.com>; Sat, 16 Feb 2013 11:35:35 -0500
Message-ID: <511FB556.9070301@redhat.com>
Date: Sat, 16 Feb 2013 17:35:34 +0100
From: "Fabio M. Di Nitto" <fdinitto@redhat.com>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/20130110 Thunderbird/17.0.2
MIME-Version: 1.0
To: cluster-devel@redhat.com
References: <511E35AC.1060306@redhat.com>
In-Reply-To: <511E35AC.1060306@redhat.com>
X-Enigmail-Version: 1.5.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-loop: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] Heads-up: retiring gfs_controld
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Sat, 16 Feb 2013 16:36:38 -0000

On 02/15/2013 02:18 PM, Andrew Price wrote:
> Hi,
> 
> Now that Fedora 16 has EOL'd we have little reason to keep gfs_controld
> and gfs_control in gfs2-utils. They're currently disabled by default but
> can be enabled with configure option --enable-gfs_controld which adds
> additional dependencies on corosynclib, clusterlib (discontinued) and
> openaislib (discontinued).
> 
> My intention is to remove gfs_control* from gfs2-utils.git before the
> next release unless there are any good reasons to keep them around.
> 
> Andy
> 

Just make sure it is clear from which exact kernel version it is
possible to operate without gfs_control*. so that maintainers will not
try to backport to linux 1.0.

Fabio

From anprice@redhat.com Sun Feb 17 09:08:38 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1HE8cq3003731 for <cluster-devel@listman.util.phx.redhat.com>;
	Sun, 17 Feb 2013 09:08:38 -0500
Received: from rhlaptop.andrewprice.me.uk (ovpn-116-32.ams2.redhat.com
	[10.36.116.32])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1HE8aI3025651
	(version=TLSv1/SSLv3 cipher=DHE-RSA-CAMELLIA256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Sun, 17 Feb 2013 09:08:37 -0500
Message-ID: <5120E463.4020208@redhat.com>
Date: Sun, 17 Feb 2013 14:08:35 +0000
From: Andrew Price <anprice@redhat.com>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/20130110 Thunderbird/17.0.2
MIME-Version: 1.0
To: cluster-devel@redhat.com
References: <511E35AC.1060306@redhat.com> <511FB556.9070301@redhat.com>
In-Reply-To: <511FB556.9070301@redhat.com>
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-loop: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] Heads-up: retiring gfs_controld
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Sun, 17 Feb 2013 14:08:38 -0000

On 16/02/13 16:35, Fabio M. Di Nitto wrote:
> On 02/15/2013 02:18 PM, Andrew Price wrote:
>> Hi,
>>
>> Now that Fedora 16 has EOL'd we have little reason to keep gfs_controld
>> and gfs_control in gfs2-utils. They're currently disabled by default but
>> can be enabled with configure option --enable-gfs_controld which adds
>> additional dependencies on corosynclib, clusterlib (discontinued) and
>> openaislib (discontinued).
>>
>> My intention is to remove gfs_control* from gfs2-utils.git before the
>> next release unless there are any good reasons to keep them around.
>>
>> Andy
>>
>
> Just make sure it is clear from which exact kernel version it is
> possible to operate without gfs_control*. so that maintainers will not
> try to backport to linux 1.0.
>
> Fabio

I'd have to get confirmation on this but it looks like this commit 
obsoleted gfs_controld:

    commit e0c2a9aa1e68455dc3439e95d85cabcaff073666
    Author: David Teigland <teigland@redhat.com>
    Date:   Mon Jan 9 17:18:05 2012 -0500

        GFS2: dlm based recovery coordination

        This new method of managing recovery is an alternative to
        the previous approach of using the userland gfs_controld.
    [...]

Which was released in:

    $ git describe --contains e0c2a9aa1e68455dc3439e95d85cabcaff073666
    v3.3-rc1~77^2~4

So a little while after linux 1.0 :)

Andy

From swhiteho@redhat.com Mon Feb 18 05:28:23 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1IASNqB020635 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 18 Feb 2013 05:28:23 -0500
Received: from [10.10.48.229] (vpn-48-229.rdu2.redhat.com [10.10.48.229])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1IASMVq001117
	for <cluster-devel@redhat.com>; Mon, 18 Feb 2013 05:28:22 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Mon, 18 Feb 2013 10:27:00 +0000
Message-ID: <1361183220.2696.6.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] libgfs2: Add readahead for rgrp headers
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 18 Feb 2013 10:28:23 -0000


This adds readahead to rgrp headers, greatly improving the speed with
which they can be read in during fsck. Also, the multiple reads which
were used before are replaced with a single read per resource group.

This is an example of the kinds of speed up which may well be possible
elsewhere in the code. I started with this example simply because it was
the easiest one to do.

An alternative implementation might O_DIRECT and aio, but I'm not sure
that there would be much benefit compared with this method. A further
thought would be to use drop behind in places where we know that we will
not be looking at the data again.

Taking timings for just the rgrp reading section of fsck, I see almost a
10x speed up for that section of code using this patch on a 500G
filesystem.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/gfs2/libgfs2/buf.c b/gfs2/libgfs2/buf.c
index 5bc1a4e..68f0731 100644
--- a/gfs2/libgfs2/buf.c
+++ b/gfs2/libgfs2/buf.c
@@ -7,6 +7,7 @@
 #include <inttypes.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/time.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <errno.h>
@@ -30,39 +31,54 @@ struct gfs2_buffer_head *bget(struct gfs2_sbd *sdp, uint64_t num)
 	return bh;
 }
 
-struct gfs2_buffer_head *__bread(struct gfs2_sbd *sdp, uint64_t num, int line,
-				 const char *caller)
+int __breadm(struct gfs2_sbd *sdp, struct gfs2_buffer_head **bhs, size_t n,
+	     uint64_t block, int line, const char *caller)
 {
-	struct gfs2_buffer_head *bh = bget(sdp, num);
-	if (bh == NULL)
-		return bh;
-	if (lseek(sdp->device_fd, num * sdp->bsize, SEEK_SET) !=
-	    num * sdp->bsize) {
-		fprintf(stderr, "bad seek: %s from %s:%d: block "
-			"%llu (0x%llx)\n", strerror(errno),
-			caller, line, (unsigned long long)num,
-			(unsigned long long)num);
-		exit(-1);
+	struct iovec *iov = alloca(n * sizeof(struct iovec));
+	struct iovec *iovbase = iov;
+	uint64_t b = block;
+	size_t size = 0;
+	size_t i;
+	int ret;
+
+	for (i = 0; i < n; i++) {
+		bhs[i] = bget(sdp, b++);
+		if (bhs[i] == NULL)
+			return -1;
+		*iov++ = bhs[i]->iov;
+		size += bhs[i]->iov.iov_len;
 	}
-	if (readv(sdp->device_fd, &bh->iov, 1) < 0) {
+
+	ret = preadv(sdp->device_fd, iovbase, n, block * sdp->bsize);
+
+	if (ret != size) {
 		fprintf(stderr, "bad read: %s from %s:%d: block "
-			"%llu (0x%llx)\n", strerror(errno),
-			caller, line, (unsigned long long)num,
-			(unsigned long long)num);
+				"%llu (0x%llx)\n", strerror(errno),
+				caller, line, (unsigned long long)block,
+				(unsigned long long)block);
 		exit(-1);
 	}
-	return bh;
+
+	return 0;
+}
+
+struct gfs2_buffer_head *__bread(struct gfs2_sbd *sdp, uint64_t num, int line,
+				 const char *caller)
+{
+	struct gfs2_buffer_head *bh;
+	int ret;
+
+	ret = __breadm(sdp, &bh, 1, num, line, caller);
+	if (ret >= 0)
+		return bh;
+	return NULL;
 }
 
 int bwrite(struct gfs2_buffer_head *bh)
 {
 	struct gfs2_sbd *sdp = bh->sdp;
 
-	if (lseek(sdp->device_fd, bh->b_blocknr * sdp->bsize, SEEK_SET) !=
-	    bh->b_blocknr * sdp->bsize) {
-		return -1;
-	}
-	if (writev(sdp->device_fd, &bh->iov, 1) != bh->iov.iov_len)
+	if (pwritev(sdp->device_fd, &bh->iov, 1, bh->b_blocknr * sdp->bsize) != bh->iov.iov_len)
 		return -1;
 	sdp->writes++;
 	bh->b_modified = 0;
diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index 2b109fb..46d4d67 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -382,6 +382,7 @@ extern void gfs2_special_clear(struct special_blocks *blocklist,
 extern struct gfs2_buffer_head *bget(struct gfs2_sbd *sdp, uint64_t num);
 extern struct gfs2_buffer_head *__bread(struct gfs2_sbd *sdp, uint64_t num,
 					int line, const char *caller);
+extern int __breadm(struct gfs2_sbd *sdp, struct gfs2_buffer_head **bhs, size_t n, uint64_t block, int line, const char *caller);
 extern int bwrite(struct gfs2_buffer_head *bh);
 extern int brelse(struct gfs2_buffer_head *bh);
 extern uint32_t lgfs2_get_block_type(const struct gfs2_buffer_head *lbh);
@@ -389,6 +390,7 @@ extern uint32_t lgfs2_get_block_type(const struct gfs2_buffer_head *lbh);
 #define bmodified(bh) do { bh->b_modified = 1; } while(0)
 
 #define bread(bl, num) __bread(bl, num, __LINE__, __FUNCTION__)
+#define breadm(bl, bhs, n, block) __breadm(bl, bhs, n, block, __LINE__, __FUNCTION__)
 
 /* device_geometry.c */
 extern int lgfs2_get_dev_info(int fd, struct lgfs2_dev_info *i);
diff --git a/gfs2/libgfs2/rgrp.c b/gfs2/libgfs2/rgrp.c
index cbab2a3..f7dc01e 100644
--- a/gfs2/libgfs2/rgrp.c
+++ b/gfs2/libgfs2/rgrp.c
@@ -127,10 +127,10 @@ uint64_t gfs2_rgrp_read(struct gfs2_sbd *sdp, struct rgrp_tree *rgd)
 		return -1;
 	if (gfs2_check_range(sdp, rgd->ri.ri_addr))
 		return -1;
+	if (breadm(sdp, rgd->bh, length, rgd->ri.ri_addr))
+		return -1;
 	for (x = 0; x < length; x++){
-		rgd->bh[x] = bread(sdp, rgd->ri.ri_addr + x);
-		if(gfs2_check_meta(rgd->bh[x],
-				   (x) ? GFS2_METATYPE_RB : GFS2_METATYPE_RG))
+		if(gfs2_check_meta(rgd->bh[x], (x) ? GFS2_METATYPE_RB : GFS2_METATYPE_RG))
 		{
 			uint64_t error;
 
diff --git a/gfs2/libgfs2/super.c b/gfs2/libgfs2/super.c
index 8317862..21c9f7b 100644
--- a/gfs2/libgfs2/super.c
+++ b/gfs2/libgfs2/super.c
@@ -7,6 +7,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
+#include <fcntl.h>
 
 #include "libgfs2.h"
 #include "osi_list.h"
@@ -198,6 +199,29 @@ int rindex_read(struct gfs2_sbd *sdp, int fd, int *count1, int *sane)
 	return 0;
 }
 
+#define RA_WINDOW 32
+
+static unsigned gfs2_rgrp_reada(struct gfs2_sbd *sdp, unsigned cur_window,
+				struct osi_node *n)
+{
+	struct rgrp_tree *rgd;
+	unsigned i;
+	off_t start, len;
+
+	for (i = 0; i < RA_WINDOW; i++, n = osi_next(n)) {
+		if (n == NULL)
+			return i;
+		if (i < cur_window)
+			continue;
+		rgd = (struct rgrp_tree *)n;
+		start = rgd->ri.ri_addr * sdp->bsize;
+		len = rgd->ri.ri_length * sdp->bsize;
+		posix_fadvise(sdp->device_fd, start, len, POSIX_FADV_WILLNEED);
+	}
+
+	return i;
+}
+
 /**
  * ri_update - attach rgrps to the super block
  * @sdp: incore superblock data
@@ -218,15 +242,24 @@ static int __ri_update(struct gfs2_sbd *sdp, int fd, int *rgcount, int *sane,
 	uint64_t errblock = 0;
 	uint64_t rmax = 0;
 	struct osi_node *n, *next = NULL;
+	unsigned ra_window = 0;
+
+	/* Turn off generic readhead */
+	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_RANDOM);
 
 	if (rindex_read(sdp, fd, &count1, sane))
 		goto fail;
 	for (n = osi_first(&sdp->rgtree); n; n = next) {
 		next = osi_next(n);
 		rgd = (struct rgrp_tree *)n;
+		/* Readahead resource group headers */
+		if (ra_window < RA_WINDOW/2)
+			ra_window = gfs2_rgrp_reada(sdp, ra_window, n);
+		/* Read resource group header */
 		errblock = gfs2_rgrp_read(sdp, rgd);
 		if (errblock)
 			return errblock;
+		ra_window--;
 		count2++;
 		if (!quiet && count2 % 100 == 0) {
 			printf(".");
@@ -242,9 +275,11 @@ static int __ri_update(struct gfs2_sbd *sdp, int fd, int *rgcount, int *sane,
 	if (count1 != count2)
 		goto fail;
 
+	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_NORMAL);
 	return 0;
 
  fail:
+	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_NORMAL);
 	gfs2_rgrp_free(&sdp->rgtree);
 	return -1;
 }


From anprice@redhat.com Mon Feb 18 05:56:02 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1IAu2Hc006387 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 18 Feb 2013 05:56:02 -0500
Received: from rhlaptop.andrewprice.me.uk (ovpn-116-67.ams2.redhat.com
	[10.36.116.67])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1IAtxkO009996
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
	Mon, 18 Feb 2013 05:56:01 -0500
Message-ID: <512208BF.3070601@redhat.com>
Date: Mon, 18 Feb 2013 10:55:59 +0000
From: Andrew Price <anprice@redhat.com>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/20130110 Thunderbird/17.0.2
MIME-Version: 1.0
To: Steven Whitehouse <swhiteho@redhat.com>
References: <1361183220.2696.6.camel@menhir>
In-Reply-To: <1361183220.2696.6.camel@menhir>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] libgfs2: Add readahead for rgrp headers
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 18 Feb 2013 10:56:02 -0000

Hi,

On 18/02/13 10:27, Steven Whitehouse wrote:
>
> This adds readahead to rgrp headers, greatly improving the speed with
> which they can be read in during fsck. Also, the multiple reads which
> were used before are replaced with a single read per resource group.
>
> This is an example of the kinds of speed up which may well be possible
> elsewhere in the code. I started with this example simply because it was
> the easiest one to do.
>
> An alternative implementation might O_DIRECT and aio, but I'm not sure
> that there would be much benefit compared with this method. A further
> thought would be to use drop behind in places where we know that we will
> not be looking at the data again.
>
> Taking timings for just the rgrp reading section of fsck, I see almost a
> 10x speed up for that section of code using this patch on a 500G
> filesystem.

Looks good to me,

Andy

>
> Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
>
> diff --git a/gfs2/libgfs2/buf.c b/gfs2/libgfs2/buf.c
> index 5bc1a4e..68f0731 100644
> --- a/gfs2/libgfs2/buf.c
> +++ b/gfs2/libgfs2/buf.c
> @@ -7,6 +7,7 @@
>   #include <inttypes.h>
>   #include <sys/types.h>
>   #include <sys/stat.h>
> +#include <sys/time.h>
>   #include <fcntl.h>
>   #include <unistd.h>
>   #include <errno.h>
> @@ -30,39 +31,54 @@ struct gfs2_buffer_head *bget(struct gfs2_sbd *sdp, uint64_t num)
>   	return bh;
>   }
>
> -struct gfs2_buffer_head *__bread(struct gfs2_sbd *sdp, uint64_t num, int line,
> -				 const char *caller)
> +int __breadm(struct gfs2_sbd *sdp, struct gfs2_buffer_head **bhs, size_t n,
> +	     uint64_t block, int line, const char *caller)
>   {
> -	struct gfs2_buffer_head *bh = bget(sdp, num);
> -	if (bh == NULL)
> -		return bh;
> -	if (lseek(sdp->device_fd, num * sdp->bsize, SEEK_SET) !=
> -	    num * sdp->bsize) {
> -		fprintf(stderr, "bad seek: %s from %s:%d: block "
> -			"%llu (0x%llx)\n", strerror(errno),
> -			caller, line, (unsigned long long)num,
> -			(unsigned long long)num);
> -		exit(-1);
> +	struct iovec *iov = alloca(n * sizeof(struct iovec));
> +	struct iovec *iovbase = iov;
> +	uint64_t b = block;
> +	size_t size = 0;
> +	size_t i;
> +	int ret;
> +
> +	for (i = 0; i < n; i++) {
> +		bhs[i] = bget(sdp, b++);
> +		if (bhs[i] == NULL)
> +			return -1;
> +		*iov++ = bhs[i]->iov;
> +		size += bhs[i]->iov.iov_len;
>   	}
> -	if (readv(sdp->device_fd, &bh->iov, 1) < 0) {
> +
> +	ret = preadv(sdp->device_fd, iovbase, n, block * sdp->bsize);
> +
> +	if (ret != size) {
>   		fprintf(stderr, "bad read: %s from %s:%d: block "
> -			"%llu (0x%llx)\n", strerror(errno),
> -			caller, line, (unsigned long long)num,
> -			(unsigned long long)num);
> +				"%llu (0x%llx)\n", strerror(errno),
> +				caller, line, (unsigned long long)block,
> +				(unsigned long long)block);
>   		exit(-1);
>   	}
> -	return bh;
> +
> +	return 0;
> +}
> +
> +struct gfs2_buffer_head *__bread(struct gfs2_sbd *sdp, uint64_t num, int line,
> +				 const char *caller)
> +{
> +	struct gfs2_buffer_head *bh;
> +	int ret;
> +
> +	ret = __breadm(sdp, &bh, 1, num, line, caller);
> +	if (ret >= 0)
> +		return bh;
> +	return NULL;
>   }
>
>   int bwrite(struct gfs2_buffer_head *bh)
>   {
>   	struct gfs2_sbd *sdp = bh->sdp;
>
> -	if (lseek(sdp->device_fd, bh->b_blocknr * sdp->bsize, SEEK_SET) !=
> -	    bh->b_blocknr * sdp->bsize) {
> -		return -1;
> -	}
> -	if (writev(sdp->device_fd, &bh->iov, 1) != bh->iov.iov_len)
> +	if (pwritev(sdp->device_fd, &bh->iov, 1, bh->b_blocknr * sdp->bsize) != bh->iov.iov_len)
>   		return -1;
>   	sdp->writes++;
>   	bh->b_modified = 0;
> diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
> index 2b109fb..46d4d67 100644
> --- a/gfs2/libgfs2/libgfs2.h
> +++ b/gfs2/libgfs2/libgfs2.h
> @@ -382,6 +382,7 @@ extern void gfs2_special_clear(struct special_blocks *blocklist,
>   extern struct gfs2_buffer_head *bget(struct gfs2_sbd *sdp, uint64_t num);
>   extern struct gfs2_buffer_head *__bread(struct gfs2_sbd *sdp, uint64_t num,
>   					int line, const char *caller);
> +extern int __breadm(struct gfs2_sbd *sdp, struct gfs2_buffer_head **bhs, size_t n, uint64_t block, int line, const char *caller);
>   extern int bwrite(struct gfs2_buffer_head *bh);
>   extern int brelse(struct gfs2_buffer_head *bh);
>   extern uint32_t lgfs2_get_block_type(const struct gfs2_buffer_head *lbh);
> @@ -389,6 +390,7 @@ extern uint32_t lgfs2_get_block_type(const struct gfs2_buffer_head *lbh);
>   #define bmodified(bh) do { bh->b_modified = 1; } while(0)
>
>   #define bread(bl, num) __bread(bl, num, __LINE__, __FUNCTION__)
> +#define breadm(bl, bhs, n, block) __breadm(bl, bhs, n, block, __LINE__, __FUNCTION__)
>
>   /* device_geometry.c */
>   extern int lgfs2_get_dev_info(int fd, struct lgfs2_dev_info *i);
> diff --git a/gfs2/libgfs2/rgrp.c b/gfs2/libgfs2/rgrp.c
> index cbab2a3..f7dc01e 100644
> --- a/gfs2/libgfs2/rgrp.c
> +++ b/gfs2/libgfs2/rgrp.c
> @@ -127,10 +127,10 @@ uint64_t gfs2_rgrp_read(struct gfs2_sbd *sdp, struct rgrp_tree *rgd)
>   		return -1;
>   	if (gfs2_check_range(sdp, rgd->ri.ri_addr))
>   		return -1;
> +	if (breadm(sdp, rgd->bh, length, rgd->ri.ri_addr))
> +		return -1;
>   	for (x = 0; x < length; x++){
> -		rgd->bh[x] = bread(sdp, rgd->ri.ri_addr + x);
> -		if(gfs2_check_meta(rgd->bh[x],
> -				   (x) ? GFS2_METATYPE_RB : GFS2_METATYPE_RG))
> +		if(gfs2_check_meta(rgd->bh[x], (x) ? GFS2_METATYPE_RB : GFS2_METATYPE_RG))
>   		{
>   			uint64_t error;
>
> diff --git a/gfs2/libgfs2/super.c b/gfs2/libgfs2/super.c
> index 8317862..21c9f7b 100644
> --- a/gfs2/libgfs2/super.c
> +++ b/gfs2/libgfs2/super.c
> @@ -7,6 +7,7 @@
>   #include <stdlib.h>
>   #include <string.h>
>   #include <errno.h>
> +#include <fcntl.h>
>
>   #include "libgfs2.h"
>   #include "osi_list.h"
> @@ -198,6 +199,29 @@ int rindex_read(struct gfs2_sbd *sdp, int fd, int *count1, int *sane)
>   	return 0;
>   }
>
> +#define RA_WINDOW 32
> +
> +static unsigned gfs2_rgrp_reada(struct gfs2_sbd *sdp, unsigned cur_window,
> +				struct osi_node *n)
> +{
> +	struct rgrp_tree *rgd;
> +	unsigned i;
> +	off_t start, len;
> +
> +	for (i = 0; i < RA_WINDOW; i++, n = osi_next(n)) {
> +		if (n == NULL)
> +			return i;
> +		if (i < cur_window)
> +			continue;
> +		rgd = (struct rgrp_tree *)n;
> +		start = rgd->ri.ri_addr * sdp->bsize;
> +		len = rgd->ri.ri_length * sdp->bsize;
> +		posix_fadvise(sdp->device_fd, start, len, POSIX_FADV_WILLNEED);
> +	}
> +
> +	return i;
> +}
> +
>   /**
>    * ri_update - attach rgrps to the super block
>    * @sdp: incore superblock data
> @@ -218,15 +242,24 @@ static int __ri_update(struct gfs2_sbd *sdp, int fd, int *rgcount, int *sane,
>   	uint64_t errblock = 0;
>   	uint64_t rmax = 0;
>   	struct osi_node *n, *next = NULL;
> +	unsigned ra_window = 0;
> +
> +	/* Turn off generic readhead */
> +	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_RANDOM);
>
>   	if (rindex_read(sdp, fd, &count1, sane))
>   		goto fail;
>   	for (n = osi_first(&sdp->rgtree); n; n = next) {
>   		next = osi_next(n);
>   		rgd = (struct rgrp_tree *)n;
> +		/* Readahead resource group headers */
> +		if (ra_window < RA_WINDOW/2)
> +			ra_window = gfs2_rgrp_reada(sdp, ra_window, n);
> +		/* Read resource group header */
>   		errblock = gfs2_rgrp_read(sdp, rgd);
>   		if (errblock)
>   			return errblock;
> +		ra_window--;
>   		count2++;
>   		if (!quiet && count2 % 100 == 0) {
>   			printf(".");
> @@ -242,9 +275,11 @@ static int __ri_update(struct gfs2_sbd *sdp, int fd, int *rgcount, int *sane,
>   	if (count1 != count2)
>   		goto fail;
>
> +	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_NORMAL);
>   	return 0;
>
>    fail:
> +	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_NORMAL);
>   	gfs2_rgrp_free(&sdp->rgtree);
>   	return -1;
>   }
>
>

From swhiteho@redhat.com Mon Feb 18 12:08:22 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1IH8M6H019636 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 18 Feb 2013 12:08:22 -0500
Received: from [10.10.48.229] (vpn-48-229.rdu2.redhat.com [10.10.48.229])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1IH8Lde009529
	for <cluster-devel@redhat.com>; Mon, 18 Feb 2013 12:08:21 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Mon, 18 Feb 2013 17:06:58 +0000
Message-ID: <1361207218.2696.24.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] fsck: Speed up reading of dir leaf blocks
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 18 Feb 2013 17:08:22 -0000


This patch adds readahead for directory leaf blocks. It gives me a speed
up of only around one second on my test filesystem, however that only
has one directory with a reasonable number of files in it. So that is
actually pretty good going for that small a filesystem.

Due to the reading of the dir hash table in a single sweep, this reduces
the number of calls to read dir hash table blocks considerably.

The patch takes all the valid leaf block pointers, sorts them into disk
block order and then issues readahead requests for the blocks in order
that they are read in, in good time before they are needed.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>


diff --git a/gfs2/fsck/metawalk.c b/gfs2/fsck/metawalk.c
index f19c0f7..d8193c5 100644
--- a/gfs2/fsck/metawalk.c
+++ b/gfs2/fsck/metawalk.c
@@ -9,6 +9,7 @@
 #include <unistd.h>
 #include <libintl.h>
 #include <ctype.h>
+#include <fcntl.h>
 #define _(String) gettext(String)
 
 #include "libgfs2.h"
@@ -638,24 +639,87 @@ out_copy_old_leaf:
 	return 1;
 }
 
+static uint64_t *get_dir_hash(struct gfs2_inode *ip)
+{
+	unsigned hsize = (1 << ip->i_di.di_depth) * sizeof(uint64_t);
+	int ret;
+	uint64_t *tbl = malloc(hsize);
+
+	if (tbl == NULL)
+		return NULL;
+
+	ret = gfs2_readi(ip, tbl, 0, hsize);
+	if (ret != hsize) {
+		free(tbl);
+		return NULL;
+	}
+
+	return tbl;
+}
+
+static int u64cmp(const void *p1, const void *p2)
+{
+	uint64_t a = *(uint64_t *)p1;
+	uint64_t b = *(uint64_t *)p2;
+
+	if (a > b)
+		return 1;
+	if (b < b)
+		return -1;
+
+	return 0;
+}
+
+static void dir_leaf_reada(struct gfs2_inode *ip, uint64_t *tbl, unsigned hsize)
+{
+	uint64_t *t = alloca(hsize * sizeof(uint64_t));
+	uint64_t leaf_no;
+	struct gfs2_sbd *sdp = ip->i_sbd;
+	unsigned n = 0;
+	unsigned i;
+
+	for (i = 0; i < hsize; i++) {
+		leaf_no = be64_to_cpu(tbl[i]);
+		if (valid_block(ip->i_sbd, leaf_no))
+			t[n++] = leaf_no * sdp->bsize;
+	}
+	qsort(t, n, sizeof(uint64_t), u64cmp);
+	for (i = 0; i < n; i++)
+		posix_fadvise(sdp->device_fd, t[i], sdp->bsize, POSIX_FADV_WILLNEED);
+}
+
 /* Checks exhash directory entries */
 static int check_leaf_blks(struct gfs2_inode *ip, struct metawalk_fxns *pass)
 {
 	int error;
 	struct gfs2_leaf leaf, oldleaf;
+	unsigned hsize = (1 << ip->i_di.di_depth);
 	uint64_t leaf_no, old_leaf, bad_leaf = -1;
 	uint64_t first_ok_leaf;
 	struct gfs2_buffer_head *lbh;
 	int lindex;
 	struct gfs2_sbd *sdp = ip->i_sbd;
 	int ref_count = 0, old_was_dup;
+	uint64_t *tbl;
+
+	tbl = get_dir_hash(ip);
+	if (tbl == NULL) {
+		perror("get_dir_hash");
+		return -1;
+	}
+
+	/* Turn off system readahead */
+	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_RANDOM);
+
+	/* Readahead */
+	dir_leaf_reada(ip, tbl, hsize);
 
 	/* Find the first valid leaf pointer in range and use it as our "old"
 	   leaf. That way, bad blocks at the beginning will be overwritten
 	   with the first valid leaf. */
 	first_ok_leaf = leaf_no = -1;
-	for (lindex = 0; lindex < (1 << ip->i_di.di_depth); lindex++) {
-		gfs2_get_leaf_nr(ip, lindex, &leaf_no);
+	for (lindex = 0; lindex < hsize; lindex++) {
+		leaf_no = be64_to_cpu(tbl[lindex]);
 		if (valid_block(ip->i_sbd, leaf_no)) {
 			lbh = bread(sdp, leaf_no);
 			/* Make sure it's really a valid leaf block. */
@@ -672,19 +736,22 @@ static int check_leaf_blks(struct gfs2_inode *ip, struct metawalk_fxns *pass)
 			   "blocks\n"),
 			 (unsigned long long)ip->i_di.di_num.no_addr,
 			 (unsigned long long)ip->i_di.di_num.no_addr);
+		free(tbl);
+		posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_NORMAL);
 		return 1;
 	}
 	old_leaf = -1;
 	memset(&oldleaf, 0, sizeof(oldleaf));
 	old_was_dup = 0;
-	for (lindex = 0; lindex < (1 << ip->i_di.di_depth); lindex++) {
+	for (lindex = 0; lindex < hsize; lindex++) {
 		if (fsck_abort)
 			break;
-		gfs2_get_leaf_nr(ip, lindex, &leaf_no);
+		leaf_no = be64_to_cpu(tbl[lindex]);
 
 		/* GFS has multiple indirect pointers to the same leaf
 		 * until those extra pointers are needed, so skip the dups */
 		if (leaf_no == bad_leaf) {
+			tbl[lindex] = cpu_to_be64(old_leaf);
 			gfs2_put_leaf_nr(ip, lindex, old_leaf);
 			ref_count++;
 			continue;
@@ -694,8 +761,11 @@ static int check_leaf_blks(struct gfs2_inode *ip, struct metawalk_fxns *pass)
 		}
 
 		do {
-			if (fsck_abort)
+			if (fsck_abort) {
+				free(tbl);
+				posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_NORMAL);
 				return 0;
+			}
 			/* If the old leaf was a duplicate referenced by a
 			   previous dinode, we can't check the number of
 			   pointers because the number of pointers may be for
@@ -706,8 +776,10 @@ static int check_leaf_blks(struct gfs2_inode *ip, struct metawalk_fxns *pass)
 							     &ref_count,
 							     &lindex,
 							     &oldleaf);
-				if (error)
+				if (error) {
+					free(tbl);
 					return error;
+				}
 			}
 			error = check_leaf(ip, lindex, pass, &ref_count,
 					   &leaf_no, old_leaf, &bad_leaf,
@@ -722,6 +794,8 @@ static int check_leaf_blks(struct gfs2_inode *ip, struct metawalk_fxns *pass)
 				   (unsigned long long)leaf_no);
 		} while (1); /* while we have chained leaf blocks */
 	} /* for every leaf block */
+	free(tbl);
+	posix_fadvise(sdp->device_fd, 0, 0, POSIX_FADV_NORMAL);
 	return 0;
 }
 


From lhh@redhat.com Mon Feb 18 14:33:14 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1IJXE6C002580 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 18 Feb 2013 14:33:14 -0500
Received: from zealand.bos.redhat.com (dhcp-186-68.bos.redhat.com
	[10.16.186.68])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1IJXDwt009267; Mon, 18 Feb 2013 14:33:13 -0500
Message-ID: <512281F9.9080901@redhat.com>
Date: Mon, 18 Feb 2013 14:33:13 -0500
From: Lon Hohberger <lhh@redhat.com>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/20130110 Thunderbird/17.0.2
MIME-Version: 1.0
To: Dietmar Maurer <dietmar@proxmox.com>
References: <24E144B8C0207547AD09C467A8259F7557A510DA@lisa.maurer-it.com>
In-Reply-To: <24E144B8C0207547AD09C467A8259F7557A510DA@lisa.maurer-it.com>
X-Enigmail-Version: 1.4.6
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Cc: "cluster-devel@redhat.com" <cluster-devel@redhat.com>
Subject: Re: [Cluster-devel] qdisk and fence race
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 18 Feb 2013 19:33:14 -0000

On 02/13/2013 12:32 PM, Dietmar Maurer wrote:
> The following example is copied from 'man qdisk':
> 
>        <cman two_node="0" expected_votes="3" .../>
>         <clusternodes>
>             <clusternode name="node1" votes="1" ... />
>             <clusternode name="node2" votes="1" ... />
>         </clusternodes>
>         <quorumd interval="1" tko="10" votes="1" label="testing">
>             <heuristic   program="ping  A  -c1  -w1"  score="1"  interval="2" tko="3"/>
>         </quorumd>
> 
> Is it true that this can still result is a fence race?
> 
> If so, what is the suggested way to avoid that? Should I configure with  master_wins="1" instead?

It's best to use master_wins over a heuristic.  Ping as a tiebreaker
seems good in practice, but the problem is that there are certain
network failures where two nodes can see the thing they're pinging - but
not each other (e.g. some switch loops).

master_wins protects against this.

-- Lon

From dietmar@proxmox.com Mon Feb 18 23:51:11 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1J4pBGX015015 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 18 Feb 2013 23:51:11 -0500
Received: from mx1.redhat.com (ext-mx15.extmail.prod.ext.phx2.redhat.com
	[10.5.110.20])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1J4pBwM007980; Mon, 18 Feb 2013 23:51:11 -0500
Received: from proxmox.maurer-it.com (www.maurer-it.com [213.129.239.114])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1J4p99B006321;
	Mon, 18 Feb 2013 23:51:09 -0500
Received: from proxmox.maurer-it.com (localhost.localdomain [127.0.0.1])
	by proxmox.maurer-it.com (Proxmox) with ESMTP id 6871826A0913;
	Tue, 19 Feb 2013 05:51:05 +0100 (CET)
From: Dietmar Maurer <dietmar@proxmox.com>
To: Lon Hohberger <lhh@redhat.com>
Thread-Topic: [Cluster-devel] qdisk and fence race
Thread-Index: Ac4KD50neRo8oXIRSy+902E5KCj8bwD9suSAABWGNsA=
Date: Tue, 19 Feb 2013 04:51:03 +0000
Message-ID: <24E144B8C0207547AD09C467A8259F7557A69197@lisa.maurer-it.com>
References: <24E144B8C0207547AD09C467A8259F7557A510DA@lisa.maurer-it.com>
	<512281F9.9080901@redhat.com>
In-Reply-To: <512281F9.9080901@redhat.com>
Accept-Language: en-US, de-AT
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
X-RedHat-Spam-Score: -2.601  (BAYES_00,RCVD_IN_DNSWL_LOW,SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.20
Content-Transfer-Encoding: 8bit
X-MIME-Autoconverted: from quoted-printable to 8bit by
	lists01.pubmisc.prod.ext.phx2.redhat.com id r1J4pBGX015015
X-loop: cluster-devel@redhat.com
Cc: "cluster-devel@redhat.com" <cluster-devel@redhat.com>
Subject: Re: [Cluster-devel] qdisk and fence race
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 04:51:11 -0000

> > If so, what is the suggested way to avoid that? Should I configure with
> master_wins="1" instead?
> 
> It's best to use master_wins over a heuristic.  Ping as a tiebreaker seems
> good in practice, but the problem is that there are certain network failures
> where two nodes can see the thing they're pinging - but not each other (e.g.
> some switch loops).
> 
> master_wins protects against this.

Ok. Many thanks for your help.

- Dietmar


From swhiteho@redhat.com Tue Feb 19 05:14:01 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAE0xr017191 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:14:00 -0500
Received: from [10.10.51.154] (vpn-51-154.rdu2.redhat.com [10.10.51.154])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JADxdd026084
	for <cluster-devel@redhat.com>; Tue, 19 Feb 2013 05:14:00 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Tue, 19 Feb 2013 10:12:36 +0000
Message-ID: <1361268756.2704.5.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] fsck: Add readahead to inodes in pass1
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:14:01 -0000


Pass 1 in fsck reads all the inodes, in disk block order based upon the
rgrp bitmap. This patch adds a function to create a list of blocks of a
certain type from the rgrp bitmap. Using this list it is then possible
to do readahead on the inode blocks.

This gives me a gain of around 25% improvement in speed of overall fsck
time for my 500G test filesystem.

It is also a nice cleanup, since it splits the pass1 function into more
easily understood components.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/gfs2/fsck/pass1.c b/gfs2/fsck/pass1.c
index 540f2a9..4c67a83 100644
--- a/gfs2/fsck/pass1.c
+++ b/gfs2/fsck/pass1.c
@@ -14,6 +14,7 @@
 #include <unistd.h>
 #include <string.h>
 #include <time.h>
+#include <fcntl.h>
 #include <sys/ioctl.h>
 #include <inttypes.h>
 #include <libintl.h>
@@ -1547,6 +1548,145 @@ static int check_system_inodes(struct gfs2_sbd *sdp)
 	return 0;
 }
 
+#define RA_WINDOW 64
+
+static unsigned pass1_readahead(struct gfs2_sbd *sdp, uint64_t *ibuf, unsigned n, unsigned cur_window)
+{
+	unsigned i;
+	unsigned thresh = (n < RA_WINDOW) ? n : RA_WINDOW;
+
+	for (i = cur_window; i < thresh; i++)
+		posix_fadvise(sdp->device_fd, ibuf[i]*sdp->bsize, sdp->bsize, POSIX_FADV_WILLNEED);
+
+	return i;
+}
+
+static int pass1_process_bitmap(struct gfs2_sbd *sdp, struct rgrp_tree *rgd, uint64_t *ibuf, unsigned n)
+{
+	struct gfs2_buffer_head *bh;
+	unsigned i;
+	unsigned ra_window = 0;
+	uint64_t block;
+
+	for (i = 0; i < n; i++) {
+		block = ibuf[i];
+
+		if (ra_window < RA_WINDOW/2)
+			ra_window = pass1_readahead(sdp, ibuf + i, n - i, ra_window);
+
+		/* skip gfs1 rindex indirect blocks */
+		if (sdp->gfs1 && blockfind(&gfs1_rindex_blks, block)) {
+			log_debug(_("Skipping rindex indir block "
+				    "%lld (0x%llx)\n"),
+				  (unsigned long long)block,
+				  (unsigned long long)block);
+			continue;
+		}
+		warm_fuzzy_stuff(block);
+
+		if (fsck_abort) { /* if asked to abort */
+			gfs2_special_free(&gfs1_rindex_blks);
+			return FSCK_OK;
+		}
+		if (skip_this_pass) {
+			printf( _("Skipping pass 1 is not a good idea.\n"));
+			skip_this_pass = FALSE;
+			fflush(stdout);
+		}
+		if (fsck_system_inode(sdp, block)) {
+			log_debug(_("Already processed system inode "
+				    "%lld (0x%llx)\n"),
+				  (unsigned long long)block,
+				  (unsigned long long)block);
+			continue;
+		}
+		bh = bread(sdp, block);
+
+		if (gfs2_check_meta(bh, GFS2_METATYPE_DI)) {
+			/* In gfs2, a bitmap mark of 2 means an inode,
+			   but in gfs1 it means any metadata.  So if
+			   this is gfs1 and not an inode, it may be
+			   okay.  If it's non-dinode metadata, it will
+			   be referenced by an inode, so we need to
+			   skip it here and it will be sorted out
+			   when the referencing inode is checked. */
+			if (sdp->gfs1) {
+				uint32_t check_magic;
+
+				check_magic = ((struct gfs2_meta_header *)
+					       (bh->b_data))->mh_magic;
+				if (be32_to_cpu(check_magic) == GFS2_MAGIC) {
+					log_debug( _("Deferring GFS1 "
+						     "metadata block #"
+						     "%" PRIu64" (0x%"
+						     PRIx64 ")\n"),
+						   block, block);
+					brelse(bh);
+					continue;
+				}
+			}
+			log_err( _("Found invalid inode at block #"
+				   "%llu (0x%llx)\n"),
+				 (unsigned long long)block,
+				 (unsigned long long)block);
+			if (gfs2_blockmap_set(bl, block, gfs2_block_free)) {
+				stack;
+				brelse(bh);
+				gfs2_special_free(&gfs1_rindex_blks);
+				return FSCK_ERROR;
+			}
+			check_n_fix_bitmap(sdp, block, gfs2_block_free);
+		} else if (handle_di(sdp, bh) < 0) {
+			stack;
+			brelse(bh);
+			gfs2_special_free(&gfs1_rindex_blks);
+			return FSCK_ERROR;
+		}
+		/* Ignore everything else - they should be hit by the
+		   handle_di step.  Don't check NONE either, because
+		   check_meta passes everything if GFS2_METATYPE_NONE
+		   is specified.  Hopefully, other metadata types such
+		   as indirect blocks will be handled when the inode
+		   itself is processed, and if it's not, it should be
+		   caught in pass5. */
+		brelse(bh);
+	}
+
+	return 0;
+}
+
+static int pass1_process_rgrp(struct gfs2_sbd *sdp, struct rgrp_tree *rgd)
+{
+	unsigned k, n, i;
+	uint64_t *ibuf = malloc(sdp->bsize * GFS2_NBBY * sizeof(uint64_t));
+	int ret;
+
+	for (k = 0; k < rgd->ri.ri_length; k++) {
+		n = lgfs2_bm_scan(rgd, k, ibuf, GFS2_BLKST_DINODE);
+
+		if (n) {
+			ret = pass1_process_bitmap(sdp, rgd, ibuf, n);
+			if (ret)
+				return ret;
+		}
+
+		/*
+		  For GFS1, we have to count the "free meta" blocks in the
+		  resource group and mark them specially so we can count them
+		  properly in pass5.
+		 */
+		if (!sdp->gfs1)
+			continue;
+
+		n = lgfs2_bm_scan(rgd, k, ibuf, GFS2_BLKST_UNLINKED);
+		for (i = 0; i < n; i++)
+			gfs2_blockmap_set(bl, ibuf[i], gfs2_freemeta);
+	}
+
+	free(ibuf);
+	return 0;
+}
+
 /**
  * pass1 - walk through inodes and check inode state
  *
@@ -1563,12 +1703,10 @@ static int check_system_inodes(struct gfs2_sbd *sdp)
 int pass1(struct gfs2_sbd *sdp)
 {
 	struct osi_node *n, *next = NULL;
-	struct gfs2_buffer_head *bh;
-	uint64_t block = 0;
 	struct rgrp_tree *rgd;
-	int first;
 	uint64_t i;
 	uint64_t rg_count = 0;
+	int ret;
 
 	osi_list_init(&gfs1_rindex_blks.list);
 
@@ -1611,115 +1749,10 @@ int pass1(struct gfs2_sbd *sdp)
 			gfs2_meta_rgrp);*/
 		}
 
-		first = 1;
+		ret = pass1_process_rgrp(sdp, rgd);
+		if (ret)
+			return ret;
 
-		while (1) {
-			/* "block" is relative to the entire file system */
-			/* Get the next dinode in the file system, according
-			   to the bitmap.  This should ONLY be dinodes unless
-			   it's GFS1, in which case it can be any metadata. */
-			if (gfs2_next_rg_meta(rgd, &block, first))
-				break;
-			/* skip gfs1 rindex indirect blocks */
-			if (sdp->gfs1 && blockfind(&gfs1_rindex_blks, block)) {
-				log_debug(_("Skipping rindex indir block "
-					    "%lld (0x%llx)\n"),
-					  (unsigned long long)block,
-					  (unsigned long long)block);
-				first = 0;
-				continue;
-			}
-			warm_fuzzy_stuff(block);
-
-			if (fsck_abort) { /* if asked to abort */
-				gfs2_special_free(&gfs1_rindex_blks);
-				return FSCK_OK;
-			}
-			if (skip_this_pass) {
-				printf( _("Skipping pass 1 is not a good idea.\n"));
-				skip_this_pass = FALSE;
-				fflush(stdout);
-			}
-			if (fsck_system_inode(sdp, block)) {
-				log_debug(_("Already processed system inode "
-					    "%lld (0x%llx)\n"),
-					  (unsigned long long)block,
-					  (unsigned long long)block);
-				first = 0;
-				continue;
-			}
-			bh = bread(sdp, block);
-
-			/*log_debug( _("Checking metadata block #%" PRIu64
-			  " (0x%" PRIx64 ")\n"), block, block);*/
-
-			if (gfs2_check_meta(bh, GFS2_METATYPE_DI)) {
-				/* In gfs2, a bitmap mark of 2 means an inode,
-				   but in gfs1 it means any metadata.  So if
-				   this is gfs1 and not an inode, it may be
-				   okay.  If it's non-dinode metadata, it will
-				   be referenced by an inode, so we need to
-				   skip it here and it will be sorted out
-				   when the referencing inode is checked. */
-				if (sdp->gfs1) {
-					uint32_t check_magic;
-
-					check_magic = ((struct
-							gfs2_meta_header *)
-						       (bh->b_data))->mh_magic;
-					if (be32_to_cpu(check_magic) ==
-					    GFS2_MAGIC) {
-						log_debug( _("Deferring GFS1 "
-							     "metadata block #"
-							     "%" PRIu64" (0x%"
-							     PRIx64 ")\n"),
-							   block, block);
-						brelse(bh);
-						first = 0;
-						continue;
-					}
-				}
-				log_err( _("Found invalid inode at block #"
-					   "%llu (0x%llx)\n"),
-					 (unsigned long long)block,
-					 (unsigned long long)block);
-				if (gfs2_blockmap_set(bl, block,
-						      gfs2_block_free)) {
-					stack;
-					brelse(bh);
-					gfs2_special_free(&gfs1_rindex_blks);
-					return FSCK_ERROR;
-				}
-				check_n_fix_bitmap(sdp, block,
-						   gfs2_block_free);
-			} else if (handle_di(sdp, bh) < 0) {
-				stack;
-				brelse(bh);
-				gfs2_special_free(&gfs1_rindex_blks);
-				return FSCK_ERROR;
-			}
-			/* Ignore everything else - they should be hit by the
-			   handle_di step.  Don't check NONE either, because
-			   check_meta passes everything if GFS2_METATYPE_NONE
-			   is specified.  Hopefully, other metadata types such
-			   as indirect blocks will be handled when the inode
-			   itself is processed, and if it's not, it should be
-			   caught in pass5. */
-			brelse(bh);
-			first = 0;
-		}
-		/*
-		  For GFS1, we have to count the "free meta" blocks in the
-		  resource group and mark them specially so we can count them
-		  properly in pass5.
-		 */
-		if (!sdp->gfs1)
-			continue;
-		first = 1;
-		while (gfs2_next_rg_freemeta(rgd, &block, first) == 0) {
-			gfs2_blockmap_set(bl, block, gfs2_freemeta);
-			first = 0;
-		}
 	}
 	gfs2_special_free(&gfs1_rindex_blks);
 	return FSCK_OK;
diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index 46d4d67..db31a6c 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -757,12 +757,12 @@ extern int build_root(struct gfs2_sbd *sdp);
 extern int do_init_inum(struct gfs2_sbd *sdp);
 extern int do_init_statfs(struct gfs2_sbd *sdp);
 extern int gfs2_check_meta(struct gfs2_buffer_head *bh, int type);
+extern unsigned lgfs2_bm_scan(struct rgrp_tree *rgd, unsigned idx,
+			      uint64_t *buf, uint8_t state);
 extern int gfs2_next_rg_meta(struct rgrp_tree *rgd, uint64_t *block,
 			     int first);
 extern int gfs2_next_rg_metatype(struct gfs2_sbd *sdp, struct rgrp_tree *rgd,
 				 uint64_t *block, uint32_t type, int first);
-extern int gfs2_next_rg_freemeta(struct rgrp_tree *rgd, uint64_t *block,
-				 int first);
 
 /* super.c */
 extern int check_sb(struct gfs2_sb *sb);
diff --git a/gfs2/libgfs2/structures.c b/gfs2/libgfs2/structures.c
index 645c45a..6981072 100644
--- a/gfs2/libgfs2/structures.c
+++ b/gfs2/libgfs2/structures.c
@@ -495,6 +495,24 @@ int gfs2_check_meta(struct gfs2_buffer_head *bh, int type)
 	return 0;
 }
 
+unsigned lgfs2_bm_scan(struct rgrp_tree *rgd, unsigned idx, uint64_t *buf, uint8_t state)
+{
+	struct gfs2_bitmap *bi = &rgd->bits[idx];
+	unsigned n = 0;
+	uint32_t blk = 0;
+
+	while(blk < (bi->bi_len * GFS2_NBBY)) {
+		blk = gfs2_bitfit(rgd->bh[idx]->b_data + bi->bi_offset,
+				  bi->bi_len, blk, state);
+		if (blk == BFITNOENT)
+			break;
+		buf[n++] = blk + (bi->bi_start * GFS2_NBBY) + rgd->ri.ri_data0;
+		blk++;
+	}
+
+	return n;
+}
+
 /**
  * gfs2_next_rg_meta
  * @rgd:
@@ -545,11 +563,6 @@ int gfs2_next_rg_meta(struct rgrp_tree *rgd, uint64_t *block, int first)
 	return __gfs2_next_rg_meta(rgd, block, first, GFS2_BLKST_DINODE);
 }
 
-int gfs2_next_rg_freemeta(struct rgrp_tree *rgd, uint64_t *block, int first)
-{
-	return __gfs2_next_rg_meta(rgd, block, first, GFS2_BLKST_UNLINKED);
-}
-
 /**
  * next_rg_metatype
  * @rgd:


From swhiteho@redhat.com Tue Feb 19 05:34:00 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAY04O032703 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:00 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwpx000596; Tue, 19 Feb 2013 05:33:59 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:30 +0000
Message-Id: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] GFS2: Pre-pull patch posting (merge window)
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:00 -0000

This is one of the smallest collections of patches for the merge
window for some time. There are some clean ups relating to the
transaction code and the shrinker, which are mostly in preparation
for further development, but also make the code much easier to
follow in these areas.

There is a patch which allows the use of ->writepages even in the
default ordered write mode for all writebacks. This results in
sending larger i/os to the block layer, and a subsequent increase
in performance. It also reduces the number of different i/o paths
by one.

There is also a bug fix reinstating the withdraw ack system which
somehow got lost when the lock modules were merged into GFS2.

And thats all this time around,

Steve.

From swhiteho@redhat.com Tue Feb 19 05:34:01 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAY1uU032713 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:01 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq0000596; Tue, 19 Feb 2013 05:34:00 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:31 +0000
Message-Id: <1361268460-3092-2-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 01/10] GFS2: Separate LRU scanning from
	shrinker
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:01 -0000

This breaks out the LRU scanning function from the shrinker in
preparation for adding other callers to the LRU scanner.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 992c5c0..3ad8fd3 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -1376,23 +1376,19 @@ void gfs2_glock_complete(struct gfs2_glock *gl, int ret)
 		gfs2_glock_put(gl);
 }
 
+/**
+ * gfs2_scan_glock_lru - Scan the LRU looking for locks to demote
+ * @nr: The number of entries to scan
+ *
+ */
 
-static int gfs2_shrink_glock_memory(struct shrinker *shrink,
-				    struct shrink_control *sc)
+static void gfs2_scan_glock_lru(int nr)
 {
 	struct gfs2_glock *gl;
 	int may_demote;
 	int nr_skipped = 0;
-	int nr = sc->nr_to_scan;
-	gfp_t gfp_mask = sc->gfp_mask;
 	LIST_HEAD(skipped);
 
-	if (nr == 0)
-		goto out;
-
-	if (!(gfp_mask & __GFP_FS))
-		return -1;
-
 	spin_lock(&lru_lock);
 	while(nr && !list_empty(&lru_list)) {
 		gl = list_entry(lru_list.next, struct gfs2_glock, gl_lru);
@@ -1425,7 +1421,17 @@ static int gfs2_shrink_glock_memory(struct shrinker *shrink,
 	list_splice(&skipped, &lru_list);
 	atomic_add(nr_skipped, &lru_count);
 	spin_unlock(&lru_lock);
-out:
+}
+
+static int gfs2_shrink_glock_memory(struct shrinker *shrink,
+				    struct shrink_control *sc)
+{
+	if (sc->nr_to_scan) {
+		if (!(sc->gfp_mask & __GFP_FS))
+			return -1;
+		gfs2_scan_glock_lru(sc->nr_to_scan);
+	}
+
 	return (atomic_read(&lru_count) / 100) * sysctl_vfs_cache_pressure;
 }
 
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:03 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAY328032723 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:03 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq1000596; Tue, 19 Feb 2013 05:34:02 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:32 +0000
Message-Id: <1361268460-3092-3-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 02/10] GFS2: Merge revoke adding functions
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:03 -0000

This moves the lo_add function for revokes into trans.c, removing
a function call and making the code easier to read.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/lops.c b/fs/gfs2/lops.c
index 9ceccb1..9c80742 100644
--- a/fs/gfs2/lops.c
+++ b/fs/gfs2/lops.c
@@ -600,20 +600,6 @@ static void buf_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)
 	        jd->jd_jid, sdp->sd_replayed_blocks, sdp->sd_found_blocks);
 }
 
-static void revoke_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
-{
-	struct gfs2_glock *gl = bd->bd_gl;
-	struct gfs2_trans *tr;
-
-	tr = current->journal_info;
-	tr->tr_touched = 1;
-	tr->tr_num_revoke++;
-	sdp->sd_log_num_revoke++;
-	atomic_inc(&gl->gl_revokes);
-	set_bit(GLF_LFLUSH, &gl->gl_flags);
-	list_add(&bd->bd_list, &sdp->sd_log_le_revoke);
-}
-
 static void revoke_lo_before_commit(struct gfs2_sbd *sdp)
 {
 	struct gfs2_meta_header *mh;
@@ -895,7 +881,6 @@ const struct gfs2_log_operations gfs2_buf_lops = {
 };
 
 const struct gfs2_log_operations gfs2_revoke_lops = {
-	.lo_add = revoke_lo_add,
 	.lo_before_commit = revoke_lo_before_commit,
 	.lo_after_commit = revoke_lo_after_commit,
 	.lo_before_scan = revoke_lo_before_scan,
diff --git a/fs/gfs2/trans.c b/fs/gfs2/trans.c
index 4136270..6f3ddbc 100644
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@ -175,11 +175,19 @@ void gfs2_trans_add_bh(struct gfs2_glock *gl, struct buffer_head *bh, int meta)
 
 void gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
 {
+	struct gfs2_glock *gl = bd->bd_gl;
+	struct gfs2_trans *tr = current->journal_info;
+
 	BUG_ON(!list_empty(&bd->bd_list));
 	BUG_ON(!list_empty(&bd->bd_ail_st_list));
 	BUG_ON(!list_empty(&bd->bd_ail_gl_list));
 	lops_init_le(bd, &gfs2_revoke_lops);
-	lops_add(sdp, bd);
+	tr->tr_touched = 1;
+	tr->tr_num_revoke++;
+	sdp->sd_log_num_revoke++;
+	atomic_inc(&gl->gl_revokes);
+	set_bit(GLF_LFLUSH, &gl->gl_flags);
+	list_add(&bd->bd_list, &sdp->sd_log_le_revoke);
 }
 
 void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:04 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAY4mJ032733 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:04 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq2000596; Tue, 19 Feb 2013 05:34:03 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:33 +0000
Message-Id: <1361268460-3092-4-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 03/10] GFS2: Split gfs2_trans_add_bh() into
	two
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:04 -0000

There is little common content in gfs2_trans_add_bh() between the data
and meta classes by the time that the functions which it calls are
taken into account. The intent here is to split this into two
separate functions. Stage one is to introduce gfs2_trans_add_data()
and gfs2_trans_add_meta() and update the callers accordingly.

Later patches will then pull in the content of gfs2_trans_add_bh()
and its dependent functions in order to clean up the code in this
area.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/aops.c b/fs/gfs2/aops.c
index 30de4f2..92340dd 100644
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@ -51,7 +51,7 @@ static void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,
 			continue;
 		if (gfs2_is_jdata(ip))
 			set_buffer_uptodate(bh);
-		gfs2_trans_add_bh(ip->i_gl, bh, 0);
+		gfs2_trans_add_data(ip->i_gl, bh);
 	}
 }
 
@@ -852,7 +852,7 @@ static int gfs2_write_end(struct file *file, struct address_space *mapping,
 		goto failed;
 	}
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 
 	if (gfs2_is_stuffed(ip))
 		return gfs2_stuffed_write_end(inode, dibh, pos, len, copied, page);
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index a68e91b..7a86275 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -93,7 +93,7 @@ static int gfs2_unstuffer_page(struct gfs2_inode *ip, struct buffer_head *dibh,
 	if (!gfs2_is_jdata(ip))
 		mark_buffer_dirty(bh);
 	if (!gfs2_is_writeback(ip))
-		gfs2_trans_add_bh(ip->i_gl, bh, 0);
+		gfs2_trans_add_data(ip->i_gl, bh);
 
 	if (release) {
 		unlock_page(page);
@@ -153,7 +153,7 @@ int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)
 
 	/*  Set up the pointer to the new block  */
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	di = (struct gfs2_dinode *)dibh->b_data;
 	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
 
@@ -405,7 +405,7 @@ static inline __be64 *gfs2_indirect_init(struct metapath *mp,
 	BUG_ON(i < 1);
 	BUG_ON(mp->mp_bh[i] != NULL);
 	mp->mp_bh[i] = gfs2_meta_new(gl, bn);
-	gfs2_trans_add_bh(gl, mp->mp_bh[i], 1);
+	gfs2_trans_add_meta(gl, mp->mp_bh[i]);
 	gfs2_metatype_set(mp->mp_bh[i], GFS2_METATYPE_IN, GFS2_FORMAT_IN);
 	gfs2_buffer_clear_tail(mp->mp_bh[i], sizeof(struct gfs2_meta_header));
 	ptr += offset;
@@ -468,7 +468,7 @@ static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,
 	BUG_ON(sheight < 1);
 	BUG_ON(dibh == NULL);
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 
 	if (height == sheight) {
 		struct buffer_head *bh;
@@ -544,7 +544,7 @@ static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,
 		/* Branching from existing tree */
 		case ALLOC_GROW_DEPTH:
 			if (i > 1 && i < height)
-				gfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);
+				gfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);
 			for (; i < height && n > 0; i++, n--)
 				gfs2_indirect_init(mp, ip->i_gl, i,
 						   mp->mp_list[i-1], bn++);
@@ -556,7 +556,7 @@ static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,
 		case ALLOC_DATA:
 			BUG_ON(n > dblks);
 			BUG_ON(mp->mp_bh[end_of_metadata] == NULL);
-			gfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);
+			gfs2_trans_add_meta(ip->i_gl, mp->mp_bh[end_of_metadata]);
 			dblks = n;
 			ptr = metapointer(end_of_metadata, mp);
 			dblock = bn;
@@ -796,8 +796,8 @@ static int do_strip(struct gfs2_inode *ip, struct buffer_head *dibh,
 
 	down_write(&ip->i_rw_mutex);
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 
 	bstart = 0;
 	blen = 0;
@@ -981,7 +981,7 @@ static int gfs2_block_truncate_page(struct address_space *mapping, loff_t from)
 	}
 
 	if (!gfs2_is_writeback(ip))
-		gfs2_trans_add_bh(ip->i_gl, bh, 0);
+		gfs2_trans_add_data(ip->i_gl, bh);
 
 	zero_user(page, offset, length);
 	mark_buffer_dirty(bh);
@@ -1046,7 +1046,7 @@ static int trunc_start(struct inode *inode, u64 oldsize, u64 newsize)
 	if (error)
 		goto out;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 
 	if (gfs2_is_stuffed(ip)) {
 		gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode) + newsize);
@@ -1141,7 +1141,7 @@ static int trunc_end(struct gfs2_inode *ip)
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 	ip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_dinode_out(ip, dibh->b_data);
 	brelse(dibh);
 
@@ -1246,7 +1246,7 @@ static int do_grow(struct inode *inode, u64 size)
 
 	i_size_write(inode, size);
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_dinode_out(ip, dibh->b_data);
 	brelse(dibh);
 
diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 9a35670..7179478 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -93,7 +93,7 @@ int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
 	struct buffer_head *bh;
 
 	bh = gfs2_meta_new(ip->i_gl, block);
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	gfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);
 	gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
 	*bhp = bh;
@@ -127,7 +127,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 	if (error)
 		return error;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
 	if (ip->i_inode.i_size < offset + size)
 		i_size_write(&ip->i_inode, offset + size);
@@ -209,7 +209,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 		if (error)
 			goto fail;
 
-		gfs2_trans_add_bh(ip->i_gl, bh, 1);
+		gfs2_trans_add_meta(ip->i_gl, bh);
 		memcpy(bh->b_data + o, buf, amount);
 		brelse(bh);
 
@@ -231,7 +231,7 @@ out:
 		i_size_write(&ip->i_inode, offset + copied);
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_dinode_out(ip, dibh->b_data);
 	brelse(dibh);
 
@@ -647,7 +647,7 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 		return;
 	}
 
-	gfs2_trans_add_bh(dip->i_gl, bh, 1);
+	gfs2_trans_add_meta(dip->i_gl, bh);
 
 	/* If there is no prev entry, this is the first entry in the block.
 	   The de_rec_len is already as big as it needs to be.  Just zero
@@ -690,7 +690,7 @@ static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
 		offset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
 	totlen = be16_to_cpu(dent->de_rec_len);
 	BUG_ON(offset + name->len > totlen);
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	ndent = (struct gfs2_dirent *)((char *)dent + offset);
 	dent->de_rec_len = cpu_to_be16(offset);
 	gfs2_qstr2dirent(name, totlen - offset, ndent);
@@ -831,7 +831,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 		return NULL;
 
 	gfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	leaf = (struct gfs2_leaf *)bh->b_data;
 	leaf->lf_depth = cpu_to_be16(depth);
@@ -916,7 +916,7 @@ static int dir_make_exhash(struct inode *inode)
 	/*  We're done with the new leaf block, now setup the new
 	    hash table.  */
 
-	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(dip->i_gl, dibh);
 	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
 
 	lp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));
@@ -976,7 +976,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 		return 1; /* can't split */
 	}
 
-	gfs2_trans_add_bh(dip->i_gl, obh, 1);
+	gfs2_trans_add_meta(dip->i_gl, obh);
 
 	nleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);
 	if (!nleaf) {
@@ -1069,7 +1069,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {
-		gfs2_trans_add_bh(dip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(dip->i_gl, dibh);
 		gfs2_add_inode_blocks(&dip->i_inode, 1);
 		gfs2_dinode_out(dip, dibh->b_data);
 		brelse(dibh);
@@ -1622,7 +1622,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 			return error;
 	} while(1);
 
-	gfs2_trans_add_bh(ip->i_gl, obh, 1);
+	gfs2_trans_add_meta(ip->i_gl, obh);
 
 	leaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));
 	if (!leaf) {
@@ -1636,7 +1636,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 	error = gfs2_meta_inode_buffer(ip, &bh);
 	if (error)
 		return error;
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	gfs2_add_inode_blocks(&ip->i_inode, 1);
 	gfs2_dinode_out(ip, bh->b_data);
 	brelse(bh);
@@ -1795,7 +1795,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 	if (IS_ERR(dent))
 		return PTR_ERR(dent);
 
-	gfs2_trans_add_bh(dip->i_gl, bh, 1);
+	gfs2_trans_add_meta(dip->i_gl, bh);
 	gfs2_inum_out(nip, dent);
 	dent->de_type = cpu_to_be16(new_type);
 
@@ -1804,7 +1804,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		error = gfs2_meta_inode_buffer(dip, &bh);
 		if (error)
 			return error;
-		gfs2_trans_add_bh(dip->i_gl, bh, 1);
+		gfs2_trans_add_meta(dip->i_gl, bh);
 	}
 
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
@@ -1917,7 +1917,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (error)
 		goto out_end_trans;
 
-	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(dip->i_gl, dibh);
 	/* On the last dealloc, make this a regular file in case we crash.
 	   (We don't want to free these blocks a second time.)  */
 	if (last_dealloc)
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index 991ab2d..06b7092 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -276,7 +276,7 @@ static int do_gfs2_set_flags(struct file *filp, u32 reqflags, u32 mask)
 	error = gfs2_meta_inode_buffer(ip, &bh);
 	if (error)
 		goto out_trans_end;
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	ip->i_diskflags = new_flags;
 	gfs2_dinode_out(ip, bh->b_data);
 	brelse(bh);
@@ -709,7 +709,7 @@ static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,
 	if (unlikely(error))
 		return error;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 
 	if (gfs2_is_stuffed(ip)) {
 		error = gfs2_unstuff_dinode(ip, NULL);
diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c
index 2b6f569..db048a8 100644
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@ -447,7 +447,7 @@ static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 	struct timespec tv = CURRENT_TIME;
 
 	dibh = gfs2_meta_new(ip->i_gl, ip->i_no_addr);
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_metatype_set(dibh, GFS2_METATYPE_DI, GFS2_FORMAT_DI);
 	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
 	di = (struct gfs2_dinode *)dibh->b_data;
@@ -584,7 +584,7 @@ static int link_dinode(struct gfs2_inode *dip, const struct qstr *name,
 	if (error)
 		goto fail_end_trans;
 	set_nlink(&ip->i_inode, S_ISDIR(ip->i_inode.i_mode) ? 2 : 1);
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_dinode_out(ip, dibh->b_data);
 	brelse(dibh);
 	return 0;
@@ -931,7 +931,7 @@ static int gfs2_link(struct dentry *old_dentry, struct inode *dir,
 	if (error)
 		goto out_brelse;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	inc_nlink(&ip->i_inode);
 	ip->i_inode.i_ctime = CURRENT_TIME;
 	ihold(inode);
@@ -1412,7 +1412,7 @@ static int gfs2_rename(struct inode *odir, struct dentry *odentry,
 		if (error)
 			goto out_end_trans;
 		ip->i_inode.i_ctime = CURRENT_TIME;
-		gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(ip->i_gl, dibh);
 		gfs2_dinode_out(ip, dibh->b_data);
 		brelse(dibh);
 	}
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index ae55e24..06122d0 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -590,7 +590,7 @@ static void do_qc(struct gfs2_quota_data *qd, s64 change)
 	s64 x;
 
 	mutex_lock(&sdp->sd_quota_mutex);
-	gfs2_trans_add_bh(ip->i_gl, qd->qd_bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, qd->qd_bh);
 
 	if (!test_bit(QDF_CHANGE, &qd->qd_flags)) {
 		qc->qc_change = 0;
@@ -726,7 +726,7 @@ get_a_page:
 			goto unlock_out;
 	}
 
-	gfs2_trans_add_bh(ip->i_gl, bh, 0);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 
 	kaddr = kmap_atomic(page);
 	if (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index b7eff07..52c2aea 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -1323,7 +1323,7 @@ int gfs2_fitrim(struct file *filp, void __user *argp)
 			if (ret == 0) {
 				bh = rgd->rd_bits[0].bi_bh;
 				rgd->rd_flags |= GFS2_RGF_TRIMMED;
-				gfs2_trans_add_bh(rgd->rd_gl, bh, 1);
+				gfs2_trans_add_meta(rgd->rd_gl, bh);
 				gfs2_rgrp_out(rgd, bh->b_data);
 				gfs2_rgrp_ondisk2lvb(rgd->rd_rgl, bh->b_data);
 				gfs2_trans_end(sdp);
@@ -1968,14 +1968,14 @@ static void gfs2_alloc_extent(const struct gfs2_rbm *rbm, bool dinode,
 
 	*n = 1;
 	block = gfs2_rbm_to_block(rbm);
-	gfs2_trans_add_bh(rbm->rgd->rd_gl, rbm->bi->bi_bh, 1);
+	gfs2_trans_add_meta(rbm->rgd->rd_gl, rbm->bi->bi_bh);
 	gfs2_setbit(rbm, true, dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);
 	block++;
 	while (*n < elen) {
 		ret = gfs2_rbm_from_block(&pos, block);
 		if (ret || gfs2_testbit(&pos) != GFS2_BLKST_FREE)
 			break;
-		gfs2_trans_add_bh(pos.rgd->rd_gl, pos.bi->bi_bh, 1);
+		gfs2_trans_add_meta(pos.rgd->rd_gl, pos.bi->bi_bh);
 		gfs2_setbit(&pos, true, GFS2_BLKST_USED);
 		(*n)++;
 		block++;
@@ -2014,7 +2014,7 @@ static struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,
 			       rbm.bi->bi_bh->b_data + rbm.bi->bi_offset,
 			       rbm.bi->bi_len);
 		}
-		gfs2_trans_add_bh(rbm.rgd->rd_gl, rbm.bi->bi_bh, 1);
+		gfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.bi->bi_bh);
 		gfs2_setbit(&rbm, false, new_state);
 	}
 
@@ -2157,7 +2157,7 @@ int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,
 		if (error == 0) {
 			struct gfs2_dinode *di =
 				(struct gfs2_dinode *)dibh->b_data;
-			gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+			gfs2_trans_add_meta(ip->i_gl, dibh);
 			di->di_goal_meta = di->di_goal_data =
 				cpu_to_be64(ip->i_goal);
 			brelse(dibh);
@@ -2176,7 +2176,7 @@ int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,
 			*generation = rbm.rgd->rd_igeneration++;
 	}
 
-	gfs2_trans_add_bh(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh, 1);
+	gfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);
 	gfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);
 	gfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);
 
@@ -2223,7 +2223,7 @@ void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta)
 	trace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);
 	rgd->rd_free += blen;
 	rgd->rd_flags &= ~GFS2_RGF_TRIMMED;
-	gfs2_trans_add_bh(rgd->rd_gl, rgd->rd_bits[0].bi_bh, 1);
+	gfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);
 	gfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);
 	gfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);
 
@@ -2260,7 +2260,7 @@ void gfs2_unlink_di(struct inode *inode)
 	if (!rgd)
 		return;
 	trace_gfs2_block_alloc(ip, rgd, blkno, 1, GFS2_BLKST_UNLINKED);
-	gfs2_trans_add_bh(rgd->rd_gl, rgd->rd_bits[0].bi_bh, 1);
+	gfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);
 	gfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);
 	gfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);
 	update_rgrp_lvb_unlinked(rgd, 1);
@@ -2281,7 +2281,7 @@ static void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, u64 blkno)
 	rgd->rd_dinodes--;
 	rgd->rd_free++;
 
-	gfs2_trans_add_bh(rgd->rd_gl, rgd->rd_bits[0].bi_bh, 1);
+	gfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);
 	gfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);
 	gfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);
 	update_rgrp_lvb_unlinked(rgd, -1);
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index d648867..4dfda4c 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -500,7 +500,7 @@ void gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,
 	if (error)
 		return;
 
-	gfs2_trans_add_bh(l_ip->i_gl, l_bh, 1);
+	gfs2_trans_add_meta(l_ip->i_gl, l_bh);
 
 	spin_lock(&sdp->sd_statfs_spin);
 	l_sc->sc_total += total;
@@ -528,7 +528,7 @@ void update_statfs(struct gfs2_sbd *sdp, struct buffer_head *m_bh,
 	struct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;
 	struct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;
 
-	gfs2_trans_add_bh(l_ip->i_gl, l_bh, 1);
+	gfs2_trans_add_meta(l_ip->i_gl, l_bh);
 
 	spin_lock(&sdp->sd_statfs_spin);
 	m_sc->sc_total += l_sc->sc_total;
@@ -539,7 +539,7 @@ void update_statfs(struct gfs2_sbd *sdp, struct buffer_head *m_bh,
 	       0, sizeof(struct gfs2_statfs_change));
 	spin_unlock(&sdp->sd_statfs_spin);
 
-	gfs2_trans_add_bh(m_ip->i_gl, m_bh, 1);
+	gfs2_trans_add_meta(m_ip->i_gl, m_bh);
 	gfs2_statfs_change_out(m_sc, m_bh->b_data + sizeof(struct gfs2_dinode));
 }
 
@@ -824,7 +824,7 @@ static void gfs2_dirty_inode(struct inode *inode, int flags)
 
 	ret = gfs2_meta_inode_buffer(ip, &bh);
 	if (ret == 0) {
-		gfs2_trans_add_bh(ip->i_gl, bh, 1);
+		gfs2_trans_add_meta(ip->i_gl, bh);
 		gfs2_dinode_out(ip, bh->b_data);
 		brelse(bh);
 	}
diff --git a/fs/gfs2/trans.c b/fs/gfs2/trans.c
index 6f3ddbc..cb795ac 100644
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@ -150,7 +150,7 @@ void gfs2_trans_end(struct gfs2_sbd *sdp)
  *
  */
 
-void gfs2_trans_add_bh(struct gfs2_glock *gl, struct buffer_head *bh, int meta)
+static void gfs2_trans_add_bh(struct gfs2_glock *gl, struct buffer_head *bh, int meta)
 {
 	struct gfs2_sbd *sdp = gl->gl_sbd;
 	struct gfs2_bufdata *bd;
@@ -173,6 +173,16 @@ void gfs2_trans_add_bh(struct gfs2_glock *gl, struct buffer_head *bh, int meta)
 	unlock_buffer(bh);
 }
 
+void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
+{
+	return gfs2_trans_add_bh(gl, bh, 0);
+}
+
+void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)
+{
+	return gfs2_trans_add_bh(gl, bh, 1);
+}
+
 void gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
 {
 	struct gfs2_glock *gl = bd->bd_gl;
diff --git a/fs/gfs2/trans.h b/fs/gfs2/trans.h
index bf2ae9a..1e6e7da 100644
--- a/fs/gfs2/trans.h
+++ b/fs/gfs2/trans.h
@@ -39,7 +39,8 @@ extern int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,
 			    unsigned int revokes);
 
 extern void gfs2_trans_end(struct gfs2_sbd *sdp);
-extern void gfs2_trans_add_bh(struct gfs2_glock *gl, struct buffer_head *bh, int meta);
+extern void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh);
+extern void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh);
 extern void gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd);
 extern void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len);
 
diff --git a/fs/gfs2/xattr.c b/fs/gfs2/xattr.c
index 76c144b..cbb46c2 100644
--- a/fs/gfs2/xattr.c
+++ b/fs/gfs2/xattr.c
@@ -270,7 +270,7 @@ static int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,
 	if (error)
 		goto out_gunlock;
 
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 
 	dataptrs = GFS2_EA2DATAPTRS(ea);
 	for (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {
@@ -309,7 +309,7 @@ static int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,
 	error = gfs2_meta_inode_buffer(ip, &dibh);
 	if (!error) {
 		ip->i_inode.i_ctime = CURRENT_TIME;
-		gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(ip->i_gl, dibh);
 		gfs2_dinode_out(ip, dibh->b_data);
 		brelse(dibh);
 	}
@@ -509,7 +509,7 @@ static int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,
 		}
 
 		if (din) {
-			gfs2_trans_add_bh(ip->i_gl, bh[x], 1);
+			gfs2_trans_add_meta(ip->i_gl, bh[x]);
 			memcpy(pos, din, cp_size);
 			din += sdp->sd_jbsize;
 		}
@@ -629,7 +629,7 @@ static int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)
 		return error;
 	gfs2_trans_add_unrevoke(sdp, block, 1);
 	*bhp = gfs2_meta_new(ip->i_gl, block);
-	gfs2_trans_add_bh(ip->i_gl, *bhp, 1);
+	gfs2_trans_add_meta(ip->i_gl, *bhp);
 	gfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);
 	gfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));
 
@@ -691,7 +691,7 @@ static int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,
 				return error;
 			gfs2_trans_add_unrevoke(sdp, block, 1);
 			bh = gfs2_meta_new(ip->i_gl, block);
-			gfs2_trans_add_bh(ip->i_gl, bh, 1);
+			gfs2_trans_add_meta(ip->i_gl, bh);
 			gfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);
 
 			gfs2_add_inode_blocks(&ip->i_inode, 1);
@@ -751,7 +751,7 @@ static int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,
 	error = gfs2_meta_inode_buffer(ip, &dibh);
 	if (!error) {
 		ip->i_inode.i_ctime = CURRENT_TIME;
-		gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(ip->i_gl, dibh);
 		gfs2_dinode_out(ip, dibh->b_data);
 		brelse(dibh);
 	}
@@ -834,7 +834,7 @@ static void ea_set_remove_stuffed(struct gfs2_inode *ip,
 	struct gfs2_ea_header *prev = el->el_prev;
 	u32 len;
 
-	gfs2_trans_add_bh(ip->i_gl, el->el_bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, el->el_bh);
 
 	if (!prev || !GFS2_EA_IS_STUFFED(ea)) {
 		ea->ea_type = GFS2_EATYPE_UNUSED;
@@ -872,7 +872,7 @@ static int ea_set_simple_noalloc(struct gfs2_inode *ip, struct buffer_head *bh,
 	if (error)
 		return error;
 
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 
 	if (es->ea_split)
 		ea = ea_split_ea(ea);
@@ -886,7 +886,7 @@ static int ea_set_simple_noalloc(struct gfs2_inode *ip, struct buffer_head *bh,
 	if (error)
 		goto out;
 	ip->i_inode.i_ctime = CURRENT_TIME;
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_dinode_out(ip, dibh->b_data);
 	brelse(dibh);
 out:
@@ -901,7 +901,7 @@ static int ea_set_simple_alloc(struct gfs2_inode *ip,
 	struct gfs2_ea_header *ea = es->es_ea;
 	int error;
 
-	gfs2_trans_add_bh(ip->i_gl, es->es_bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, es->es_bh);
 
 	if (es->ea_split)
 		ea = ea_split_ea(ea);
@@ -997,7 +997,7 @@ static int ea_set_block(struct gfs2_inode *ip, struct gfs2_ea_request *er,
 			goto out;
 		}
 
-		gfs2_trans_add_bh(ip->i_gl, indbh, 1);
+		gfs2_trans_add_meta(ip->i_gl, indbh);
 	} else {
 		u64 blk;
 		unsigned int n = 1;
@@ -1006,7 +1006,7 @@ static int ea_set_block(struct gfs2_inode *ip, struct gfs2_ea_request *er,
 			return error;
 		gfs2_trans_add_unrevoke(sdp, blk, 1);
 		indbh = gfs2_meta_new(ip->i_gl, blk);
-		gfs2_trans_add_bh(ip->i_gl, indbh, 1);
+		gfs2_trans_add_meta(ip->i_gl, indbh);
 		gfs2_metatype_set(indbh, GFS2_METATYPE_IN, GFS2_FORMAT_IN);
 		gfs2_buffer_clear_tail(indbh, mh_size);
 
@@ -1092,7 +1092,7 @@ static int ea_remove_stuffed(struct gfs2_inode *ip, struct gfs2_ea_location *el)
 	if (error)
 		return error;
 
-	gfs2_trans_add_bh(ip->i_gl, el->el_bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, el->el_bh);
 
 	if (prev) {
 		u32 len;
@@ -1109,7 +1109,7 @@ static int ea_remove_stuffed(struct gfs2_inode *ip, struct gfs2_ea_location *el)
 	error = gfs2_meta_inode_buffer(ip, &dibh);
 	if (!error) {
 		ip->i_inode.i_ctime = CURRENT_TIME;
-		gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(ip->i_gl, dibh);
 		gfs2_dinode_out(ip, dibh->b_data);
 		brelse(dibh);
 	}
@@ -1265,7 +1265,7 @@ int gfs2_xattr_acl_chmod(struct gfs2_inode *ip, struct iattr *attr, char *data)
 	if (GFS2_EA_IS_STUFFED(el.el_ea)) {
 		error = gfs2_trans_begin(sdp, RES_DINODE + RES_EATTR, 0);
 		if (error == 0) {
-			gfs2_trans_add_bh(ip->i_gl, el.el_bh, 1);
+			gfs2_trans_add_meta(ip->i_gl, el.el_bh);
 			memcpy(GFS2_EA2DATA(el.el_ea), data,
 			       GFS2_EA_DATA_LEN(el.el_ea));
 		}
@@ -1352,7 +1352,7 @@ static int ea_dealloc_indirect(struct gfs2_inode *ip)
 	if (error)
 		goto out_gunlock;
 
-	gfs2_trans_add_bh(ip->i_gl, indbh, 1);
+	gfs2_trans_add_meta(ip->i_gl, indbh);
 
 	eablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));
 	bstart = 0;
@@ -1384,7 +1384,7 @@ static int ea_dealloc_indirect(struct gfs2_inode *ip)
 
 	error = gfs2_meta_inode_buffer(ip, &dibh);
 	if (!error) {
-		gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(ip->i_gl, dibh);
 		gfs2_dinode_out(ip, dibh->b_data);
 		brelse(dibh);
 	}
@@ -1434,7 +1434,7 @@ static int ea_dealloc_block(struct gfs2_inode *ip)
 
 	error = gfs2_meta_inode_buffer(ip, &dibh);
 	if (!error) {
-		gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(ip->i_gl, dibh);
 		gfs2_dinode_out(ip, dibh->b_data);
 		brelse(dibh);
 	}
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:06 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAY6b1032743 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:06 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq3000596; Tue, 19 Feb 2013 05:34:05 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:34 +0000
Message-Id: <1361268460-3092-5-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 04/10] GFS2: Copy gfs2_trans_add_bh into new
	data/meta functions
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:06 -0000

This patch copies the body of gfs2_trans_add_bh into the two newly
added gfs2_trans_add_data and gfs2_trans_add_meta functions. We can
then move the .lo_add functions from lops.c into trans.c and call
them directly.

As a result of this, we no longer need to use the .lo_add functions
at all, so that is removed from the log operations structure.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c373a24..5d129ab 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -52,7 +52,6 @@ struct gfs2_log_header_host {
  */
 
 struct gfs2_log_operations {
-	void (*lo_add) (struct gfs2_sbd *sdp, struct gfs2_bufdata *bd);
 	void (*lo_before_commit) (struct gfs2_sbd *sdp);
 	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_ail *ai);
 	void (*lo_before_scan) (struct gfs2_jdesc *jd,
diff --git a/fs/gfs2/lops.c b/fs/gfs2/lops.c
index 9c80742..a505597 100644
--- a/fs/gfs2/lops.c
+++ b/fs/gfs2/lops.c
@@ -37,7 +37,7 @@
  *
  * The log lock must be held when calling this function
  */
-static void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)
+void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)
 {
 	struct gfs2_bufdata *bd;
 
@@ -388,32 +388,6 @@ static struct page *gfs2_get_log_desc(struct gfs2_sbd *sdp, u32 ld_type,
 	return page;
 }
 
-static void buf_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
-{
-	struct gfs2_meta_header *mh;
-	struct gfs2_trans *tr;
-
-	tr = current->journal_info;
-	tr->tr_touched = 1;
-	if (!list_empty(&bd->bd_list))
-		return;
-	set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
-	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
-	mh = (struct gfs2_meta_header *)bd->bd_bh->b_data;
-	if (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {
-		printk(KERN_ERR
-		       "Attempting to add uninitialised block to journal (inplace block=%lld)\n",
-		       (unsigned long long)bd->bd_bh->b_blocknr);
-		BUG();
-	}
-	gfs2_pin(sdp, bd->bd_bh);
-	mh->__pad0 = cpu_to_be64(0);
-	mh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);
-	sdp->sd_log_num_buf++;
-	list_add(&bd->bd_list, &sdp->sd_log_le_buf);
-	tr->tr_num_buf_new++;
-}
-
 static void gfs2_check_magic(struct buffer_head *bh)
 {
 	void *kaddr;
@@ -735,44 +709,6 @@ static void revoke_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)
 }
 
 /**
- * databuf_lo_add - Add a databuf to the transaction.
- *
- * This is used in two distinct cases:
- * i) In ordered write mode
- *    We put the data buffer on a list so that we can ensure that its
- *    synced to disk at the right time
- * ii) In journaled data mode
- *    We need to journal the data block in the same way as metadata in
- *    the functions above. The difference is that here we have a tag
- *    which is two __be64's being the block number (as per meta data)
- *    and a flag which says whether the data block needs escaping or
- *    not. This means we need a new log entry for each 251 or so data
- *    blocks, which isn't an enormous overhead but twice as much as
- *    for normal metadata blocks.
- */
-static void databuf_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
-{
-	struct gfs2_trans *tr = current->journal_info;
-	struct address_space *mapping = bd->bd_bh->b_page->mapping;
-	struct gfs2_inode *ip = GFS2_I(mapping->host);
-
-	if (tr)
-		tr->tr_touched = 1;
-	if (!list_empty(&bd->bd_list))
-		return;
-	set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
-	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
-	if (gfs2_is_jdata(ip)) {
-		gfs2_pin(sdp, bd->bd_bh);
-		tr->tr_num_databuf_new++;
-		sdp->sd_log_num_databuf++;
-		list_add_tail(&bd->bd_list, &sdp->sd_log_le_databuf);
-	} else {
-		list_add_tail(&bd->bd_list, &sdp->sd_log_le_ordered);
-	}
-}
-
-/**
  * databuf_lo_before_commit - Scan the data buffers, writing as we go
  *
  */
@@ -871,7 +807,6 @@ static void databuf_lo_after_commit(struct gfs2_sbd *sdp, struct gfs2_ail *ai)
 
 
 const struct gfs2_log_operations gfs2_buf_lops = {
-	.lo_add = buf_lo_add,
 	.lo_before_commit = buf_lo_before_commit,
 	.lo_after_commit = buf_lo_after_commit,
 	.lo_before_scan = buf_lo_before_scan,
@@ -894,7 +829,6 @@ const struct gfs2_log_operations gfs2_rg_lops = {
 };
 
 const struct gfs2_log_operations gfs2_databuf_lops = {
-	.lo_add = databuf_lo_add,
 	.lo_before_commit = databuf_lo_before_commit,
 	.lo_after_commit = databuf_lo_after_commit,
 	.lo_scan_elements = databuf_lo_scan_elements,
diff --git a/fs/gfs2/lops.h b/fs/gfs2/lops.h
index 954a330..d85b376 100644
--- a/fs/gfs2/lops.h
+++ b/fs/gfs2/lops.h
@@ -29,6 +29,7 @@ extern const struct gfs2_log_operations gfs2_databuf_lops;
 extern const struct gfs2_log_operations *gfs2_log_ops[];
 extern void gfs2_log_write_page(struct gfs2_sbd *sdp, struct page *page);
 extern void gfs2_log_flush_bio(struct gfs2_sbd *sdp, int rw);
+extern void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh);
 
 static inline unsigned int buf_limit(struct gfs2_sbd *sdp)
 {
@@ -53,12 +54,6 @@ static inline void lops_init_le(struct gfs2_bufdata *bd,
 	bd->bd_ops = lops;
 }
 
-static inline void lops_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
-{
-	if (bd->bd_ops->lo_add)
-		bd->bd_ops->lo_add(sdp, bd);
-}
-
 static inline void lops_before_commit(struct gfs2_sbd *sdp)
 {
 	int x;
diff --git a/fs/gfs2/trans.c b/fs/gfs2/trans.c
index cb795ac..1fbd57e 100644
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@ -18,6 +18,7 @@
 #include "gfs2.h"
 #include "incore.h"
 #include "glock.h"
+#include "inode.h"
 #include "log.h"
 #include "lops.h"
 #include "meta_io.h"
@@ -143,15 +144,46 @@ void gfs2_trans_end(struct gfs2_sbd *sdp)
 }
 
 /**
- * gfs2_trans_add_bh - Add a to-be-modified buffer to the current transaction
- * @gl: the glock the buffer belongs to
- * @bh: The buffer to add
- * @meta: True in the case of adding metadata
+ * databuf_lo_add - Add a databuf to the transaction.
  *
+ * This is used in two distinct cases:
+ * i) In ordered write mode
+ *    We put the data buffer on a list so that we can ensure that its
+ *    synced to disk at the right time
+ * ii) In journaled data mode
+ *    We need to journal the data block in the same way as metadata in
+ *    the functions above. The difference is that here we have a tag
+ *    which is two __be64's being the block number (as per meta data)
+ *    and a flag which says whether the data block needs escaping or
+ *    not. This means we need a new log entry for each 251 or so data
+ *    blocks, which isn't an enormous overhead but twice as much as
+ *    for normal metadata blocks.
  */
+static void databuf_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
+{
+	struct gfs2_trans *tr = current->journal_info;
+	struct address_space *mapping = bd->bd_bh->b_page->mapping;
+	struct gfs2_inode *ip = GFS2_I(mapping->host);
+
+	if (tr)
+		tr->tr_touched = 1;
+	if (!list_empty(&bd->bd_list))
+		return;
+	set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
+	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
+	if (gfs2_is_jdata(ip)) {
+		gfs2_pin(sdp, bd->bd_bh);
+		tr->tr_num_databuf_new++;
+		sdp->sd_log_num_databuf++;
+		list_add_tail(&bd->bd_list, &sdp->sd_log_le_databuf);
+	} else {
+		list_add_tail(&bd->bd_list, &sdp->sd_log_le_ordered);
+	}
+}
 
-static void gfs2_trans_add_bh(struct gfs2_glock *gl, struct buffer_head *bh, int meta)
+void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
 {
+
 	struct gfs2_sbd *sdp = gl->gl_sbd;
 	struct gfs2_bufdata *bd;
 
@@ -163,24 +195,64 @@ static void gfs2_trans_add_bh(struct gfs2_glock *gl, struct buffer_head *bh, int
 	else {
 		gfs2_log_unlock(sdp);
 		unlock_buffer(bh);
-		gfs2_attach_bufdata(gl, bh, meta);
+		gfs2_attach_bufdata(gl, bh, 0);
 		bd = bh->b_private;
 		lock_buffer(bh);
 		gfs2_log_lock(sdp);
 	}
-	lops_add(sdp, bd);
+	databuf_lo_add(sdp, bd);
 	gfs2_log_unlock(sdp);
 	unlock_buffer(bh);
 }
 
-void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
+static void meta_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
 {
-	return gfs2_trans_add_bh(gl, bh, 0);
+	struct gfs2_meta_header *mh;
+	struct gfs2_trans *tr;
+
+	tr = current->journal_info;
+	tr->tr_touched = 1;
+	if (!list_empty(&bd->bd_list))
+		return;
+	set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
+	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
+	mh = (struct gfs2_meta_header *)bd->bd_bh->b_data;
+	if (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {
+		printk(KERN_ERR
+		       "Attempting to add uninitialised block to journal (inplace block=%lld)\n",
+		       (unsigned long long)bd->bd_bh->b_blocknr);
+		BUG();
+	}
+	gfs2_pin(sdp, bd->bd_bh);
+	mh->__pad0 = cpu_to_be64(0);
+	mh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);
+	sdp->sd_log_num_buf++;
+	list_add(&bd->bd_list, &sdp->sd_log_le_buf);
+	tr->tr_num_buf_new++;
 }
 
 void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)
 {
-	return gfs2_trans_add_bh(gl, bh, 1);
+
+	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct gfs2_bufdata *bd;
+
+	lock_buffer(bh);
+	gfs2_log_lock(sdp);
+	bd = bh->b_private;
+	if (bd)
+		gfs2_assert(sdp, bd->bd_gl == gl);
+	else {
+		gfs2_log_unlock(sdp);
+		unlock_buffer(bh);
+		gfs2_attach_bufdata(gl, bh, 1);
+		bd = bh->b_private;
+		lock_buffer(bh);
+		gfs2_log_lock(sdp);
+	}
+	meta_lo_add(sdp, bd);
+	gfs2_log_unlock(sdp);
+	unlock_buffer(bh);
 }
 
 void gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:07 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAY7G3032754 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:07 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq4000596; Tue, 19 Feb 2013 05:34:06 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:35 +0000
Message-Id: <1361268460-3092-6-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 05/10] GFS2: Merge gfs2_attach_bufdata()
	into trans.c
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:07 -0000

The locking in gfs2_attach_bufdata() was type specific (data/meta)
which made the function rather confusing. This patch moves the core
of gfs2_attach_bufdata() into trans.c renaming it gfs2_alloc_bufdata()
and moving the locking into gfs2_trans_add_data()/gfs2_trans_add_meta()

As a result all of the locking related to adding data and metadata to
the journal is now in these two functions. This should help to clarify
what is going on, and give us some opportunities to simplify in
some cases.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/lops.h b/fs/gfs2/lops.h
index d85b376..ba77b7d 100644
--- a/fs/gfs2/lops.h
+++ b/fs/gfs2/lops.h
@@ -47,13 +47,6 @@ static inline unsigned int databuf_limit(struct gfs2_sbd *sdp)
 	return limit;
 }
 
-static inline void lops_init_le(struct gfs2_bufdata *bd,
-				const struct gfs2_log_operations *lops)
-{
-	INIT_LIST_HEAD(&bd->bd_list);
-	bd->bd_ops = lops;
-}
-
 static inline void lops_before_commit(struct gfs2_sbd *sdp)
 {
 	int x;
diff --git a/fs/gfs2/meta_io.c b/fs/gfs2/meta_io.c
index 22255d9..b059bbb 100644
--- a/fs/gfs2/meta_io.c
+++ b/fs/gfs2/meta_io.c
@@ -271,41 +271,6 @@ int gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)
 	return 0;
 }
 
-/**
- * gfs2_attach_bufdata - attach a struct gfs2_bufdata structure to a buffer
- * @gl: the glock the buffer belongs to
- * @bh: The buffer to be attached to
- * @meta: Flag to indicate whether its metadata or not
- */
-
-void gfs2_attach_bufdata(struct gfs2_glock *gl, struct buffer_head *bh,
-			 int meta)
-{
-	struct gfs2_bufdata *bd;
-
-	if (meta)
-		lock_page(bh->b_page);
-
-	if (bh->b_private) {
-		if (meta)
-			unlock_page(bh->b_page);
-		return;
-	}
-
-	bd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);
-	bd->bd_bh = bh;
-	bd->bd_gl = gl;
-
-	if (meta)
-		lops_init_le(bd, &gfs2_buf_lops);
-	else
-		lops_init_le(bd, &gfs2_databuf_lops);
-	bh->b_private = bd;
-
-	if (meta)
-		unlock_page(bh->b_page);
-}
-
 void gfs2_remove_from_journal(struct buffer_head *bh, struct gfs2_trans *tr, int meta)
 {
 	struct address_space *mapping = bh->b_page->mapping;
diff --git a/fs/gfs2/meta_io.h b/fs/gfs2/meta_io.h
index c30973b..0d4c843 100644
--- a/fs/gfs2/meta_io.h
+++ b/fs/gfs2/meta_io.h
@@ -56,9 +56,6 @@ int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno,
 int gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh);
 struct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create);
 
-void gfs2_attach_bufdata(struct gfs2_glock *gl, struct buffer_head *bh,
-			 int meta);
-
 void gfs2_remove_from_journal(struct buffer_head *bh, struct gfs2_trans *tr,
 			      int meta);
 
diff --git a/fs/gfs2/trans.c b/fs/gfs2/trans.c
index 1fbd57e..14dbf6d 100644
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@ -143,6 +143,21 @@ void gfs2_trans_end(struct gfs2_sbd *sdp)
 	sb_end_intwrite(sdp->sd_vfs);
 }
 
+static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,
+					       struct buffer_head *bh,
+					       const struct gfs2_log_operations *lops)
+{
+	struct gfs2_bufdata *bd;
+
+	bd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);
+	bd->bd_bh = bh;
+	bd->bd_gl = gl;
+	bd->bd_ops = lops;
+	INIT_LIST_HEAD(&bd->bd_list);
+	bh->b_private = bd;
+	return bd;
+}
+
 /**
  * databuf_lo_add - Add a databuf to the transaction.
  *
@@ -190,16 +205,15 @@ void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
 	lock_buffer(bh);
 	gfs2_log_lock(sdp);
 	bd = bh->b_private;
-	if (bd)
-		gfs2_assert(sdp, bd->bd_gl == gl);
-	else {
+	if (bd == NULL) {
 		gfs2_log_unlock(sdp);
 		unlock_buffer(bh);
-		gfs2_attach_bufdata(gl, bh, 0);
-		bd = bh->b_private;
+		if (bh->b_private == NULL)
+			bd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);
 		lock_buffer(bh);
 		gfs2_log_lock(sdp);
 	}
+	gfs2_assert(sdp, bd->bd_gl == gl);
 	databuf_lo_add(sdp, bd);
 	gfs2_log_unlock(sdp);
 	unlock_buffer(bh);
@@ -240,16 +254,17 @@ void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)
 	lock_buffer(bh);
 	gfs2_log_lock(sdp);
 	bd = bh->b_private;
-	if (bd)
-		gfs2_assert(sdp, bd->bd_gl == gl);
-	else {
+	if (bd == NULL) {
 		gfs2_log_unlock(sdp);
 		unlock_buffer(bh);
-		gfs2_attach_bufdata(gl, bh, 1);
-		bd = bh->b_private;
+		lock_page(bh->b_page);
+		if (bh->b_private == NULL)
+			bd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);
+		unlock_page(bh->b_page);
 		lock_buffer(bh);
 		gfs2_log_lock(sdp);
 	}
+	gfs2_assert(sdp, bd->bd_gl == gl);
 	meta_lo_add(sdp, bd);
 	gfs2_log_unlock(sdp);
 	unlock_buffer(bh);
@@ -263,7 +278,7 @@ void gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
 	BUG_ON(!list_empty(&bd->bd_list));
 	BUG_ON(!list_empty(&bd->bd_ail_st_list));
 	BUG_ON(!list_empty(&bd->bd_ail_gl_list));
-	lops_init_le(bd, &gfs2_revoke_lops);
+	bd->bd_ops = &gfs2_revoke_lops;
 	tr->tr_touched = 1;
 	tr->tr_num_revoke++;
 	sdp->sd_log_num_revoke++;
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:09 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAY9tl032764 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:09 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq5000596; Tue, 19 Feb 2013 05:34:08 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:36 +0000
Message-Id: <1361268460-3092-7-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 06/10] GFS2: Clean up freeze code
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:09 -0000

The freeze code has not been looked at a lot recently. Upstream has
moved on, and this is an attempt to catch us back up again. There
is a vfs level interface for the freeze code which can be called
from our (obsolete, but kept for backward compatibility purposes)
sysfs freeze interface. This means freezing this way vs. doing it
from the ioctl should now work in identical fashion.

As a result of this, the freeze function is only called once
and we can drop our own special purpose code for counting the
number of freezes.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5d129ab..19750bc 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -757,10 +757,7 @@ struct gfs2_sbd {
 	unsigned int sd_replayed_blocks;
 
 	/* For quiescing the filesystem */
-
 	struct gfs2_holder sd_freeze_gh;
-	struct mutex sd_freeze_lock;
-	unsigned int sd_freeze_count;
 
 	char sd_fsname[GFS2_FSNAME_LEN];
 	char sd_table_name[GFS2_FSNAME_LEN];
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index 0e3554e..5f5aba5 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -115,8 +115,6 @@ static struct gfs2_sbd *init_sbd(struct super_block *sb)
 
 	INIT_LIST_HEAD(&sdp->sd_revoke_list);
 
-	mutex_init(&sdp->sd_freeze_lock);
-
 	return sdp;
 }
 
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 4dfda4c..c075b62 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -663,54 +663,6 @@ out:
 	return error;
 }
 
-/**
- * gfs2_freeze_fs - freezes the file system
- * @sdp: the file system
- *
- * This function flushes data and meta data for all machines by
- * acquiring the transaction log exclusively.  All journals are
- * ensured to be in a clean state as well.
- *
- * Returns: errno
- */
-
-int gfs2_freeze_fs(struct gfs2_sbd *sdp)
-{
-	int error = 0;
-
-	mutex_lock(&sdp->sd_freeze_lock);
-
-	if (!sdp->sd_freeze_count++) {
-		error = gfs2_lock_fs_check_clean(sdp, &sdp->sd_freeze_gh);
-		if (error)
-			sdp->sd_freeze_count--;
-	}
-
-	mutex_unlock(&sdp->sd_freeze_lock);
-
-	return error;
-}
-
-/**
- * gfs2_unfreeze_fs - unfreezes the file system
- * @sdp: the file system
- *
- * This function allows the file system to proceed by unlocking
- * the exclusively held transaction lock.  Other GFS2 nodes are
- * now free to acquire the lock shared and go on with their lives.
- *
- */
-
-void gfs2_unfreeze_fs(struct gfs2_sbd *sdp)
-{
-	mutex_lock(&sdp->sd_freeze_lock);
-
-	if (sdp->sd_freeze_count && !--sdp->sd_freeze_count)
-		gfs2_glock_dq_uninit(&sdp->sd_freeze_gh);
-
-	mutex_unlock(&sdp->sd_freeze_lock);
-}
-
 void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)
 {
 	struct gfs2_dinode *str = buf;
@@ -888,13 +840,6 @@ static void gfs2_put_super(struct super_block *sb)
 	int error;
 	struct gfs2_jdesc *jd;
 
-	/*  Unfreeze the filesystem, if we need to  */
-
-	mutex_lock(&sdp->sd_freeze_lock);
-	if (sdp->sd_freeze_count)
-		gfs2_glock_dq_uninit(&sdp->sd_freeze_gh);
-	mutex_unlock(&sdp->sd_freeze_lock);
-
 	/* No more recovery requests */
 	set_bit(SDF_NORECOVERY, &sdp->sd_flags);
 	smp_mb();
@@ -985,7 +930,7 @@ static int gfs2_freeze(struct super_block *sb)
 		return -EINVAL;
 
 	for (;;) {
-		error = gfs2_freeze_fs(sdp);
+		error = gfs2_lock_fs_check_clean(sdp, &sdp->sd_freeze_gh);
 		if (!error)
 			break;
 
@@ -1013,7 +958,9 @@ static int gfs2_freeze(struct super_block *sb)
 
 static int gfs2_unfreeze(struct super_block *sb)
 {
-	gfs2_unfreeze_fs(sb->s_fs_info);
+	struct gfs2_sbd *sdp = sb->s_fs_info;
+
+	gfs2_glock_dq_uninit(&sdp->sd_freeze_gh);
 	return 0;
 }
 
diff --git a/fs/gfs2/super.h b/fs/gfs2/super.h
index a046468..90e3322 100644
--- a/fs/gfs2/super.h
+++ b/fs/gfs2/super.h
@@ -46,9 +46,6 @@ extern void update_statfs(struct gfs2_sbd *sdp, struct buffer_head *m_bh,
 			  struct buffer_head *l_bh);
 extern int gfs2_statfs_sync(struct super_block *sb, int type);
 
-extern int gfs2_freeze_fs(struct gfs2_sbd *sdp);
-extern void gfs2_unfreeze_fs(struct gfs2_sbd *sdp);
-
 extern struct file_system_type gfs2_fs_type;
 extern struct file_system_type gfs2meta_fs_type;
 extern const struct export_operations gfs2_export_ops;
diff --git a/fs/gfs2/sys.c b/fs/gfs2/sys.c
index 8056b7b..462e841 100644
--- a/fs/gfs2/sys.c
+++ b/fs/gfs2/sys.c
@@ -91,19 +91,15 @@ static ssize_t uuid_show(struct gfs2_sbd *sdp, char *buf)
 
 static ssize_t freeze_show(struct gfs2_sbd *sdp, char *buf)
 {
-	unsigned int count;
-
-	mutex_lock(&sdp->sd_freeze_lock);
-	count = sdp->sd_freeze_count;
-	mutex_unlock(&sdp->sd_freeze_lock);
+	struct super_block *sb = sdp->sd_vfs;
+	int frozen = (sb->s_writers.frozen == SB_UNFROZEN) ? 0 : 1;
 
-	return snprintf(buf, PAGE_SIZE, "%u\n", count);
+	return snprintf(buf, PAGE_SIZE, "%u\n", frozen);
 }
 
 static ssize_t freeze_store(struct gfs2_sbd *sdp, const char *buf, size_t len)
 {
-	ssize_t ret = len;
-	int error = 0;
+	int error;
 	int n = simple_strtol(buf, NULL, 0);
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -111,19 +107,21 @@ static ssize_t freeze_store(struct gfs2_sbd *sdp, const char *buf, size_t len)
 
 	switch (n) {
 	case 0:
-		gfs2_unfreeze_fs(sdp);
+		error = thaw_super(sdp->sd_vfs);
 		break;
 	case 1:
-		error = gfs2_freeze_fs(sdp);
+		error = freeze_super(sdp->sd_vfs);
 		break;
 	default:
-		ret = -EINVAL;
+		return -EINVAL;
 	}
 
-	if (error)
+	if (error) {
 		fs_warn(sdp, "freeze %d error %d", n, error);
+		return error;
+	}
 
-	return ret;
+	return len;
 }
 
 static ssize_t withdraw_show(struct gfs2_sbd *sdp, char *buf)
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:10 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAYAAs000308 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:10 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq6000596; Tue, 19 Feb 2013 05:34:09 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:37 +0000
Message-Id: <1361268460-3092-8-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 07/10] GFS2: Use ->writepages for ordered
	writes
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:11 -0000

Instead of using a list of buffers to write ahead of the journal
flush, this now uses a list of inodes and calls ->writepages
via filemap_fdatawrite() in order to achieve the same thing. For
most use cases this results in a shorter ordered write list,
as well as much larger i/os being issued.

The ordered write list is sorted by inode number before writing
in order to retain the disk block ordering between inodes as
per the previous code.

The previous ordered write code used to conflict in its assumptions
about how to write out the disk blocks with mpage_writepages()
so that with this updated version we can also use mpage_writepages()
for GFS2's ordered write, writepages implementation. So we will
also send larger i/os from writeback too.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/aops.c b/fs/gfs2/aops.c
index 92340dd..24f414f 100644
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@ -230,16 +230,14 @@ out_ignore:
 }
 
 /**
- * gfs2_writeback_writepages - Write a bunch of dirty pages back to disk
+ * gfs2_writepages - Write a bunch of dirty pages back to disk
  * @mapping: The mapping to write
  * @wbc: Write-back control
  *
- * For the data=writeback case we can already ignore buffer heads
- * and write whole extents at once. This is a big reduction in the
- * number of I/O requests we send and the bmap calls we make in this case.
+ * Used for both ordered and writeback modes.
  */
-static int gfs2_writeback_writepages(struct address_space *mapping,
-				     struct writeback_control *wbc)
+static int gfs2_writepages(struct address_space *mapping,
+			   struct writeback_control *wbc)
 {
 	return mpage_writepages(mapping, wbc, gfs2_get_block_noalloc);
 }
@@ -1102,7 +1100,7 @@ cannot_release:
 
 static const struct address_space_operations gfs2_writeback_aops = {
 	.writepage = gfs2_writeback_writepage,
-	.writepages = gfs2_writeback_writepages,
+	.writepages = gfs2_writepages,
 	.readpage = gfs2_readpage,
 	.readpages = gfs2_readpages,
 	.write_begin = gfs2_write_begin,
@@ -1118,6 +1116,7 @@ static const struct address_space_operations gfs2_writeback_aops = {
 
 static const struct address_space_operations gfs2_ordered_aops = {
 	.writepage = gfs2_ordered_writepage,
+	.writepages = gfs2_writepages,
 	.readpage = gfs2_readpage,
 	.readpages = gfs2_readpages,
 	.write_begin = gfs2_write_begin,
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index 7a86275..d29d779 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -22,6 +22,7 @@
 #include "meta_io.h"
 #include "quota.h"
 #include "rgrp.h"
+#include "log.h"
 #include "super.h"
 #include "trans.h"
 #include "dir.h"
@@ -1137,6 +1138,7 @@ static int trunc_end(struct gfs2_inode *ip)
 		ip->i_height = 0;
 		ip->i_goal = ip->i_no_addr;
 		gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
+		gfs2_ordered_del_inode(ip);
 	}
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 	ip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 19750bc..1533cf8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -340,6 +340,7 @@ enum {
 	GIF_QD_LOCKED		= 1,
 	GIF_ALLOC_FAILED	= 2,
 	GIF_SW_PAGED		= 3,
+	GIF_ORDERED		= 4,
 };
 
 struct gfs2_inode {
@@ -356,6 +357,7 @@ struct gfs2_inode {
 	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
+	struct list_head i_ordered;
 	struct list_head i_trunc_list;
 	__be64 *i_hash_cache;
 	u32 i_entries;
@@ -722,6 +724,7 @@ struct gfs2_sbd {
 	struct list_head sd_log_le_revoke;
 	struct list_head sd_log_le_databuf;
 	struct list_head sd_log_le_ordered;
+	spinlock_t sd_ordered_lock;
 
 	atomic_t sd_log_thresh1;
 	atomic_t sd_log_thresh2;
diff --git a/fs/gfs2/log.c b/fs/gfs2/log.c
index f4beeb9..9a2ca8b 100644
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@ -482,70 +482,66 @@ static void log_flush_wait(struct gfs2_sbd *sdp)
 	}
 }
 
-static int bd_cmp(void *priv, struct list_head *a, struct list_head *b)
+static int ip_cmp(void *priv, struct list_head *a, struct list_head *b)
 {
-	struct gfs2_bufdata *bda, *bdb;
+	struct gfs2_inode *ipa, *ipb;
 
-	bda = list_entry(a, struct gfs2_bufdata, bd_list);
-	bdb = list_entry(b, struct gfs2_bufdata, bd_list);
+	ipa = list_entry(a, struct gfs2_inode, i_ordered);
+	ipb = list_entry(b, struct gfs2_inode, i_ordered);
 
-	if (bda->bd_bh->b_blocknr < bdb->bd_bh->b_blocknr)
+	if (ipa->i_no_addr < ipb->i_no_addr)
 		return -1;
-	if (bda->bd_bh->b_blocknr > bdb->bd_bh->b_blocknr)
+	if (ipa->i_no_addr > ipb->i_no_addr)
 		return 1;
 	return 0;
 }
 
 static void gfs2_ordered_write(struct gfs2_sbd *sdp)
 {
-	struct gfs2_bufdata *bd;
-	struct buffer_head *bh;
+	struct gfs2_inode *ip;
 	LIST_HEAD(written);
 
-	gfs2_log_lock(sdp);
-	list_sort(NULL, &sdp->sd_log_le_ordered, &bd_cmp);
+	spin_lock(&sdp->sd_ordered_lock);
+	list_sort(NULL, &sdp->sd_log_le_ordered, &ip_cmp);
 	while (!list_empty(&sdp->sd_log_le_ordered)) {
-		bd = list_entry(sdp->sd_log_le_ordered.next, struct gfs2_bufdata, bd_list);
-		list_move(&bd->bd_list, &written);
-		bh = bd->bd_bh;
-		if (!buffer_dirty(bh))
+		ip = list_entry(sdp->sd_log_le_ordered.next, struct gfs2_inode, i_ordered);
+		list_move(&ip->i_ordered, &written);
+		if (ip->i_inode.i_mapping->nrpages == 0)
 			continue;
-		get_bh(bh);
-		gfs2_log_unlock(sdp);
-		lock_buffer(bh);
-		if (buffer_mapped(bh) && test_clear_buffer_dirty(bh)) {
-			bh->b_end_io = end_buffer_write_sync;
-			submit_bh(WRITE_SYNC, bh);
-		} else {
-			unlock_buffer(bh);
-			brelse(bh);
-		}
-		gfs2_log_lock(sdp);
+		spin_unlock(&sdp->sd_ordered_lock);
+		filemap_fdatawrite(ip->i_inode.i_mapping);
+		spin_lock(&sdp->sd_ordered_lock);
 	}
 	list_splice(&written, &sdp->sd_log_le_ordered);
-	gfs2_log_unlock(sdp);
+	spin_unlock(&sdp->sd_ordered_lock);
 }
 
 static void gfs2_ordered_wait(struct gfs2_sbd *sdp)
 {
-	struct gfs2_bufdata *bd;
-	struct buffer_head *bh;
+	struct gfs2_inode *ip;
 
-	gfs2_log_lock(sdp);
+	spin_lock(&sdp->sd_ordered_lock);
 	while (!list_empty(&sdp->sd_log_le_ordered)) {
-		bd = list_entry(sdp->sd_log_le_ordered.prev, struct gfs2_bufdata, bd_list);
-		bh = bd->bd_bh;
-		if (buffer_locked(bh)) {
-			get_bh(bh);
-			gfs2_log_unlock(sdp);
-			wait_on_buffer(bh);
-			brelse(bh);
-			gfs2_log_lock(sdp);
+		ip = list_entry(sdp->sd_log_le_ordered.next, struct gfs2_inode, i_ordered);
+		list_del(&ip->i_ordered);
+		WARN_ON(!test_and_clear_bit(GIF_ORDERED, &ip->i_flags));
+		if (ip->i_inode.i_mapping->nrpages == 0)
 			continue;
-		}
-		list_del_init(&bd->bd_list);
+		spin_unlock(&sdp->sd_ordered_lock);
+		filemap_fdatawait(ip->i_inode.i_mapping);
+		spin_lock(&sdp->sd_ordered_lock);
 	}
-	gfs2_log_unlock(sdp);
+	spin_unlock(&sdp->sd_ordered_lock);
+}
+
+void gfs2_ordered_del_inode(struct gfs2_inode *ip)
+{
+	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
+
+	spin_lock(&sdp->sd_ordered_lock);
+	if (test_and_clear_bit(GIF_ORDERED, &ip->i_flags))
+		list_del(&ip->i_ordered);
+	spin_unlock(&sdp->sd_ordered_lock);
 }
 
 /**
diff --git a/fs/gfs2/log.h b/fs/gfs2/log.h
index 3fd5215..3566f35 100644
--- a/fs/gfs2/log.h
+++ b/fs/gfs2/log.h
@@ -48,6 +48,18 @@ static inline void gfs2_log_pointers_init(struct gfs2_sbd *sdp,
 	sdp->sd_log_head = sdp->sd_log_tail = value;
 }
 
+static inline void gfs2_ordered_add_inode(struct gfs2_inode *ip)
+{
+	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
+
+	if (!test_bit(GIF_ORDERED, &ip->i_flags)) {
+		spin_lock(&sdp->sd_ordered_lock);
+		if (!test_and_set_bit(GIF_ORDERED, &ip->i_flags))
+			list_add(&ip->i_ordered, &sdp->sd_log_le_ordered);
+		spin_unlock(&sdp->sd_ordered_lock);
+	}
+}
+extern void gfs2_ordered_del_inode(struct gfs2_inode *ip);
 extern unsigned int gfs2_struct2blk(struct gfs2_sbd *sdp, unsigned int nstruct,
 			    unsigned int ssize);
 
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index 5f5aba5..e063f22 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -102,6 +102,7 @@ static struct gfs2_sbd *init_sbd(struct super_block *sb)
 	INIT_LIST_HEAD(&sdp->sd_log_le_revoke);
 	INIT_LIST_HEAD(&sdp->sd_log_le_databuf);
 	INIT_LIST_HEAD(&sdp->sd_log_le_ordered);
+	spin_lock_init(&sdp->sd_ordered_lock);
 
 	init_waitqueue_head(&sdp->sd_log_waitq);
 	init_waitqueue_head(&sdp->sd_logd_waitq);
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index c075b62..a3b40ee 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -1524,6 +1524,7 @@ out:
 	/* Case 3 starts here */
 	truncate_inode_pages(&inode->i_data, 0);
 	gfs2_rs_delete(ip);
+	gfs2_ordered_del_inode(ip);
 	clear_inode(inode);
 	gfs2_dir_hash_inval(ip);
 	ip->i_gl->gl_object = NULL;
diff --git a/fs/gfs2/trans.c b/fs/gfs2/trans.c
index 14dbf6d..88162fa 100644
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@ -159,7 +159,9 @@ static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,
 }
 
 /**
- * databuf_lo_add - Add a databuf to the transaction.
+ * gfs2_trans_add_data - Add a databuf to the transaction.
+ * @gl: The inode glock associated with the buffer
+ * @bh: The buffer to add
  *
  * This is used in two distinct cases:
  * i) In ordered write mode
@@ -174,33 +176,18 @@ static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,
  *    blocks, which isn't an enormous overhead but twice as much as
  *    for normal metadata blocks.
  */
-static void databuf_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
+void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
 {
 	struct gfs2_trans *tr = current->journal_info;
-	struct address_space *mapping = bd->bd_bh->b_page->mapping;
+	struct gfs2_sbd *sdp = gl->gl_sbd;
+	struct address_space *mapping = bh->b_page->mapping;
 	struct gfs2_inode *ip = GFS2_I(mapping->host);
+	struct gfs2_bufdata *bd;
 
-	if (tr)
-		tr->tr_touched = 1;
-	if (!list_empty(&bd->bd_list))
+	if (!gfs2_is_jdata(ip)) {
+		gfs2_ordered_add_inode(ip);
 		return;
-	set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
-	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
-	if (gfs2_is_jdata(ip)) {
-		gfs2_pin(sdp, bd->bd_bh);
-		tr->tr_num_databuf_new++;
-		sdp->sd_log_num_databuf++;
-		list_add_tail(&bd->bd_list, &sdp->sd_log_le_databuf);
-	} else {
-		list_add_tail(&bd->bd_list, &sdp->sd_log_le_ordered);
 	}
-}
-
-void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
-{
-
-	struct gfs2_sbd *sdp = gl->gl_sbd;
-	struct gfs2_bufdata *bd;
 
 	lock_buffer(bh);
 	gfs2_log_lock(sdp);
@@ -214,7 +201,15 @@ void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)
 		gfs2_log_lock(sdp);
 	}
 	gfs2_assert(sdp, bd->bd_gl == gl);
-	databuf_lo_add(sdp, bd);
+	tr->tr_touched = 1;
+	if (list_empty(&bd->bd_list)) {
+		set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
+		set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
+		gfs2_pin(sdp, bd->bd_bh);
+		tr->tr_num_databuf_new++;
+		sdp->sd_log_num_databuf++;
+		list_add_tail(&bd->bd_list, &sdp->sd_log_le_databuf);
+	}
 	gfs2_log_unlock(sdp);
 	unlock_buffer(bh);
 }
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:12 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAYCP2000359 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:12 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq7000596; Tue, 19 Feb 2013 05:34:11 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:38 +0000
Message-Id: <1361268460-3092-9-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 08/10] GFS2: Split glock lru processing into
	two parts
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:12 -0000

The intent here is to split the processing of the glock lru
list into two parts, so that the selection of glocks and the
disposal are separate functions. The plan is then, that further
updates can then be made to these functions in the future
to improve the selection of glocks and also the efficiency of
glock disposal.

The new feature which this patch brings is sorting the
glocks to be disposed of into glock number (and thus also
disk block number) order. Not all glocks will need i/o in
order to dispose of them, but some will, and at least we'll
generate mostly disk block order i/o now.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 3ad8fd3..cf35155 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -30,6 +30,7 @@
 #include <linux/rculist_bl.h>
 #include <linux/bit_spinlock.h>
 #include <linux/percpu.h>
+#include <linux/list_sort.h>
 
 #include "gfs2.h"
 #include "incore.h"
@@ -1376,50 +1377,93 @@ void gfs2_glock_complete(struct gfs2_glock *gl, int ret)
 		gfs2_glock_put(gl);
 }
 
+static int glock_cmp(void *priv, struct list_head *a, struct list_head *b)
+{
+	struct gfs2_glock *gla, *glb;
+
+	gla = list_entry(a, struct gfs2_glock, gl_lru);
+	glb = list_entry(b, struct gfs2_glock, gl_lru);
+
+	if (gla->gl_name.ln_number > glb->gl_name.ln_number)
+		return 1;
+	if (gla->gl_name.ln_number < glb->gl_name.ln_number)
+		return -1;
+
+	return 0;
+}
+
+/**
+ * gfs2_dispose_glock_lru - Demote a list of glocks
+ * @list: The list to dispose of
+ *
+ * Disposing of glocks may involve disk accesses, so that here we sort
+ * the glocks by number (i.e. disk location of the inodes) so that if
+ * there are any such accesses, they'll be sent in order (mostly).
+ *
+ * Must be called under the lru_lock, but may drop and retake this
+ * lock. While the lru_lock is dropped, entries may vanish from the
+ * list, but no new entries will appear on the list (since it is
+ * private)
+ */
+
+static void gfs2_dispose_glock_lru(struct list_head *list)
+__releases(&lru_lock)
+__acquires(&lru_lock)
+{
+	struct gfs2_glock *gl;
+
+	list_sort(NULL, list, glock_cmp);
+
+	while(!list_empty(list)) {
+		gl = list_entry(list->next, struct gfs2_glock, gl_lru);
+		list_del_init(&gl->gl_lru);
+		clear_bit(GLF_LRU, &gl->gl_flags);
+		gfs2_glock_hold(gl);
+		spin_unlock(&lru_lock);
+		spin_lock(&gl->gl_spin);
+		if (demote_ok(gl))
+			handle_callback(gl, LM_ST_UNLOCKED, 0);
+		WARN_ON(!test_and_clear_bit(GLF_LOCK, &gl->gl_flags));
+		smp_mb__after_clear_bit();
+		if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
+			gfs2_glock_put_nolock(gl);
+		spin_unlock(&gl->gl_spin);
+		spin_lock(&lru_lock);
+	}
+}
+
 /**
  * gfs2_scan_glock_lru - Scan the LRU looking for locks to demote
  * @nr: The number of entries to scan
  *
+ * This function selects the entries on the LRU which are able to
+ * be demoted, and then kicks off the process by calling
+ * gfs2_dispose_glock_lru() above.
  */
 
 static void gfs2_scan_glock_lru(int nr)
 {
 	struct gfs2_glock *gl;
-	int may_demote;
-	int nr_skipped = 0;
 	LIST_HEAD(skipped);
+	LIST_HEAD(dispose);
 
 	spin_lock(&lru_lock);
 	while(nr && !list_empty(&lru_list)) {
 		gl = list_entry(lru_list.next, struct gfs2_glock, gl_lru);
-		list_del_init(&gl->gl_lru);
-		clear_bit(GLF_LRU, &gl->gl_flags);
-		atomic_dec(&lru_count);
 
 		/* Test for being demotable */
 		if (!test_and_set_bit(GLF_LOCK, &gl->gl_flags)) {
-			gfs2_glock_hold(gl);
-			spin_unlock(&lru_lock);
-			spin_lock(&gl->gl_spin);
-			may_demote = demote_ok(gl);
-			if (may_demote) {
-				handle_callback(gl, LM_ST_UNLOCKED, 0);
-				nr--;
-			}
-			clear_bit(GLF_LOCK, &gl->gl_flags);
-			smp_mb__after_clear_bit();
-			if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
-				gfs2_glock_put_nolock(gl);
-			spin_unlock(&gl->gl_spin);
-			spin_lock(&lru_lock);
+			list_move(&gl->gl_lru, &dispose);
+			atomic_dec(&lru_count);
+			nr--;
 			continue;
 		}
-		nr_skipped++;
-		list_add(&gl->gl_lru, &skipped);
-		set_bit(GLF_LRU, &gl->gl_flags);
+
+		list_move(&gl->gl_lru, &skipped);
 	}
 	list_splice(&skipped, &lru_list);
-	atomic_add(nr_skipped, &lru_count);
+	if (!list_empty(&dispose))
+		gfs2_dispose_glock_lru(&dispose);
 	spin_unlock(&lru_lock);
 }
 
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:14 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAYEUC000370 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:14 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq8000596; Tue, 19 Feb 2013 05:34:12 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:39 +0000
Message-Id: <1361268460-3092-10-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 09/10] GFS2: Get a block reservation before
	resizing a file
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:14 -0000

From: Bob Peterson <rpeterso@redhat.com>

This patch allocates a block reservation structure before growing
or shrinking a file. Without this structure, the grow or shink code
can reference the bad pointer.

Signed-off-by: Bob Peterson <rpeterso@redhat.com>
Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index d29d779..df686d1 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -1288,6 +1288,10 @@ int gfs2_setattr_size(struct inode *inode, u64 newsize)
 
 	inode_dio_wait(inode);
 
+	ret = gfs2_rs_alloc(GFS2_I(inode));
+	if (ret)
+		return ret;
+
 	oldsize = inode->i_size;
 	if (newsize >= oldsize)
 		return do_grow(inode, newsize);
-- 
1.7.4

From swhiteho@redhat.com Tue Feb 19 05:34:15 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAYFKk000382 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:34:15 -0500
Received: from chywoon.redhat.com (vpn1-6-226.ams2.redhat.com [10.36.6.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAXwq9000596; Tue, 19 Feb 2013 05:34:14 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: linux-kernel@vger.kernel.org, cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 10:07:40 +0000
Message-Id: <1361268460-3092-11-git-send-email-swhiteho@redhat.com>
In-Reply-To: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
References: <1361268460-3092-1-git-send-email-swhiteho@redhat.com>
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 10/10] GFS2: Reinstate withdraw ack system
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:34:15 -0000

This patch reinstates the ack system which withdraw should be using. It
appears to have been accidentally forgotten when the lock module was
merged into GFS2, due to two different sysfs files having the same name.

Reported-by: David Teigland <teigland@redhat.com>
Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1533cf8..e2601ba 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -642,6 +642,7 @@ struct gfs2_sbd {
 	wait_queue_head_t sd_glock_wait;
 	atomic_t sd_glock_disposal;
 	struct completion sd_locking_init;
+	struct completion sd_wdack;
 	struct delayed_work sd_control_work;
 
 	/* Inode Stuff */
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index e063f22..1b612be 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -81,6 +81,7 @@ static struct gfs2_sbd *init_sbd(struct super_block *sb)
 	init_waitqueue_head(&sdp->sd_glock_wait);
 	atomic_set(&sdp->sd_glock_disposal, 0);
 	init_completion(&sdp->sd_locking_init);
+	init_completion(&sdp->sd_wdack);
 	spin_lock_init(&sdp->sd_statfs_spin);
 
 	spin_lock_init(&sdp->sd_rindex_spin);
diff --git a/fs/gfs2/sys.c b/fs/gfs2/sys.c
index 462e841..4fb9ad8 100644
--- a/fs/gfs2/sys.c
+++ b/fs/gfs2/sys.c
@@ -330,6 +330,28 @@ static ssize_t block_store(struct gfs2_sbd *sdp, const char *buf, size_t len)
 	return ret;
 }
 
+static ssize_t wdack_show(struct gfs2_sbd *sdp, char *buf)
+{
+	int val = completion_done(&sdp->sd_wdack) ? 1 : 0;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t wdack_store(struct gfs2_sbd *sdp, const char *buf, size_t len)
+{
+	ssize_t ret = len;
+	int val;
+
+	val = simple_strtol(buf, NULL, 0);
+
+	if ((val == 1) &&
+	    !strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, "lock_dlm"))
+		complete(&sdp->sd_wdack);
+	else
+		ret = -EINVAL;
+	return ret;
+}
+
 static ssize_t lkfirst_show(struct gfs2_sbd *sdp, char *buf)
 {
 	struct lm_lockstruct *ls = &sdp->sd_lockstruct;
@@ -461,7 +483,7 @@ static struct gfs2_attr gdlm_attr_##_name = __ATTR(_name,_mode,_show,_store)
 
 GDLM_ATTR(proto_name,		0444, proto_name_show,		NULL);
 GDLM_ATTR(block,		0644, block_show,		block_store);
-GDLM_ATTR(withdraw,		0644, withdraw_show,		withdraw_store);
+GDLM_ATTR(withdraw,		0644, wdack_show,		wdack_store);
 GDLM_ATTR(jid,			0644, jid_show,			jid_store);
 GDLM_ATTR(first,		0644, lkfirst_show,		lkfirst_store);
 GDLM_ATTR(first_done,		0444, first_done_show,		NULL);
diff --git a/fs/gfs2/util.c b/fs/gfs2/util.c
index f00d7c5..6402fb6 100644
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@ -54,6 +54,9 @@ int gfs2_lm_withdraw(struct gfs2_sbd *sdp, char *fmt, ...)
 
 		kobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);
 
+		if (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, "lock_dlm"))
+			wait_for_completion(&sdp->sd_wdack);
+
 		if (lm->lm_unmount) {
 			fs_err(sdp, "telling LM to unmount\n");
 			lm->lm_unmount(sdp);
-- 
1.7.4

From jajcus@jajcus.net Tue Feb 19 05:55:21 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JAtLKJ021210 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 05:55:21 -0500
Received: from mx1.redhat.com (ext-mx12.extmail.prod.ext.phx2.redhat.com
	[10.5.110.17])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1JAtKDa026281
	for <cluster-devel@redhat.com>; Tue, 19 Feb 2013 05:55:21 -0500
Received: from jajo.eggsoft.pl (eggsoft.sp.imz.pl [212.106.158.142])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1JAtHDI023933
	for <cluster-devel@redhat.com>; Tue, 19 Feb 2013 05:55:18 -0500
X-CheckPoint: {51235A14-1-1BF6AD4-3FFFF}
Received: from jajo.eggsoft (localhost [127.0.0.1])
	by jajo.eggsoft.pl (Postfix) with ESMTP id 36806B002
	for <cluster-devel@redhat.com>; Tue, 19 Feb 2013 11:55:15 +0100 (CET)
Date: Tue, 19 Feb 2013 11:55:14 +0100
From: Jacek Konieczny <jajcus@jajcus.net>
To: cluster-devel@redhat.com
Message-ID: <20130219115514.6111ba2b@jajo.eggsoft>
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-RedHat-Spam-Score: -1.901  (BAYES_00,SPF_PASS)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.17
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] DLM regression in 64-bit 3.7.x Kernel?
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 10:55:21 -0000

Hi,

I have recently upgraded my development cluster from 3.6.x to 3.7.1
kernel and clvmd stopped working (all locking operation result in 'Invalid
argument'). I have traced the problem to this call:

write(8, "\6\0\0\0\0\0\0\0\1\0\0\0\1\1\0\0\5@\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\320\307\351\326\277\177\0\0\20\17\36\331\277\177\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\313\351\326\277\177\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Hlk5NeaVF0qhDF20RBq61EZaIj5yyUJgWxxs4ntZedP34Rj3E2wadZfVwtOcvpKb", 184) = -1 EINVAL (Invalid argument)

Kernel sources show only a few conditions which can result in the EINVAL error
and the one introduced by the 'dlm: check the maximum size of a request from
user' patch seemed suspicious to me.

The commit: http://git.kernel.org/?p=linux/kernel/git/teigland/linux-dlm.git;a=commitdiff;h=2b75bc9121e54e22537207b47b71373bcb0be41c

Should a 64-bit kernel really refuse requests using the 64-bit
dlm_write_request struct when compiled with CONFIG_COMPAT on?

To verify my suspicions I have compiled the 3.7.9 with a little patch dropping 
the '(count > sizeof(struct dlm_write_request32) + DLM_RESNAME_MAXLEN)' check,
which solved the problem for me.

The patch will follow, though I am still not sure this is the solution.

Greets,
	Jacek

From jajcus@jajcus.net Tue Feb 19 06:41:19 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JBfJ8W020040 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 06:41:19 -0500
Received: from mx1.redhat.com (ext-mx16.extmail.prod.ext.phx2.redhat.com
	[10.5.110.21])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JBfJf6023151
	for <cluster-devel@redhat.com>; Tue, 19 Feb 2013 06:41:19 -0500
Received: from jajo.eggsoft.pl (eggsoft.sp.imz.pl [212.106.158.142])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1JBfASa019604
	for <cluster-devel@redhat.com>; Tue, 19 Feb 2013 06:41:11 -0500
X-CheckPoint: {512364D6-0-1BF6AD4-3FFFF}
Received: by jajo.eggsoft.pl (Postfix, from userid 1000)
	id 06571B002; Tue, 19 Feb 2013 12:41:08 +0100 (CET)
From: Jacek Konieczny <jajcus@jajcus.net>
To: cluster-devel@redhat.com
Date: Tue, 19 Feb 2013 12:40:50 +0100
Message-Id: <1361274050-27658-1-git-send-email-jajcus@jajcus.net>
In-Reply-To: <20130219115514.6111ba2b@jajo.eggsoft>
References: <20130219115514.6111ba2b@jajo.eggsoft>
X-RedHat-Spam-Score: -1.901  (BAYES_00,SPF_PASS)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.21
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH] dlm: Allow 64-bit request when
	CONFIG_COMPAT is on
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 11:41:19 -0000

Even if kernel is compiled for 32-bit ABI compatibility it still should
able to process 64-bit dlm_write_request struct.
The regression was introduced by:

b75bc91 dlm: check the maximum size of a request from user

Signed-off-by: Jacek Konieczny <jajcus@jajcus.net>
---
 fs/dlm/user.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/fs/dlm/user.c b/fs/dlm/user.c
index 7ff4985..d08a156 100644
--- a/fs/dlm/user.c
+++ b/fs/dlm/user.c
@@ -503,11 +503,7 @@ static ssize_t device_write(struct file *file, const char __user *buf,
 #endif
 		return -EINVAL;
 
-#ifdef CONFIG_COMPAT
-	if (count > sizeof(struct dlm_write_request32) + DLM_RESNAME_MAXLEN)
-#else
 	if (count > sizeof(struct dlm_write_request) + DLM_RESNAME_MAXLEN)
-#endif
 		return -EINVAL;
 
 	kbuf = kzalloc(count + 1, GFP_NOFS);
-- 
1.8.0.1

From swhiteho@redhat.com Tue Feb 19 11:39:56 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1JGdu23021324 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 19 Feb 2013 11:39:56 -0500
Received: from [10.10.51.154] (vpn-51-154.rdu2.redhat.com [10.10.51.154])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1JGds85005621; Tue, 19 Feb 2013 11:39:55 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: Linus Torvalds <torvalds@linux-foundation.org>
Content-Type: multipart/signed; micalg="pgp-sha1";
	protocol="application/pgp-signature";
	boundary="=-ezKJShqmIJk+6B9sTAy4"
Organization: Red Hat UK Ltd
Date: Tue, 19 Feb 2013 16:38:34 +0000
Message-ID: <1361291914.2704.19.camel@menhir>
Mime-Version: 1.0
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com, linux-kernel@vger.kernel.org
Subject: [Cluster-devel] GFS2: Pull request (merge window)
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 19 Feb 2013 16:39:56 -0000


--=-ezKJShqmIJk+6B9sTAy4
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable

Hi,

Please consider pulling the following GFS2 patches for the merge window,

Steve.

---------------------------------------------------------------------------
This is one of the smallest collections of patches for the merge
window for some time. There are some clean ups relating to the
transaction code and the shrinker, which are mostly in preparation
for further development, but also make the code much easier to
follow in these areas.

There is a patch which allows the use of ->writepages even in the
default ordered write mode for all writebacks. This results in
sending larger i/os to the block layer, and a subsequent increase
in performance. It also reduces the number of different i/o paths
by one.

There is also a bug fix reinstating the withdraw ack system which
somehow got lost when the lock modules were merged into GFS2.

---------------------------------------------------------------------------
The following changes since commit 6abb7c25775b7fb2225ad0508236d63ca710e65f=
:

  Merge tag 'regulator-3.8-rc5' of git://git.kernel.org/pub/scm/linux/kerne=
l/git/broonie/regulator (2013-01-28 22:44:53 -0800)

are available in the git repository at:

  git://git.kernel.org/pub/scm/linux/kernel/git/steve/gfs2-3.0-nmw.git mast=
er

Bob Peterson (1):
      GFS2: Get a block reservation before resizing a file

Steven Whitehouse (9):
      GFS2: Separate LRU scanning from shrinker
      GFS2: Merge revoke adding functions
      GFS2: Split gfs2_trans_add_bh() into two
      GFS2: Copy gfs2_trans_add_bh into new data/meta functions
      GFS2: Merge gfs2_attach_bufdata() into trans.c
      GFS2: Clean up freeze code
      GFS2: Use ->writepages for ordered writes
      GFS2: Split glock lru processing into two parts
      GFS2: Reinstate withdraw ack system

 fs/gfs2/aops.c       |   17 +++----
 fs/gfs2/bmap.c       |   30 +++++++-----
 fs/gfs2/dir.c        |   30 ++++++------
 fs/gfs2/file.c       |    4 +-
 fs/gfs2/glock.c      |  116 +++++++++++++++++++++++++++++++++-------------
 fs/gfs2/incore.h     |    8 ++--
 fs/gfs2/inode.c      |    8 ++--
 fs/gfs2/log.c        |   76 ++++++++++++++----------------
 fs/gfs2/log.h        |   12 +++++
 fs/gfs2/lops.c       |   83 +---------------------------------
 fs/gfs2/lops.h       |   14 +-----
 fs/gfs2/meta_io.c    |   35 --------------
 fs/gfs2/meta_io.h    |    3 -
 fs/gfs2/ops_fstype.c |    4 +-
 fs/gfs2/quota.c      |    4 +-
 fs/gfs2/rgrp.c       |   18 ++++----
 fs/gfs2/super.c      |   70 ++++------------------------
 fs/gfs2/super.h      |    3 -
 fs/gfs2/sys.c        |   48 ++++++++++++++------
 fs/gfs2/trans.c      |  124 +++++++++++++++++++++++++++++++++++++++++++++-=
----
 fs/gfs2/trans.h      |    3 +-
 fs/gfs2/util.c       |    3 +
 fs/gfs2/xattr.c      |   36 +++++++-------
 23 files changed, 375 insertions(+), 374 deletions(-)


--=-ezKJShqmIJk+6B9sTAy4
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIcBAABAgAGBQJRI6qFAAoJEMrg3m4a/8jSWaYP/jZsga/9ts5wiyVieyRuDjV8
ncMPi+Mmne5iCWixbg3BRkkA5LQrsj3o1fPvVdx0QtwnQVHx5g9erDlsAp7PquUC
9hXjgYy27SJAM5S1GwXsPZNQQ2PLD59ErpF7FBD7e0DPOpWhI7HbuySglGNI3L+S
VZWh4RB0tcb/JwEU1Wt9lSjDoVH8mH8kgsOGJYZn9D3LCiRDIeuFTbAKnYk2BVQ/
2brKxjaoUgSufchOlTnI65a8CIPorDa60Ab9j3Xp0c+Kgk0wEfyoxwWeUfZ68zQ5
vmRUxiEyAa0PEc1yfu3KZxZfQJnO/u16PXioMSg9Q1zhK1yghAv+h/OU3vQ12/jY
88JeH1zMR2Bm7KLqOMXQnXNFdJfGQ/ADQyAYAFGr+YiQqw1gkFyxZgqEdPkrG6gF
z2/Jilwx7d6gC/1hhj5OMw/UDXFHYvPjYrcPrOGRx6ac1GSacmVEOkoxFFg6XjdH
xaAYfDL2CsZ47WCSbp2Ip/+OHA/4pza8zW/qSccrg/s6t5R6J7hvFZfx4v2wMhqW
BCQypwb55ejHOXd6mE9tZTKPoPtprlSdabJ5VumF5v3nZ5nCzWOn09khmXzJVn4C
kyHEb1iPqYQgeqIstwNqD+F7pLiwmV0/i5qS1DAcUi7D9NoiaYGD9R4ROQzLJYBR
ocsIPB/mW/14w1AG6NuZ
=OauT
-----END PGP SIGNATURE-----

--=-ezKJShqmIJk+6B9sTAy4--

From jpokorny@redhat.com Wed Feb 20 05:39:29 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1KAdTxj014588 for <cluster-devel@listman.util.phx.redhat.com>;
	Wed, 20 Feb 2013 05:39:29 -0500
Received: from poki.brq.redhat.com (poki.brq.redhat.com [10.34.129.84])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1KAdSFq020648; Wed, 20 Feb 2013 05:39:28 -0500
From: =?UTF-8?q?Jan=20Pokorn=C3=BD?= <jpokorny@redhat.com>
To: cluster-devel@redhat.com
Date: Wed, 20 Feb 2013 11:39:25 +0100
Message-Id: <1361356765-19974-1-git-send-email-jpokorny@redhat.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH] rgmanager: remove copy-paste dupe in
	default_event_script.sl
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Wed, 20 Feb 2013 10:39:29 -0000

Signed-off-by: Jan Pokorný <jpokorny@redhat.com>
---
 rgmanager/src/resources/default_event_script.sl | 50 -------------------------
 1 file changed, 50 deletions(-)

diff --git a/rgmanager/src/resources/default_event_script.sl b/rgmanager/src/resources/default_event_script.sl
index c9cde4b..12260ee 100644
--- a/rgmanager/src/resources/default_event_script.sl
+++ b/rgmanager/src/resources/default_event_script.sl
@@ -292,56 +292,6 @@ define allowed_nodes(service)
 	return anodes;
 }
 
-%
-% Returns the set of online nodes in preferred/shuffled order which
-% are allowed to run this service.  Gives highest preference to current
-% owner if nofailback is specified.
-% 
-define allowed_nodes(service)
-{
-	variable anodes;
-	variable online;
-	variable nodes_domain;
-	variable ordered, restricted, nofailback;
-	variable state, owner;
-	variable depends;
-
-	(nofailback, restricted, ordered, nodes_domain) =
-			service_domain_info(service);
-	(,,, owner, state) = service_status(service);
-
-	anodes = nodes_online();
-
-	% Shuffle the array so we don't start all services on the same
-	% node.  TODO - add RR, Least-services, placement policies...
-	online = shuffle(anodes);
-
-	if (restricted == 1) {
-		anodes = intersection(nodes_domain, online);
-	} else {
-		% Ordered failover domains (nodes_domain) unioned with the
-		% online nodes basically just reorders the online node list
-		% according to failover domain priority rules.
-		anodes = union(intersection(nodes_domain, online),
-			       online);
-	}
-
-	if ((nofailback == 1) or (ordered == 0)) {
-		
-		if ((owner < 0) or (node_in_set(anodes, owner) == 0)) {
-			return anodes;
-		}
-		
-		% Because union takes left as priority, we can
-		% return the union of the current owner with the
-		% allowed node list.  This means the service will
-		% remain on the same node it's currently on.
-		return union(owner, anodes);
-	}
-
-	return anodes;
-}
-
 define string_list(thelist, delimiter)
 {
 	variable index;
-- 
1.7.11.7

From swhiteho@redhat.com Fri Feb 22 05:03:07 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1MA37Ft028787 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 22 Feb 2013 05:03:07 -0500
Received: from [10.10.51.223] (vpn-51-223.rdu2.redhat.com [10.10.51.223])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1MA367F029399
	for <cluster-devel@redhat.com>; Fri, 22 Feb 2013 05:03:06 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Fri, 22 Feb 2013 10:01:45 +0000
Message-ID: <1361527305.2720.6.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] GFS2 git tree
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 22 Feb 2013 10:03:07 -0000

Hi,

Linus pulled the -nmw tree yesterday evening, so that there are
currently no pending patches. As per usual, I'll hold any patches sent
in the mean time until -rc1 has appeared,

Steve.


From swhiteho@redhat.com Fri Feb 22 07:09:26 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1MC9QnL030910 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 22 Feb 2013 07:09:26 -0500
Received: from [10.10.51.223] (vpn-51-223.rdu2.redhat.com [10.10.51.223])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1MC9Om6018022
	for <cluster-devel@redhat.com>; Fri, 22 Feb 2013 07:09:25 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Fri, 22 Feb 2013 12:08:03 +0000
Message-ID: <1361534883.2720.25.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] fsck: Clean up pass1 inode iteration code
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 22 Feb 2013 12:09:26 -0000


The original version of this patch, including readahead for the
inodes only appears to deliver a performance improvement in some
particular cases, and slows down other cases. So this patch is
fairly similar in that it includes the clean ups from the previous
attempt, however the readahead has been left out for the time
being until the problem is better understood, and can be fixed.

This clean up still has the advantage of better code structure
around the main loop, and in addition it also reduced the number
of read requests which are generated too.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/gfs2/fsck/pass1.c b/gfs2/fsck/pass1.c
index 540f2a9..9a34e97 100644
--- a/gfs2/fsck/pass1.c
+++ b/gfs2/fsck/pass1.c
@@ -14,6 +14,7 @@
 #include <unistd.h>
 #include <string.h>
 #include <time.h>
+#include <fcntl.h>
 #include <sys/ioctl.h>
 #include <inttypes.h>
 #include <libintl.h>
@@ -1547,6 +1548,128 @@ static int check_system_inodes(struct gfs2_sbd *sdp)
 	return 0;
 }
 
+static int pass1_process_bitmap(struct gfs2_sbd *sdp, struct rgrp_tree *rgd, uint64_t *ibuf, unsigned n)
+{
+	struct gfs2_buffer_head *bh;
+	unsigned i;
+	uint64_t block;
+
+	for (i = 0; i < n; i++) {
+		block = ibuf[i];
+
+		/* skip gfs1 rindex indirect blocks */
+		if (sdp->gfs1 && blockfind(&gfs1_rindex_blks, block)) {
+			log_debug(_("Skipping rindex indir block "
+				    "%lld (0x%llx)\n"),
+				  (unsigned long long)block,
+				  (unsigned long long)block);
+			continue;
+		}
+		warm_fuzzy_stuff(block);
+
+		if (fsck_abort) { /* if asked to abort */
+			gfs2_special_free(&gfs1_rindex_blks);
+			return FSCK_OK;
+		}
+		if (skip_this_pass) {
+			printf( _("Skipping pass 1 is not a good idea.\n"));
+			skip_this_pass = FALSE;
+			fflush(stdout);
+		}
+		if (fsck_system_inode(sdp, block)) {
+			log_debug(_("Already processed system inode "
+				    "%lld (0x%llx)\n"),
+				  (unsigned long long)block,
+				  (unsigned long long)block);
+			continue;
+		}
+		bh = bread(sdp, block);
+
+		if (gfs2_check_meta(bh, GFS2_METATYPE_DI)) {
+			/* In gfs2, a bitmap mark of 2 means an inode,
+			   but in gfs1 it means any metadata.  So if
+			   this is gfs1 and not an inode, it may be
+			   okay.  If it's non-dinode metadata, it will
+			   be referenced by an inode, so we need to
+			   skip it here and it will be sorted out
+			   when the referencing inode is checked. */
+			if (sdp->gfs1) {
+				uint32_t check_magic;
+
+				check_magic = ((struct gfs2_meta_header *)
+					       (bh->b_data))->mh_magic;
+				if (be32_to_cpu(check_magic) == GFS2_MAGIC) {
+					log_debug( _("Deferring GFS1 "
+						     "metadata block #"
+						     "%" PRIu64" (0x%"
+						     PRIx64 ")\n"),
+						   block, block);
+					brelse(bh);
+					continue;
+				}
+			}
+			log_err( _("Found invalid inode at block #"
+				   "%llu (0x%llx)\n"),
+				 (unsigned long long)block,
+				 (unsigned long long)block);
+			if (gfs2_blockmap_set(bl, block, gfs2_block_free)) {
+				stack;
+				brelse(bh);
+				gfs2_special_free(&gfs1_rindex_blks);
+				return FSCK_ERROR;
+			}
+			check_n_fix_bitmap(sdp, block, gfs2_block_free);
+		} else if (handle_di(sdp, bh) < 0) {
+			stack;
+			brelse(bh);
+			gfs2_special_free(&gfs1_rindex_blks);
+			return FSCK_ERROR;
+		}
+		/* Ignore everything else - they should be hit by the
+		   handle_di step.  Don't check NONE either, because
+		   check_meta passes everything if GFS2_METATYPE_NONE
+		   is specified.  Hopefully, other metadata types such
+		   as indirect blocks will be handled when the inode
+		   itself is processed, and if it's not, it should be
+		   caught in pass5. */
+		brelse(bh);
+	}
+
+	return 0;
+}
+
+static int pass1_process_rgrp(struct gfs2_sbd *sdp, struct rgrp_tree *rgd)
+{
+	unsigned k, n, i;
+	uint64_t *ibuf = malloc(sdp->bsize * GFS2_NBBY * sizeof(uint64_t));
+	int ret;
+
+	for (k = 0; k < rgd->ri.ri_length; k++) {
+		n = lgfs2_bm_scan(rgd, k, ibuf, GFS2_BLKST_DINODE);
+
+		if (n) {
+			ret = pass1_process_bitmap(sdp, rgd, ibuf, n);
+			if (ret)
+				return ret;
+		}
+
+		/*
+		  For GFS1, we have to count the "free meta" blocks in the
+		  resource group and mark them specially so we can count them
+		  properly in pass5.
+		 */
+		if (!sdp->gfs1)
+			continue;
+
+		n = lgfs2_bm_scan(rgd, k, ibuf, GFS2_BLKST_UNLINKED);
+		for (i = 0; i < n; i++)
+			gfs2_blockmap_set(bl, ibuf[i], gfs2_freemeta);
+	}
+
+	free(ibuf);
+	return 0;
+}
+
 /**
  * pass1 - walk through inodes and check inode state
  *
@@ -1563,12 +1686,10 @@ static int check_system_inodes(struct gfs2_sbd *sdp)
 int pass1(struct gfs2_sbd *sdp)
 {
 	struct osi_node *n, *next = NULL;
-	struct gfs2_buffer_head *bh;
-	uint64_t block = 0;
 	struct rgrp_tree *rgd;
-	int first;
 	uint64_t i;
 	uint64_t rg_count = 0;
+	int ret;
 
 	osi_list_init(&gfs1_rindex_blks.list);
 
@@ -1611,115 +1732,10 @@ int pass1(struct gfs2_sbd *sdp)
 			gfs2_meta_rgrp);*/
 		}
 
-		first = 1;
+		ret = pass1_process_rgrp(sdp, rgd);
+		if (ret)
+			return ret;
 
-		while (1) {
-			/* "block" is relative to the entire file system */
-			/* Get the next dinode in the file system, according
-			   to the bitmap.  This should ONLY be dinodes unless
-			   it's GFS1, in which case it can be any metadata. */
-			if (gfs2_next_rg_meta(rgd, &block, first))
-				break;
-			/* skip gfs1 rindex indirect blocks */
-			if (sdp->gfs1 && blockfind(&gfs1_rindex_blks, block)) {
-				log_debug(_("Skipping rindex indir block "
-					    "%lld (0x%llx)\n"),
-					  (unsigned long long)block,
-					  (unsigned long long)block);
-				first = 0;
-				continue;
-			}
-			warm_fuzzy_stuff(block);
-
-			if (fsck_abort) { /* if asked to abort */
-				gfs2_special_free(&gfs1_rindex_blks);
-				return FSCK_OK;
-			}
-			if (skip_this_pass) {
-				printf( _("Skipping pass 1 is not a good idea.\n"));
-				skip_this_pass = FALSE;
-				fflush(stdout);
-			}
-			if (fsck_system_inode(sdp, block)) {
-				log_debug(_("Already processed system inode "
-					    "%lld (0x%llx)\n"),
-					  (unsigned long long)block,
-					  (unsigned long long)block);
-				first = 0;
-				continue;
-			}
-			bh = bread(sdp, block);
-
-			/*log_debug( _("Checking metadata block #%" PRIu64
-			  " (0x%" PRIx64 ")\n"), block, block);*/
-
-			if (gfs2_check_meta(bh, GFS2_METATYPE_DI)) {
-				/* In gfs2, a bitmap mark of 2 means an inode,
-				   but in gfs1 it means any metadata.  So if
-				   this is gfs1 and not an inode, it may be
-				   okay.  If it's non-dinode metadata, it will
-				   be referenced by an inode, so we need to
-				   skip it here and it will be sorted out
-				   when the referencing inode is checked. */
-				if (sdp->gfs1) {
-					uint32_t check_magic;
-
-					check_magic = ((struct
-							gfs2_meta_header *)
-						       (bh->b_data))->mh_magic;
-					if (be32_to_cpu(check_magic) ==
-					    GFS2_MAGIC) {
-						log_debug( _("Deferring GFS1 "
-							     "metadata block #"
-							     "%" PRIu64" (0x%"
-							     PRIx64 ")\n"),
-							   block, block);
-						brelse(bh);
-						first = 0;
-						continue;
-					}
-				}
-				log_err( _("Found invalid inode at block #"
-					   "%llu (0x%llx)\n"),
-					 (unsigned long long)block,
-					 (unsigned long long)block);
-				if (gfs2_blockmap_set(bl, block,
-						      gfs2_block_free)) {
-					stack;
-					brelse(bh);
-					gfs2_special_free(&gfs1_rindex_blks);
-					return FSCK_ERROR;
-				}
-				check_n_fix_bitmap(sdp, block,
-						   gfs2_block_free);
-			} else if (handle_di(sdp, bh) < 0) {
-				stack;
-				brelse(bh);
-				gfs2_special_free(&gfs1_rindex_blks);
-				return FSCK_ERROR;
-			}
-			/* Ignore everything else - they should be hit by the
-			   handle_di step.  Don't check NONE either, because
-			   check_meta passes everything if GFS2_METATYPE_NONE
-			   is specified.  Hopefully, other metadata types such
-			   as indirect blocks will be handled when the inode
-			   itself is processed, and if it's not, it should be
-			   caught in pass5. */
-			brelse(bh);
-			first = 0;
-		}
-		/*
-		  For GFS1, we have to count the "free meta" blocks in the
-		  resource group and mark them specially so we can count them
-		  properly in pass5.
-		 */
-		if (!sdp->gfs1)
-			continue;
-		first = 1;
-		while (gfs2_next_rg_freemeta(rgd, &block, first) == 0) {
-			gfs2_blockmap_set(bl, block, gfs2_freemeta);
-			first = 0;
-		}
 	}
 	gfs2_special_free(&gfs1_rindex_blks);
 	return FSCK_OK;
diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index 46d4d67..db31a6c 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -757,12 +757,12 @@ extern int build_root(struct gfs2_sbd *sdp);
 extern int do_init_inum(struct gfs2_sbd *sdp);
 extern int do_init_statfs(struct gfs2_sbd *sdp);
 extern int gfs2_check_meta(struct gfs2_buffer_head *bh, int type);
+extern unsigned lgfs2_bm_scan(struct rgrp_tree *rgd, unsigned idx,
+			      uint64_t *buf, uint8_t state);
 extern int gfs2_next_rg_meta(struct rgrp_tree *rgd, uint64_t *block,
 			     int first);
 extern int gfs2_next_rg_metatype(struct gfs2_sbd *sdp, struct rgrp_tree *rgd,
 				 uint64_t *block, uint32_t type, int first);
-extern int gfs2_next_rg_freemeta(struct rgrp_tree *rgd, uint64_t *block,
-				 int first);
 
 /* super.c */
 extern int check_sb(struct gfs2_sb *sb);
diff --git a/gfs2/libgfs2/structures.c b/gfs2/libgfs2/structures.c
index 645c45a..f9231ca 100644
--- a/gfs2/libgfs2/structures.c
+++ b/gfs2/libgfs2/structures.c
@@ -495,6 +495,24 @@ int gfs2_check_meta(struct gfs2_buffer_head *bh, int type)
 	return 0;
 }
 
+unsigned lgfs2_bm_scan(struct rgrp_tree *rgd, unsigned idx, uint64_t *buf, uint8_t state)
+{
+	struct gfs2_bitmap *bi = &rgd->bits[idx];
+	unsigned n = 0;
+	uint32_t blk = 0;
+
+	while(blk < (bi->bi_len * GFS2_NBBY)) {
+		blk = gfs2_bitfit((const unsigned char *)rgd->bh[idx]->b_data + bi->bi_offset,
+				  bi->bi_len, blk, state);
+		if (blk == BFITNOENT)
+			break;
+		buf[n++] = blk + (bi->bi_start * GFS2_NBBY) + rgd->ri.ri_data0;
+		blk++;
+	}
+
+	return n;
+}
+
 /**
  * gfs2_next_rg_meta
  * @rgd:
@@ -545,11 +563,6 @@ int gfs2_next_rg_meta(struct rgrp_tree *rgd, uint64_t *block, int first)
 	return __gfs2_next_rg_meta(rgd, block, first, GFS2_BLKST_DINODE);
 }
 
-int gfs2_next_rg_freemeta(struct rgrp_tree *rgd, uint64_t *block, int first)
-{
-	return __gfs2_next_rg_meta(rgd, block, first, GFS2_BLKST_UNLINKED);
-}
-
 /**
  * next_rg_metatype
  * @rgd:


From anprice@redhat.com Fri Feb 22 08:34:20 2013
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1MDYKtI002581 for <cluster-devel@listman.util.phx.redhat.com>;
	Fri, 22 Feb 2013 08:34:20 -0500
Received: from rhlaptop.andrewprice.me.uk (ovpn-116-68.ams2.redhat.com
	[10.36.116.68])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1MDYIdK003682
	(version=TLSv1/SSLv3 cipher=DHE-RSA-CAMELLIA256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Fri, 22 Feb 2013 08:34:19 -0500
Message-ID: <512773D9.2090400@redhat.com>
Date: Fri, 22 Feb 2013 13:34:17 +0000
From: Andrew Price <anprice@redhat.com>
User-Agent: Mozilla/5.0 (X11; Linux x86_64;
	rv:17.0) Gecko/20130110 Thunderbird/17.0.2
MIME-Version: 1.0
To: cluster-devel@redhat.com
References: <1361534883.2720.25.camel@menhir>
In-Reply-To: <1361534883.2720.25.camel@menhir>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-loop: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] fsck: Clean up pass1 inode iteration code
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Fri, 22 Feb 2013 13:34:20 -0000

Hi Steve,

On 22/02/13 12:08, Steven Whitehouse wrote:
>
> The original version of this patch, including readahead for the
> inodes only appears to deliver a performance improvement in some
> particular cases, and slows down other cases. So this patch is
> fairly similar in that it includes the clean ups from the previous
> attempt, however the readahead has been left out for the time
> being until the problem is better understood, and can be fixed.
>
> This clean up still has the advantage of better code structure
> around the main loop, and in addition it also reduced the number
> of read requests which are generated too.

Looks good to me.

> Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
>
> diff --git a/gfs2/fsck/pass1.c b/gfs2/fsck/pass1.c
> index 540f2a9..9a34e97 100644
> --- a/gfs2/fsck/pass1.c
> +++ b/gfs2/fsck/pass1.c
> @@ -14,6 +14,7 @@
>   #include <unistd.h>
>   #include <string.h>
>   #include <time.h>
> +#include <fcntl.h>
>   #include <sys/ioctl.h>
>   #include <inttypes.h>
>   #include <libintl.h>
> @@ -1547,6 +1548,128 @@ static int check_system_inodes(struct gfs2_sbd *sdp)
>   	return 0;
>   }
>
> +static int pass1_process_bitmap(struct gfs2_sbd *sdp, struct rgrp_tree *rgd, uint64_t *ibuf, unsigned n)
> +{
> +	struct gfs2_buffer_head *bh;
> +	unsigned i;
> +	uint64_t block;
> +
> +	for (i = 0; i < n; i++) {
> +		block = ibuf[i];
> +
> +		/* skip gfs1 rindex indirect blocks */
> +		if (sdp->gfs1 && blockfind(&gfs1_rindex_blks, block)) {
> +			log_debug(_("Skipping rindex indir block "
> +				    "%lld (0x%llx)\n"),
> +				  (unsigned long long)block,
> +				  (unsigned long long)block);
> +			continue;
> +		}
> +		warm_fuzzy_stuff(block);
> +
> +		if (fsck_abort) { /* if asked to abort */
> +			gfs2_special_free(&gfs1_rindex_blks);
> +			return FSCK_OK;
> +		}
> +		if (skip_this_pass) {
> +			printf( _("Skipping pass 1 is not a good idea.\n"));
> +			skip_this_pass = FALSE;
> +			fflush(stdout);
> +		}
> +		if (fsck_system_inode(sdp, block)) {
> +			log_debug(_("Already processed system inode "
> +				    "%lld (0x%llx)\n"),
> +				  (unsigned long long)block,
> +				  (unsigned long long)block);
> +			continue;
> +		}
> +		bh = bread(sdp, block);
> +
> +		if (gfs2_check_meta(bh, GFS2_METATYPE_DI)) {
> +			/* In gfs2, a bitmap mark of 2 means an inode,
> +			   but in gfs1 it means any metadata.  So if
> +			   this is gfs1 and not an inode, it may be
> +			   okay.  If it's non-dinode metadata, it will
> +			   be referenced by an inode, so we need to
> +			   skip it here and it will be sorted out
> +			   when the referencing inode is checked. */
> +			if (sdp->gfs1) {
> +				uint32_t check_magic;
> +
> +				check_magic = ((struct gfs2_meta_header *)
> +					       (bh->b_data))->mh_magic;
> +				if (be32_to_cpu(check_magic) == GFS2_MAGIC) {
> +					log_debug( _("Deferring GFS1 "
> +						     "metadata block #"
> +						     "%" PRIu64" (0x%"
> +						     PRIx64 ")\n"),
> +						   block, block);
> +					brelse(bh);
> +					continue;
> +				}
> +			}
> +			log_err( _("Found invalid inode at block #"
> +				   "%llu (0x%llx)\n"),
> +				 (unsigned long long)block,
> +				 (unsigned long long)block);
> +			if (gfs2_blockmap_set(bl, block, gfs2_block_free)) {
> +				stack;
> +				brelse(bh);
> +				gfs2_special_free(&gfs1_rindex_blks);
> +				return FSCK_ERROR;
> +			}
> +			check_n_fix_bitmap(sdp, block, gfs2_block_free);
> +		} else if (handle_di(sdp, bh) < 0) {
> +			stack;
> +			brelse(bh);
> +			gfs2_special_free(&gfs1_rindex_blks);
> +			return FSCK_ERROR;
> +		}
> +		/* Ignore everything else - they should be hit by the
> +		   handle_di step.  Don't check NONE either, because
> +		   check_meta passes everything if GFS2_METATYPE_NONE
> +		   is specified.  Hopefully, other metadata types such
> +		   as indirect blocks will be handled when the inode
> +		   itself is processed, and if it's not, it should be
> +		   caught in pass5. */
> +		brelse(bh);
> +	}
> +
> +	return 0;
> +}
> +
> +static int pass1_process_rgrp(struct gfs2_sbd *sdp, struct rgrp_tree *rgd)
> +{
> +	unsigned k, n, i;
> +	uint64_t *ibuf = malloc(sdp->bsize * GFS2_NBBY * sizeof(uint64_t));

Coverity will complain about ibuf not getting checked here.

Andy

> +	int ret;
> +
> +	for (k = 0; k < rgd->ri.ri_length; k++) {
> +		n = lgfs2_bm_scan(rgd, k, ibuf, GFS2_BLKST_DINODE);
> +
> +		if (n) {
> +			ret = pass1_process_bitmap(sdp, rgd, ibuf, n);
> +			if (ret)
> +				return ret;
> +		}
> +
> +		/*
> +		  For GFS1, we have to count the "free meta" blocks in the
> +		  resource group and mark them specially so we can count them
> +		  properly in pass5.
> +		 */
> +		if (!sdp->gfs1)
> +			continue;
> +
> +		n = lgfs2_bm_scan(rgd, k, ibuf, GFS2_BLKST_UNLINKED);
> +		for (i = 0; i < n; i++)
> +			gfs2_blockmap_set(bl, ibuf[i], gfs2_freemeta);
> +	}
> +
> +	free(ibuf);
> +	return 0;
> +}
> +
>   /**
>    * pass1 - walk through inodes and check inode state
>    *
> @@ -1563,12 +1686,10 @@ static int check_system_inodes(struct gfs2_sbd *sdp)
>   int pass1(struct gfs2_sbd *sdp)
>   {
>   	struct osi_node *n, *next = NULL;
> -	struct gfs2_buffer_head *bh;
> -	uint64_t block = 0;
>   	struct rgrp_tree *rgd;
> -	int first;
>   	uint64_t i;
>   	uint64_t rg_count = 0;
> +	int ret;
>
>   	osi_list_init(&gfs1_rindex_blks.list);
>
> @@ -1611,115 +1732,10 @@ int pass1(struct gfs2_sbd *sdp)
>   			gfs2_meta_rgrp);*/
>   		}
>
> -		first = 1;
> +		ret = pass1_process_rgrp(sdp, rgd);
> +		if (ret)
> +			return ret;
>
> -		while (1) {
> -			/* "block" is relative to the entire file system */
> -			/* Get the next dinode in the file system, according
> -			   to the bitmap.  This should ONLY be dinodes unless
> -			   it's GFS1, in which case it can be any metadata. */
> -			if (gfs2_next_rg_meta(rgd, &block, first))
> -				break;
> -			/* skip gfs1 rindex indirect blocks */
> -			if (sdp->gfs1 && blockfind(&gfs1_rindex_blks, block)) {
> -				log_debug(_("Skipping rindex indir block "
> -					    "%lld (0x%llx)\n"),
> -					  (unsigned long long)block,
> -					  (unsigned long long)block);
> -				first = 0;
> -				continue;
> -			}
> -			warm_fuzzy_stuff(block);
> -
> -			if (fsck_abort) { /* if asked to abort */
> -				gfs2_special_free(&gfs1_rindex_blks);
> -				return FSCK_OK;
> -			}
> -			if (skip_this_pass) {
> -				printf( _("Skipping pass 1 is not a good idea.\n"));
> -				skip_this_pass = FALSE;
> -				fflush(stdout);
> -			}
> -			if (fsck_system_inode(sdp, block)) {
> -				log_debug(_("Already processed system inode "
> -					    "%lld (0x%llx)\n"),
> -					  (unsigned long long)block,
> -					  (unsigned long long)block);
> -				first = 0;
> -				continue;
> -			}
> -			bh = bread(sdp, block);
> -
> -			/*log_debug( _("Checking metadata block #%" PRIu64
> -			  " (0x%" PRIx64 ")\n"), block, block);*/
> -
> -			if (gfs2_check_meta(bh, GFS2_METATYPE_DI)) {
> -				/* In gfs2, a bitmap mark of 2 means an inode,
> -				   but in gfs1 it means any metadata.  So if
> -				   this is gfs1 and not an inode, it may be
> -				   okay.  If it's non-dinode metadata, it will
> -				   be referenced by an inode, so we need to
> -				   skip it here and it will be sorted out
> -				   when the referencing inode is checked. */
> -				if (sdp->gfs1) {
> -					uint32_t check_magic;
> -
> -					check_magic = ((struct
> -							gfs2_meta_header *)
> -						       (bh->b_data))->mh_magic;
> -					if (be32_to_cpu(check_magic) ==
> -					    GFS2_MAGIC) {
> -						log_debug( _("Deferring GFS1 "
> -							     "metadata block #"
> -							     "%" PRIu64" (0x%"
> -							     PRIx64 ")\n"),
> -							   block, block);
> -						brelse(bh);
> -						first = 0;
> -						continue;
> -					}
> -				}
> -				log_err( _("Found invalid inode at block #"
> -					   "%llu (0x%llx)\n"),
> -					 (unsigned long long)block,
> -					 (unsigned long long)block);
> -				if (gfs2_blockmap_set(bl, block,
> -						      gfs2_block_free)) {
> -					stack;
> -					brelse(bh);
> -					gfs2_special_free(&gfs1_rindex_blks);
> -					return FSCK_ERROR;
> -				}
> -				check_n_fix_bitmap(sdp, block,
> -						   gfs2_block_free);
> -			} else if (handle_di(sdp, bh) < 0) {
> -				stack;
> -				brelse(bh);
> -				gfs2_special_free(&gfs1_rindex_blks);
> -				return FSCK_ERROR;
> -			}
> -			/* Ignore everything else - they should be hit by the
> -			   handle_di step.  Don't check NONE either, because
> -			   check_meta passes everything if GFS2_METATYPE_NONE
> -			   is specified.  Hopefully, other metadata types such
> -			   as indirect blocks will be handled when the inode
> -			   itself is processed, and if it's not, it should be
> -			   caught in pass5. */
> -			brelse(bh);
> -			first = 0;
> -		}
> -		/*
> -		  For GFS1, we have to count the "free meta" blocks in the
> -		  resource group and mark them specially so we can count them
> -		  properly in pass5.
> -		 */
> -		if (!sdp->gfs1)
> -			continue;
> -		first = 1;
> -		while (gfs2_next_rg_freemeta(rgd, &block, first) == 0) {
> -			gfs2_blockmap_set(bl, block, gfs2_freemeta);
> -			first = 0;
> -		}
>   	}
>   	gfs2_special_free(&gfs1_rindex_blks);
>   	return FSCK_OK;
> diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
> index 46d4d67..db31a6c 100644
> --- a/gfs2/libgfs2/libgfs2.h
> +++ b/gfs2/libgfs2/libgfs2.h
> @@ -757,12 +757,12 @@ extern int build_root(struct gfs2_sbd *sdp);
>   extern int do_init_inum(struct gfs2_sbd *sdp);
>   extern int do_init_statfs(struct gfs2_sbd *sdp);
>   extern int gfs2_check_meta(struct gfs2_buffer_head *bh, int type);
> +extern unsigned lgfs2_bm_scan(struct rgrp_tree *rgd, unsigned idx,
> +			      uint64_t *buf, uint8_t state);
>   extern int gfs2_next_rg_meta(struct rgrp_tree *rgd, uint64_t *block,
>   			     int first);
>   extern int gfs2_next_rg_metatype(struct gfs2_sbd *sdp, struct rgrp_tree *rgd,
>   				 uint64_t *block, uint32_t type, int first);
> -extern int gfs2_next_rg_freemeta(struct rgrp_tree *rgd, uint64_t *block,
> -				 int first);
>
>   /* super.c */
>   extern int check_sb(struct gfs2_sb *sb);
> diff --git a/gfs2/libgfs2/structures.c b/gfs2/libgfs2/structures.c
> index 645c45a..f9231ca 100644
> --- a/gfs2/libgfs2/structures.c
> +++ b/gfs2/libgfs2/structures.c
> @@ -495,6 +495,24 @@ int gfs2_check_meta(struct gfs2_buffer_head *bh, int type)
>   	return 0;
>   }
>
> +unsigned lgfs2_bm_scan(struct rgrp_tree *rgd, unsigned idx, uint64_t *buf, uint8_t state)
> +{
> +	struct gfs2_bitmap *bi = &rgd->bits[idx];
> +	unsigned n = 0;
> +	uint32_t blk = 0;
> +
> +	while(blk < (bi->bi_len * GFS2_NBBY)) {
> +		blk = gfs2_bitfit((const unsigned char *)rgd->bh[idx]->b_data + bi->bi_offset,
> +				  bi->bi_len, blk, state);
> +		if (blk == BFITNOENT)
> +			break;
> +		buf[n++] = blk + (bi->bi_start * GFS2_NBBY) + rgd->ri.ri_data0;
> +		blk++;
> +	}
> +
> +	return n;
> +}
> +
>   /**
>    * gfs2_next_rg_meta
>    * @rgd:
> @@ -545,11 +563,6 @@ int gfs2_next_rg_meta(struct rgrp_tree *rgd, uint64_t *block, int first)
>   	return __gfs2_next_rg_meta(rgd, block, first, GFS2_BLKST_DINODE);
>   }
>
> -int gfs2_next_rg_freemeta(struct rgrp_tree *rgd, uint64_t *block, int first)
> -{
> -	return __gfs2_next_rg_meta(rgd, block, first, GFS2_BLKST_UNLINKED);
> -}
> -
>   /**
>    * next_rg_metatype
>    * @rgd:
>
>

From teigland@redhat.com Mon Feb 25 11:11:55 2013
Received: from int-mx12.intmail.prod.int.phx2.redhat.com
	(int-mx12.intmail.prod.int.phx2.redhat.com [10.5.11.25])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1PGBtEu004699 for <cluster-devel@listman.util.phx.redhat.com>;
	Mon, 25 Feb 2013 11:11:55 -0500
Received: from redhat.com (s01.msp.redhat.com [10.15.95.15])
	by int-mx12.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1PGBqQ1013096
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES128-SHA bits=128 verify=NO);
	Mon, 25 Feb 2013 11:11:55 -0500
Date: Mon, 25 Feb 2013 11:11:52 -0500
From: David Teigland <teigland@redhat.com>
To: Jacek Konieczny <jajcus@jajcus.net>
Message-ID: <20130225161152.GC5627@redhat.com>
References: <20130219115514.6111ba2b@jajo.eggsoft>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20130219115514.6111ba2b@jajo.eggsoft>
User-Agent: Mutt/1.5.20 (2009-12-10)
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.25
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] DLM regression in 64-bit 3.7.x Kernel?
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Mon, 25 Feb 2013 16:11:56 -0000

On Tue, Feb 19, 2013 at 11:55:14AM +0100, Jacek Konieczny wrote:
> Hi,
> 
> I have recently upgraded my development cluster from 3.6.x to 3.7.1
> kernel and clvmd stopped working (all locking operation result in 'Invalid
> argument'). I have traced the problem to this call:
> 
> write(8, "\6\0\0\0\0\0\0\0\1\0\0\0\1\1\0\0\5@\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\320\307\351\326\277\177\0\0\20\17\36\331\277\177\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\313\351\326\277\177\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Hlk5NeaVF0qhDF20RBq61EZaIj5yyUJgWxxs4ntZedP34Rj3E2wadZfVwtOcvpKb", 184) = -1 EINVAL (Invalid argument)
> 
> Kernel sources show only a few conditions which can result in the EINVAL error
> and the one introduced by the 'dlm: check the maximum size of a request from
> user' patch seemed suspicious to me.
> 
> The commit: http://git.kernel.org/?p=linux/kernel/git/teigland/linux-dlm.git;a=commitdiff;h=2b75bc9121e54e22537207b47b71373bcb0be41c
> 
> Should a 64-bit kernel really refuse requests using the 64-bit
> dlm_write_request struct when compiled with CONFIG_COMPAT on?
> 
> To verify my suspicions I have compiled the 3.7.9 with a little patch dropping 
> the '(count > sizeof(struct dlm_write_request32) + DLM_RESNAME_MAXLEN)' check,
> which solved the problem for me.
> 
> The patch will follow, though I am still not sure this is the solution.

Hi, the fix is already upstream: d4b0bcf32b946590afd29e202d6a399b84fe6c67
Dave

From dan.carpenter@oracle.com Tue Feb 26 01:14:51 2013
Received: from int-mx02.intmail.prod.int.phx2.redhat.com
	(int-mx02.intmail.prod.int.phx2.redhat.com [10.5.11.12])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1Q6EpMk022925 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 01:14:51 -0500
Received: from mx1.redhat.com (ext-mx12.extmail.prod.ext.phx2.redhat.com
	[10.5.110.17])
	by int-mx02.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1Q6Epwa020984; Tue, 26 Feb 2013 01:14:51 -0500
Received: from userp1040.oracle.com (userp1040.oracle.com [156.151.31.81])
	by mx1.redhat.com (8.14.4/8.14.4) with ESMTP id r1Q6EoON022010;
	Tue, 26 Feb 2013 01:14:50 -0500
Received: from acsinet22.oracle.com (acsinet22.oracle.com [141.146.126.238])
	by userp1040.oracle.com (Sentrion-MTA-4.3.1/Sentrion-MTA-4.3.1) with
	ESMTP id r1Q6Enru030961
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=OK);
	Tue, 26 Feb 2013 06:14:50 GMT
Received: from acsmt356.oracle.com (acsmt356.oracle.com [141.146.40.156])
	by acsinet22.oracle.com (8.14.4+Sun/8.14.4) with ESMTP id
	r1Q6EmxA015660
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
	Tue, 26 Feb 2013 06:14:49 GMT
Received: from abhmt113.oracle.com (abhmt113.oracle.com [141.146.116.65])
	by acsmt356.oracle.com (8.12.11.20060308/8.12.11) with ESMTP id
	r1Q6Em0m027359; Tue, 26 Feb 2013 00:14:48 -0600
Received: from longonot.mountain (/41.202.240.6)
	by default (Oracle Beehive Gateway v4.0)
	with ESMTP ; Mon, 25 Feb 2013 22:14:47 -0800
Date: Tue, 26 Feb 2013 09:13:49 +0300
From: Dan Carpenter <dan.carpenter@oracle.com>
To: rpeterso@redhat.com
Message-ID: <20130226061348.GA16153@longonot.mountain>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.21 (2010-09-15)
X-Source-IP: acsinet22.oracle.com [141.146.126.238]
X-RedHat-Spam-Score: -105.004  (BAYES_00, DCC_REPUT_13_19, RCVD_IN_DNSWL_MED,
	RP_MATCHES_RCVD, SPF_PASS, UNPARSEABLE_RELAY, USER_IN_WHITELIST)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.12
X-Scanned-By: MIMEDefang 2.68 on 10.5.110.17
X-loop: cluster-devel@redhat.com
X-Mailman-Approved-At: Tue, 26 Feb 2013 04:50:20 -0500
Cc: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] GFS2: Combine functions gfs2_glock_wait and
	wait_on_holder
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 06:14:51 -0000

Hello Bob Peterson,

This is probably a false positive but I thought it would be
interesting to ask.

The patch 07a790494260: "GFS2: Combine functions gfs2_glock_wait and 
wait_on_holder" from Aug 9, 2012, leads to the following warning on
my not yet pushed version of Smatch:

"fs/gfs2/inode.c:217 gfs2_lookup_by_inum()
	 error: passing non neg 13 to ERR_PTR"

   884  /**
   885   * gfs2_glock_wait - wait on a glock acquisition
   886   * @gh: the glock holder
   887   *
   888   * Returns: 0 on success
   889   */
   890  
   891  int gfs2_glock_wait(struct gfs2_holder *gh)
   892  {
   893          unsigned long time1 = jiffies;
   894  
   895          might_sleep();
   896          wait_on_bit(&gh->gh_iflags, HIF_WAIT, gfs2_glock_holder_wait, TASK_UNINTERRUPTIBLE);
   897          if (time_after(jiffies, time1 + HZ)) /* have we waited > a second? */
   898                  /* Lengthen the minimum hold time. */
   899                  gh->gh_gl->gl_hold_time = min(gh->gh_gl->gl_hold_time +
   900                                                GL_GLOCK_HOLD_INCR,
   901                                                GL_GLOCK_MAX_HOLD);
   902          return gh->gh_error;
                       ^^^^^^^^^^^^
Can this be GLR_TRYFAILED at this point?  If it is then it would
cause a problem later on.

   903  }

regards,
dan carpenter

From swhiteho@redhat.com Tue Feb 26 05:09:38 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QA9chW010653 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 05:09:38 -0500
Received: from [10.10.55.50] (vpn-55-50.rdu2.redhat.com [10.10.55.50])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QA9bcw005329; Tue, 26 Feb 2013 05:09:37 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: Dan Carpenter <dan.carpenter@oracle.com>
In-Reply-To: <20130226061348.GA16153@longonot.mountain>
References: <20130226061348.GA16153@longonot.mountain>
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Tue, 26 Feb 2013 10:08:08 +0000
Message-ID: <1361873288.2705.2.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Cc: cluster-devel@redhat.com
Subject: Re: [Cluster-devel] GFS2: Combine functions gfs2_glock_wait and
 wait_on_holder
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 10:09:38 -0000

Hi,

That is a false positive, because gfs2_lookup_by_inum does not call the
gfs2_glock_nq_num() function with arguments which specify a try lock.
There are few uses of the try lock left in GFS2 and over time we are
eliminating them gradually,

Steve.

On Tue, 2013-02-26 at 09:13 +0300, Dan Carpenter wrote:
> Hello Bob Peterson,
> 
> This is probably a false positive but I thought it would be
> interesting to ask.
> 
> The patch 07a790494260: "GFS2: Combine functions gfs2_glock_wait and 
> wait_on_holder" from Aug 9, 2012, leads to the following warning on
> my not yet pushed version of Smatch:
> 
> "fs/gfs2/inode.c:217 gfs2_lookup_by_inum()
> 	 error: passing non neg 13 to ERR_PTR"
> 
>    884  /**
>    885   * gfs2_glock_wait - wait on a glock acquisition
>    886   * @gh: the glock holder
>    887   *
>    888   * Returns: 0 on success
>    889   */
>    890  
>    891  int gfs2_glock_wait(struct gfs2_holder *gh)
>    892  {
>    893          unsigned long time1 = jiffies;
>    894  
>    895          might_sleep();
>    896          wait_on_bit(&gh->gh_iflags, HIF_WAIT, gfs2_glock_holder_wait, TASK_UNINTERRUPTIBLE);
>    897          if (time_after(jiffies, time1 + HZ)) /* have we waited > a second? */
>    898                  /* Lengthen the minimum hold time. */
>    899                  gh->gh_gl->gl_hold_time = min(gh->gh_gl->gl_hold_time +
>    900                                                GL_GLOCK_HOLD_INCR,
>    901                                                GL_GLOCK_MAX_HOLD);
>    902          return gh->gh_error;
>                        ^^^^^^^^^^^^
> Can this be GLR_TRYFAILED at this point?  If it is then it would
> cause a problem later on.
> 
>    903  }
> 
> regards,
> dan carpenter
> 


From swhiteho@redhat.com Tue Feb 26 08:27:39 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QDRdZT028289 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 08:27:39 -0500
Received: from [10.10.55.50] (vpn-55-50.rdu2.redhat.com [10.10.55.50])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QDRcLK000931
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 08:27:39 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Tue, 26 Feb 2013 13:26:08 +0000
Message-ID: <1361885169.2705.12.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] GFS2: Clean up inode creation path
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 13:27:39 -0000

This patch cleans up the inode creation code path in GFS2. After the
Orlov allocator was merged, a number of potential improvements are
now possible, and this is a first set of these.

The quota handling is now updated so that it matches the point in
the code where the allocation takes place. This means that the one
exception in gfs2_alloc_blocks relating to quota is now no longer
required, and we can use the generic code everywhere.

In addition the call to figure out whether we need to allocate any
extra blocks in order to add a directory entry is moved higher up
gfs2_create_inode. This means that if it returns an error, we
can deal with that at a stage where it is easier to handle that case.
The returned status cannot change during the function since we hold
an exclusive lock on the directory.

Two calls to gfs2_rindex_update have been changed to one, again at
the top of gfs2_create_inode to simplify error handling.

The time stamps are also now initialised earlier in the creation
process, this is gradually moving towards being able to remove the
call to gfs2_refresh_inode in gfs2_inode_create once we have all the
fields covered.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>


diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c
index cc00bd1..df51557 100644
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@ -392,11 +392,15 @@ static int alloc_dinode(struct gfs2_inode *ip, u32 flags)
 	int error;
 	int dblocks = 1;
 
-	error = gfs2_inplace_reserve(ip, RES_DINODE, flags);
+	error = gfs2_quota_lock_check(ip);
 	if (error)
 		goto out;
 
-	error = gfs2_trans_begin(sdp, RES_RG_BIT + RES_STATFS, 0);
+	error = gfs2_inplace_reserve(ip, RES_DINODE, flags);
+	if (error)
+		goto out_quota;
+
+	error = gfs2_trans_begin(sdp, RES_RG_BIT + RES_STATFS + RES_QUOTA, 0);
 	if (error)
 		goto out_ipreserv;
 
@@ -409,6 +413,8 @@ static int alloc_dinode(struct gfs2_inode *ip, u32 flags)
 
 out_ipreserv:
 	gfs2_inplace_release(ip);
+out_quota:
+	gfs2_quota_unlock(ip);
 out:
 	return error;
 }
@@ -445,7 +451,6 @@ static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct gfs2_dinode *di;
 	struct buffer_head *dibh;
-	struct timespec tv = CURRENT_TIME;
 
 	dibh = gfs2_meta_new(ip->i_gl, ip->i_no_addr);
 	gfs2_trans_add_meta(ip->i_gl, dibh);
@@ -461,7 +466,9 @@ static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 	di->di_nlink = 0;
 	di->di_size = cpu_to_be64(ip->i_inode.i_size);
 	di->di_blocks = cpu_to_be64(1);
-	di->di_atime = di->di_mtime = di->di_ctime = cpu_to_be64(tv.tv_sec);
+	di->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);
+	di->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);
+	di->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);
 	di->di_major = cpu_to_be32(MAJOR(ip->i_inode.i_rdev));
 	di->di_minor = cpu_to_be32(MINOR(ip->i_inode.i_rdev));
 	di->di_goal_meta = di->di_goal_data = cpu_to_be64(ip->i_no_addr);
@@ -476,9 +483,9 @@ static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 	di->di_entries = 0;
 	memset(&di->__pad4, 0, sizeof(di->__pad4));
 	di->di_eattr = 0;
-	di->di_atime_nsec = cpu_to_be32(tv.tv_nsec);
-	di->di_mtime_nsec = cpu_to_be32(tv.tv_nsec);
-	di->di_ctime_nsec = cpu_to_be32(tv.tv_nsec);
+	di->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);
+	di->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);
+	di->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);
 	memset(&di->di_reserved, 0, sizeof(di->di_reserved));
 
 	switch(ip->i_inode.i_mode & S_IFMT) {
@@ -505,58 +512,18 @@ static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 	*bhp = dibh;
 }
 
-static int make_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
-		       const char *symname, struct buffer_head **bhp)
-{
-	struct inode *inode = &ip->i_inode;
-	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
-	int error;
-
-	error = gfs2_rindex_update(sdp);
-	if (error)
-		return error;
-
-	error = gfs2_quota_lock(dip, inode->i_uid, inode->i_gid);
-	if (error)
-		return error;
-
-	error = gfs2_quota_check(dip, inode->i_uid, inode->i_gid);
-	if (error)
-		goto out_quota;
-
-	error = gfs2_trans_begin(sdp, RES_DINODE + RES_QUOTA, 0);
-	if (error)
-		goto out_quota;
-
-	init_dinode(dip, ip, symname, bhp);
-	gfs2_quota_change(dip, +1, inode->i_uid, inode->i_gid);
-	gfs2_trans_end(sdp);
-
-out_quota:
-	gfs2_quota_unlock(dip);
-	return error;
-}
-
 static int link_dinode(struct gfs2_inode *dip, const struct qstr *name,
-		       struct gfs2_inode *ip)
+		       struct gfs2_inode *ip, int arq)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
-	int alloc_required;
 	struct buffer_head *dibh;
 	int error;
 
-	error = gfs2_rindex_update(sdp);
-	if (error)
-		return error;
-
 	error = gfs2_quota_lock(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);
 	if (error)
-		goto fail;
+		return error;
 
-	error = alloc_required = gfs2_diradd_alloc_required(&dip->i_inode, name);
-	if (alloc_required < 0)
-		goto fail_quota_locks;
-	if (alloc_required) {
+	if (arq) {
 		error = gfs2_quota_check(dip, dip->i_inode.i_uid, dip->i_inode.i_gid);
 		if (error)
 			goto fail_quota_locks;
@@ -592,15 +559,10 @@ static int link_dinode(struct gfs2_inode *dip, const struct qstr *name,
 
 fail_end_trans:
 	gfs2_trans_end(sdp);
-
 fail_ipreserv:
-	if (alloc_required)
-		gfs2_inplace_release(dip);
-
+	gfs2_inplace_release(dip);
 fail_quota_locks:
 	gfs2_quota_unlock(dip);
-
-fail:
 	return error;
 }
 
@@ -652,6 +614,7 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	int error;
 	struct buffer_head *bh = NULL;
 	u32 aflags = 0;
+	int arq;
 
 	if (!name->len || name->len > GFS2_FNAMESIZE)
 		return -ENAMETOOLONG;
@@ -660,6 +623,10 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	if (error)
 		return error;
 
+	error = gfs2_rindex_update(sdp);
+	if (error)
+		return error;
+
 	error = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, ghs);
 	if (error)
 		goto fail;
@@ -674,11 +641,15 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	if (error)
 		goto fail_gunlock;
 
+	arq = error = gfs2_diradd_alloc_required(dir, name);
+	if (error < 0)
+		goto fail_gunlock;
+
 	inode = new_inode(sdp->sd_vfs);
-	if (!inode) {
-		gfs2_glock_dq_uninit(ghs);
-		return -ENOMEM;
-	}
+	error = -ENOMEM;
+	if (!inode)
+		goto fail_gunlock;
+
 	ip = GFS2_I(inode);
 	error = gfs2_rs_alloc(ip);
 	if (error)
@@ -688,6 +659,7 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	inode->i_mode = mode;
 	inode->i_rdev = dev;
 	inode->i_size = size;
+	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	munge_mode_uid_gid(dip, inode);
 	ip->i_goal = dip->i_goal;
 
@@ -708,10 +680,13 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	if (error)
 		goto fail_free_inode;
 
-	error = make_dinode(dip, ip, symname, &bh);
+	error = gfs2_trans_begin(sdp, RES_DINODE, 0);
 	if (error)
 		goto fail_gunlock2;
 
+	init_dinode(dip, ip, symname, &bh);
+	gfs2_trans_end(sdp);
+
 	error = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);
 	if (error)
 		goto fail_gunlock2;
@@ -737,7 +712,7 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	if (error)
 		goto fail_gunlock3;
 
-	error = link_dinode(dip, name, ip);
+	error = link_dinode(dip, name, ip, arq);
 	if (error)
 		goto fail_gunlock3;
 
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index 52c2aea..4f7b380 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -2184,13 +2184,7 @@ int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,
 	if (dinode)
 		gfs2_trans_add_unrevoke(sdp, block, 1);
 
-	/*
-	 * This needs reviewing to see why we cannot do the quota change
-	 * at this point in the dinode case.
-	 */
-	if (ndata)
-		gfs2_quota_change(ip, ndata, ip->i_inode.i_uid,
-				  ip->i_inode.i_gid);
+	gfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);
 
 	rbm.rgd->rd_free_clone -= *nblocks;
 	trace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,


From anprice@redhat.com Tue Feb 26 09:04:31 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QE4VEv026408 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 09:04:31 -0500
Received: from rhlaptop.andrewprice.me.uk.com (ovpn-116-97.ams2.redhat.com
	[10.36.116.97])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QE4Smw018988
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 09:04:30 -0500
From: Andrew Price <anprice@redhat.com>
To: cluster-devel@redhat.com
Date: Tue, 26 Feb 2013 14:04:21 +0000
Message-Id: <1361887466-20763-1-git-send-email-anprice@redhat.com>
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 0/5] mkfs.gfs2 improvements (groundwork)
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 14:04:31 -0000

This patchset lays the groundwork for the RAID stripe alignment (etc.)
enhancements I'm working on. Notably it reduces the peak heap usage (from >3GB
to ~25MB for a 50TB fs with default options) and also improves performance
slightly. It also adds more tests to the test suite (run 'make check').

Andrew Price (5):
  libgfs2: Rework blk_alloc_i
  libgfs2: Make gfs2_rgrp_out accept char buffers
  mkfs.gfs2: Reduce memory usage
  gfs2-utils: Make the tool tests script more useful
  mkfs.gfs2: Separate user options from file system params

 .gitignore                  |   2 +
 gfs2/convert/gfs2_convert.c |  10 +-
 gfs2/edit/hexedit.c         |   4 +-
 gfs2/fsck/initialize.c      |   4 +-
 gfs2/fsck/metawalk.c        |   4 +-
 gfs2/fsck/pass5.c           |   2 +-
 gfs2/fsck/rgrepair.c        |   4 +-
 gfs2/libgfs2/fs_geometry.c  |   4 +-
 gfs2/libgfs2/fs_ops.c       |  99 +++++---
 gfs2/libgfs2/gfs1.c         |   6 +-
 gfs2/libgfs2/libgfs2.h      |  10 +-
 gfs2/libgfs2/ondisk.c       |  32 ++-
 gfs2/libgfs2/structures.c   |   2 +-
 gfs2/mkfs/main_jadd.c       |   2 +-
 gfs2/mkfs/main_mkfs.c       | 593 +++++++++++++++++++++++---------------------
 tests/tool_tests.sh         |  56 ++++-
 16 files changed, 476 insertions(+), 358 deletions(-)

-- 
1.8.1.2

From anprice@redhat.com Tue Feb 26 09:04:32 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QE4WOl026418 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 09:04:32 -0500
Received: from rhlaptop.andrewprice.me.uk.com (ovpn-116-97.ams2.redhat.com
	[10.36.116.97])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QE4Smx018988
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 09:04:31 -0500
From: Andrew Price <anprice@redhat.com>
To: cluster-devel@redhat.com
Date: Tue, 26 Feb 2013 14:04:22 +0000
Message-Id: <1361887466-20763-2-git-send-email-anprice@redhat.com>
In-Reply-To: <1361887466-20763-1-git-send-email-anprice@redhat.com>
References: <1361887466-20763-1-git-send-email-anprice@redhat.com>
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 1/5] libgfs2: Rework blk_alloc_i
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 14:04:32 -0000

blk_alloc_i previously chose any resource group with a free block and
assumed that the bitmaps were already available in the rgrp_tree. This
patch allows us to allocate blocks in a resource group with a given
number of free blocks in order to plan ahead and reads in the bitmap
data on demand. It also removes some exit()s from blk_alloc_i.

Signed-off-by: Andrew Price <anprice@redhat.com>
---
 gfs2/libgfs2/fs_ops.c  | 79 ++++++++++++++++++++++++++++++++++++++------------
 gfs2/libgfs2/libgfs2.h |  1 +
 2 files changed, 61 insertions(+), 19 deletions(-)

diff --git a/gfs2/libgfs2/fs_ops.c b/gfs2/libgfs2/fs_ops.c
index 3d027e8..b6c268d 100644
--- a/gfs2/libgfs2/fs_ops.c
+++ b/gfs2/libgfs2/fs_ops.c
@@ -116,32 +116,24 @@ void inode_put(struct gfs2_inode **ip_in)
 	*ip_in = NULL; /* make sure the memory isn't accessed again */
 }
 
-static uint64_t blk_alloc_i(struct gfs2_sbd *sdp, unsigned int type)
+static int blk_alloc_in_rg(struct gfs2_sbd *sdp, unsigned int type, struct rgrp_tree *rl, uint64_t *blkno)
 {
-	struct osi_node *n, *next = NULL;
-	struct rgrp_tree *rl = NULL;
 	struct gfs2_rindex *ri;
 	struct gfs2_rgrp *rg;
 	unsigned int block, bn = 0, x = 0, y = 0;
 	unsigned int state;
 	struct gfs2_buffer_head *bh;
 
-	memset(&rg, 0, sizeof(rg));
-	for (n = osi_first(&sdp->rgtree); n; n = next) {
-		next = osi_next(n);
-		rl = (struct rgrp_tree *)n;
-		if (rl->rg.rg_free)
-			break;
+	if (rl == NULL || rl->rg.rg_free == 0) {
+		errno = ENOSPC;
+		return -1;
 	}
 
-	if (n == NULL) {
-		fprintf(stderr, "Not enough space available on device\n");
-		exit(1);
-	}
+	if (rl->bh[0] == NULL && gfs2_rgrp_read(sdp, rl) != 0)
+		return -1;
 
 	ri = &rl->ri;
 	rg = &rl->rg;
-
 	for (block = 0; block < ri->ri_length; block++) {
 		bh = rl->bh[block];
 		x = (block) ? sizeof(struct gfs2_meta_header) : sizeof(struct gfs2_rgrp);
@@ -157,7 +149,7 @@ static uint64_t blk_alloc_i(struct gfs2_sbd *sdp, unsigned int type)
 
 	fprintf(stderr, "allocation is broken (1): %"PRIu64" %u\n",
 	    (uint64_t)rl->ri.ri_addr, rl->rg.rg_free);
-	exit(1);
+	return -1;
 
 found:
 	if (bn >= ri->ri_bitbytes * GFS2_NBBY) {
@@ -165,7 +157,7 @@ found:
 		    " (0x%" PRIx64 ") Free:%u\n",
 		    bn, ri->ri_bitbytes * GFS2_NBBY, (uint64_t)rl->ri.ri_addr,
 		    (uint64_t)rl->ri.ri_addr, rl->rg.rg_free);
-		exit(1);
+		return -1;
 	}
 
 	switch (type) {
@@ -179,7 +171,7 @@ found:
 		break;
 	default:
 		fprintf(stderr, "bad state\n");
-		exit(1);
+		return -1;
 	}
 
 	bh->b_data[x] &= ~(0x03 << (GFS2_BIT_SIZE * y));
@@ -193,7 +185,27 @@ found:
 		gfs2_rgrp_out(rg, rl->bh[0]);
 
 	sdp->blks_alloced++;
-	return ri->ri_data0 + bn;
+	*blkno = ri->ri_data0 + bn;
+	return 0;
+}
+
+/**
+ * Do not use this function, it's only here until we can kill it.
+ * Use blk_alloc_in_rg directly instead.
+ */
+static uint64_t blk_alloc_i(struct gfs2_sbd *sdp, unsigned int type)
+{
+	int ret;
+	uint64_t blkno = 0;
+	struct osi_node *n = NULL;
+	for (n = osi_first(&sdp->rgtree); n; n = osi_next(n)) {
+		if (((struct rgrp_tree *)n)->rg.rg_free)
+			break;
+	}
+	ret = blk_alloc_in_rg(sdp, type, (struct rgrp_tree *)n, &blkno);
+	if (ret != 0) /* Do what the old blk_alloc_i did */
+		exit(1);
+	return blkno;
 }
 
 uint64_t data_alloc(struct gfs2_inode *ip)
@@ -220,6 +232,33 @@ uint64_t dinode_alloc(struct gfs2_sbd *sdp)
 	return blk_alloc_i(sdp, DINODE);
 }
 
+/**
+ * Allocate a dinode block in a bitmap. In order to plan ahead we look for a
+ * resource group with blksreq free blocks but only allocate the one dinode block.
+ * Returns 0 on success with the allocated block number in *blkno or non-zero otherwise.
+ */
+int lgfs2_dinode_alloc(struct gfs2_sbd *sdp, const uint64_t blksreq, uint64_t *blkno)
+{
+	int ret;
+	struct rgrp_tree *rgt;
+	struct osi_node *n = NULL;
+	for (n = osi_first(&sdp->rgtree); n; n = osi_next(n)) {
+		rgt = (struct rgrp_tree *)n;
+		if (rgt->rg.rg_free >= blksreq)
+			break;
+	}
+	if (rgt == NULL)
+		return -1;
+
+	ret = blk_alloc_in_rg(sdp, DINODE, rgt, blkno);
+	gfs2_rgrp_relse(rgt);
+
+	if (ret == 0)
+		sdp->dinodes_alloced++;
+
+	return ret;
+}
+
 static __inline__ void buffer_clear_tail(struct gfs2_sbd *sdp,
 					 struct gfs2_buffer_head *bh, int head)
 {
@@ -1380,7 +1419,9 @@ static struct gfs2_inode *__createi(struct gfs2_inode *dip,
 
 	gfs2_lookupi(dip, filename, strlen(filename), &ip);
 	if (!ip) {
-		bn = dinode_alloc(sdp);
+		err = lgfs2_dinode_alloc(sdp, 1, &bn);
+		if (err != 0)
+			return NULL;
 
 		if (if_gfs1)
 			inum.no_formal_ino = bn;
diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index db31a6c..c415745 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -440,6 +440,7 @@ extern void inode_put(struct gfs2_inode **ip);
 extern uint64_t data_alloc(struct gfs2_inode *ip);
 extern uint64_t meta_alloc(struct gfs2_inode *ip);
 extern uint64_t dinode_alloc(struct gfs2_sbd *sdp);
+extern int lgfs2_dinode_alloc(struct gfs2_sbd *sdp, const uint64_t blksreq, uint64_t *blkno);
 extern int gfs2_readi(struct gfs2_inode *ip, void *buf, uint64_t offset,
 		      unsigned int size);
 #define gfs2_writei(ip, buf, offset, size) \
-- 
1.8.1.2

From anprice@redhat.com Tue Feb 26 09:04:33 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QE4XrG026426 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 09:04:33 -0500
Received: from rhlaptop.andrewprice.me.uk.com (ovpn-116-97.ams2.redhat.com
	[10.36.116.97])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QE4Sn0018988
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 09:04:32 -0500
From: Andrew Price <anprice@redhat.com>
To: cluster-devel@redhat.com
Date: Tue, 26 Feb 2013 14:04:23 +0000
Message-Id: <1361887466-20763-3-git-send-email-anprice@redhat.com>
In-Reply-To: <1361887466-20763-1-git-send-email-anprice@redhat.com>
References: <1361887466-20763-1-git-send-email-anprice@redhat.com>
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 2/5] libgfs2: Make gfs2_rgrp_out accept char
	buffers
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 14:04:33 -0000

In order to prepare for handling resource groups separately from buffer
heads in mkfs.gfs2, change gfs2_rgrp_out to copy rgrps to char buffers
instead of buffer heads. Copying to bh's is now done in
gfs2_rgrp_out_bh.

Signed-off-by: Andrew Price <anprice@redhat.com>
---
 gfs2/convert/gfs2_convert.c | 10 +++++-----
 gfs2/edit/hexedit.c         |  4 ++--
 gfs2/fsck/initialize.c      |  4 ++--
 gfs2/fsck/metawalk.c        |  4 ++--
 gfs2/fsck/pass5.c           |  2 +-
 gfs2/fsck/rgrepair.c        |  4 ++--
 gfs2/libgfs2/fs_geometry.c  |  4 ++--
 gfs2/libgfs2/fs_ops.c       | 20 ++++++++++----------
 gfs2/libgfs2/gfs1.c         |  6 +++---
 gfs2/libgfs2/libgfs2.h      |  8 +++++---
 gfs2/libgfs2/ondisk.c       | 32 +++++++++++++++++++++-----------
 gfs2/libgfs2/structures.c   |  2 +-
 gfs2/mkfs/main_jadd.c       |  2 +-
 13 files changed, 57 insertions(+), 45 deletions(-)

diff --git a/gfs2/convert/gfs2_convert.c b/gfs2/convert/gfs2_convert.c
index 72c974f..235c95c 100644
--- a/gfs2/convert/gfs2_convert.c
+++ b/gfs2/convert/gfs2_convert.c
@@ -237,7 +237,7 @@ static int convert_rgs(struct gfs2_sbd *sbp)
 		sbp->dinodes_alloced += rgd1->rg_useddi;
 		convert_bitmaps(sbp, rgd);
 		/* Write the updated rgrp to the gfs2 buffer */
-		gfs2_rgrp_out(&rgd->rg, rgd->bh[0]);
+		gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[0]);
 		rgs++;
 		if (rgs % 100 == 0) {
 			printf(".");
@@ -359,7 +359,7 @@ static void fix_metatree(struct gfs2_sbd *sbp, struct gfs2_inode *ip,
 			bh = bread(sbp, block);
 			if (new)
 				memset(bh->b_data, 0, sbp->bsize);
-			gfs2_meta_header_out(&mh, bh);
+			gfs2_meta_header_out_bh(&mh, bh);
 		}
 
 		hdrsize = blk->height ? sizeof(struct gfs2_meta_header) :
@@ -517,7 +517,7 @@ static void fix_jdatatree(struct gfs2_sbd *sbp, struct gfs2_inode *ip,
 			if (new)
 				memset(bh->b_data, 0, sbp->bsize);
 			if (h < (blk->height - 1))
-				gfs2_meta_header_out(&mh, bh);
+				gfs2_meta_header_out_bh(&mh, bh);
 		}
 
 		if (amount > sbp->bsize - ptramt)
@@ -1855,9 +1855,9 @@ static int journ_space_to_rg(struct gfs2_sbd *sdp)
 		convert_bitmaps(sdp, rgd);
 		for (x = 0; x < rgd->ri.ri_length; x++) {
 			if (x)
-				gfs2_meta_header_out(&mh, rgd->bh[x]);
+				gfs2_meta_header_out_bh(&mh, rgd->bh[x]);
 			else
-				gfs2_rgrp_out(&rgd->rg, rgd->bh[x]);
+				gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[x]);
 		}
 	} /* for each journal */
 	return error;
diff --git a/gfs2/edit/hexedit.c b/gfs2/edit/hexedit.c
index 931b3c3..4856181 100644
--- a/gfs2/edit/hexedit.c
+++ b/gfs2/edit/hexedit.c
@@ -1106,7 +1106,7 @@ static void set_rgrp_flags(int rgnum, uint32_t new_flags, int modify, int full)
 		if (sbd.gfs1)
 			gfs_rgrp_out(&rg.rg1, rbh);
 		else
-			gfs2_rgrp_out(&rg.rg2, rbh);
+			gfs2_rgrp_out_bh(&rg.rg2, rbh);
 		brelse(rbh);
 	} else {
 		if (full) {
@@ -2125,7 +2125,7 @@ static void process_field(const char *field, const char *nstr)
 		gfs2_rgrp_in(&rg, rbh);
 		if (setval) {
 			gfs2_rgrp_assignval(&rg, field, newval);
-			gfs2_rgrp_out(&rg, rbh);
+			gfs2_rgrp_out_bh(&rg, rbh);
 			if (!termlines)
 				gfs2_rgrp_printval(&rg, field);
 		} else {
diff --git a/gfs2/fsck/initialize.c b/gfs2/fsck/initialize.c
index e64ab3a..7d64b0a 100644
--- a/gfs2/fsck/initialize.c
+++ b/gfs2/fsck/initialize.c
@@ -314,7 +314,7 @@ static void check_rgrp_integrity(struct gfs2_sbd *sdp, struct rgrp_tree *rgd,
 		if (sdp->gfs1)
 			gfs_rgrp_out((struct gfs_rgrp *)&rgd->rg, rgd->bh[0]);
 		else
-			gfs2_rgrp_out(&rgd->rg, rgd->bh[0]);
+			gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[0]);
 		*this_rg_cleaned = 1;
 		log_info( _("The rgrp at %lld (0x%llx) was cleaned of %d "
 			    "free metadata blocks.\n"),
@@ -336,7 +336,7 @@ static void check_rgrp_integrity(struct gfs2_sbd *sdp, struct rgrp_tree *rgd,
 				gfs_rgrp_out((struct gfs_rgrp *)&rgd->rg,
 					     rgd->bh[0]);
 			else
-				gfs2_rgrp_out(&rgd->rg, rgd->bh[0]);
+				gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[0]);
 			*this_rg_fixed = 1;
 			log_err( _("The rgrp was fixed.\n"));
 		} else
diff --git a/gfs2/fsck/metawalk.c b/gfs2/fsck/metawalk.c
index d8193c5..5838fba 100644
--- a/gfs2/fsck/metawalk.c
+++ b/gfs2/fsck/metawalk.c
@@ -83,14 +83,14 @@ int check_n_fix_bitmap(struct gfs2_sbd *sdp, uint64_t blk,
 					gfs_rgrp_out((struct gfs_rgrp *)
 						     &rgd->rg, rgd->bh[0]);
 				else
-					gfs2_rgrp_out(&rgd->rg, rgd->bh[0]);
+					gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[0]);
 			} else if (old_bitmap_state == GFS2_BLKST_FREE) {
 				rgd->rg.rg_free--;
 				if (sdp->gfs1)
 					gfs_rgrp_out((struct gfs_rgrp *)
 						     &rgd->rg, rgd->bh[0]);
 				else
-					gfs2_rgrp_out(&rgd->rg, rgd->bh[0]);
+					gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[0]);
 			}
 			log_err( _("The bitmap was fixed.\n"));
 		} else {
diff --git a/gfs2/fsck/pass5.c b/gfs2/fsck/pass5.c
index 6c08e13..92861a1 100644
--- a/gfs2/fsck/pass5.c
+++ b/gfs2/fsck/pass5.c
@@ -274,7 +274,7 @@ static void update_rgrp(struct gfs2_sbd *sdp, struct rgrp_tree *rgp,
 			if (sdp->gfs1)
 				gfs_rgrp_out(gfs1rg, rgp->bh[0]);
 			else
-				gfs2_rgrp_out(&rgp->rg, rgp->bh[0]);
+				gfs2_rgrp_out_bh(&rgp->rg, rgp->bh[0]);
 		} else
 			log_err( _("Resource group counts left inconsistent\n"));
 	}
diff --git a/gfs2/fsck/rgrepair.c b/gfs2/fsck/rgrepair.c
index c3467ba..27368a2 100644
--- a/gfs2/fsck/rgrepair.c
+++ b/gfs2/fsck/rgrepair.c
@@ -684,7 +684,7 @@ static int rewrite_rg_block(struct gfs2_sbd *sdp, struct rgrp_tree *rg,
 			mh.mh_magic = GFS2_MAGIC;
 			mh.mh_type = GFS2_METATYPE_RB;
 			mh.mh_format = GFS2_FORMAT_RB;
-			gfs2_meta_header_out(&mh, rg->bh[x]);
+			gfs2_meta_header_out_bh(&mh, rg->bh[x]);
 		} else {
 			if (sdp->gfs1)
 				memset(&rg->rg, 0, sizeof(struct gfs_rgrp));
@@ -698,7 +698,7 @@ static int rewrite_rg_block(struct gfs2_sbd *sdp, struct rgrp_tree *rg,
 				gfs_rgrp_out((struct gfs_rgrp *)&rg->rg,
 					     rg->bh[x]);
 			else
-				gfs2_rgrp_out(&rg->rg, rg->bh[x]);
+				gfs2_rgrp_out_bh(&rg->rg, rg->bh[x]);
 		}
 		brelse(rg->bh[x]);
 		rg->bh[x] = NULL;
diff --git a/gfs2/libgfs2/fs_geometry.c b/gfs2/libgfs2/fs_geometry.c
index e248f7c..e716127 100644
--- a/gfs2/libgfs2/fs_geometry.c
+++ b/gfs2/libgfs2/fs_geometry.c
@@ -217,9 +217,9 @@ void build_rgrps(struct gfs2_sbd *sdp, int do_write)
 			for (x = 0; x < bitblocks; x++) {
 				rl->bh[x] = bget(sdp, rl->start + x);
 				if (x)
-					gfs2_meta_header_out(&mh, rl->bh[x]);
+					gfs2_meta_header_out_bh(&mh, rl->bh[x]);
 				else
-					gfs2_rgrp_out(&rl->rg, rl->bh[x]);
+					gfs2_rgrp_out_bh(&rl->rg, rl->bh[x]);
 			}
 		}
 
diff --git a/gfs2/libgfs2/fs_ops.c b/gfs2/libgfs2/fs_ops.c
index b6c268d..4ea6dd3 100644
--- a/gfs2/libgfs2/fs_ops.c
+++ b/gfs2/libgfs2/fs_ops.c
@@ -182,7 +182,7 @@ found:
 	if (sdp->gfs1)
 		gfs_rgrp_out((struct gfs_rgrp *)rg, rl->bh[0]);
 	else
-		gfs2_rgrp_out(rg, rl->bh[0]);
+		gfs2_rgrp_out_bh(rg, rl->bh[0]);
 
 	sdp->blks_alloced++;
 	*blkno = ri->ri_data0 + bn;
@@ -294,7 +294,7 @@ void unstuff_dinode(struct gfs2_inode *ip)
 			mh.mh_magic = GFS2_MAGIC;
 			mh.mh_type = GFS2_METATYPE_JD;
 			mh.mh_format = GFS2_FORMAT_JD;
-			gfs2_meta_header_out(&mh, bh);
+			gfs2_meta_header_out_bh(&mh, bh);
 
 			buffer_copy_tail(sdp, bh,
 					 sizeof(struct gfs2_meta_header),
@@ -371,7 +371,7 @@ void build_height(struct gfs2_inode *ip, int height)
 			mh.mh_magic = GFS2_MAGIC;
 			mh.mh_type = GFS2_METATYPE_IN;
 			mh.mh_format = GFS2_FORMAT_IN;
-			gfs2_meta_header_out(&mh, bh);
+			gfs2_meta_header_out_bh(&mh, bh);
 			buffer_copy_tail(sdp, bh,
 					 sizeof(struct gfs2_meta_header),
 					 ip->i_bh, sizeof(struct gfs2_dinode));
@@ -494,7 +494,7 @@ void block_map(struct gfs2_inode *ip, uint64_t lblock, int *new,
 			mh.mh_magic = GFS2_MAGIC;
 			mh.mh_type = GFS2_METATYPE_IN;
 			mh.mh_format = GFS2_FORMAT_IN;
-			gfs2_meta_header_out(&mh, bh);
+			gfs2_meta_header_out_bh(&mh, bh);
 		} else {
 			if (*dblock == ip->i_di.di_num.no_addr)
 				bh = ip->i_bh;
@@ -688,7 +688,7 @@ int __gfs2_writei(struct gfs2_inode *ip, void *buf,
 				mh.mh_magic = GFS2_MAGIC;
 				mh.mh_type = GFS2_METATYPE_JD;
 				mh.mh_format = GFS2_FORMAT_JD;
-				gfs2_meta_header_out(&mh, bh);
+				gfs2_meta_header_out_bh(&mh, bh);
 			}
 		} else {
 			if (dblock == ip->i_di.di_num.no_addr)
@@ -935,7 +935,7 @@ static void dir_split_leaf(struct gfs2_inode *dip, uint32_t lindex,
 		mh.mh_magic = GFS2_MAGIC;
 		mh.mh_type = GFS2_METATYPE_LF;
 		mh.mh_format = GFS2_FORMAT_LF;
-		gfs2_meta_header_out(&mh, nbh);
+		gfs2_meta_header_out_bh(&mh, nbh);
 		buffer_clear_tail(dip->i_sbd, nbh,
 				  sizeof(struct gfs2_meta_header));
 	}
@@ -1197,7 +1197,7 @@ restart:
 				mh.mh_magic = GFS2_MAGIC;
 				mh.mh_type = GFS2_METATYPE_LF;
 				mh.mh_format = GFS2_FORMAT_LF;
-				gfs2_meta_header_out(&mh, nbh);
+				gfs2_meta_header_out_bh(&mh, nbh);
 
 				leaf->lf_next = cpu_to_be64(bn);
 
@@ -1248,7 +1248,7 @@ static void dir_make_exhash(struct gfs2_inode *dip)
 		mh.mh_magic = GFS2_MAGIC;
 		mh.mh_type = GFS2_METATYPE_LF;
 		mh.mh_format = GFS2_FORMAT_LF;
-		gfs2_meta_header_out(&mh, bh);
+		gfs2_meta_header_out_bh(&mh, bh);
 	}
 
 	leaf = (struct gfs2_leaf *)bh->b_data;
@@ -1821,7 +1821,7 @@ void gfs2_free_block(struct gfs2_sbd *sdp, uint64_t block)
 		if (sdp->gfs1)
 			gfs_rgrp_out((struct gfs_rgrp *)&rgd->rg, rgd->bh[0]);
 		else
-			gfs2_rgrp_out(&rgd->rg, rgd->bh[0]);
+			gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[0]);
 		sdp->blks_alloced--;
 	}
 }
@@ -1892,7 +1892,7 @@ int gfs2_freedi(struct gfs2_sbd *sdp, uint64_t diblock)
 	if (sdp->gfs1)
 		gfs_rgrp_out((struct gfs_rgrp *)&rgd->rg, rgd->bh[0]);
 	else
-		gfs2_rgrp_out(&rgd->rg, rgd->bh[0]);
+		gfs2_rgrp_out_bh(&rgd->rg, rgd->bh[0]);
 	sdp->dinodes_alloced--;
 	return 0;
 }
diff --git a/gfs2/libgfs2/gfs1.c b/gfs2/libgfs2/gfs1.c
index 06fa98f..89fb898 100644
--- a/gfs2/libgfs2/gfs1.c
+++ b/gfs2/libgfs2/gfs1.c
@@ -126,7 +126,7 @@ void gfs1_block_map(struct gfs2_inode *ip, uint64_t lblock, int *new,
 			mh.mh_magic = GFS2_MAGIC;
 			mh.mh_type = GFS2_METATYPE_IN;
 			mh.mh_format = GFS2_FORMAT_IN;
-			gfs2_meta_header_out(&mh, bh);
+			gfs2_meta_header_out_bh(&mh, bh);
 		} else {
 			if (*dblock == ip->i_di.di_num.no_addr)
 				bh = ip->i_bh;
@@ -225,7 +225,7 @@ int gfs1_writei(struct gfs2_inode *ip, char *buf, uint64_t offset,
 			mh.mh_magic = GFS2_MAGIC;
 			mh.mh_type = GFS2_METATYPE_JD;
 			mh.mh_format = GFS2_FORMAT_JD;
-			gfs2_meta_header_out(&mh, bh);
+			gfs2_meta_header_out_bh(&mh, bh);
 		}
 
 		memcpy(bh->b_data + offset, buf + copied, amount);
@@ -381,7 +381,7 @@ void gfs_rgrp_out(struct gfs_rgrp *rgrp, struct gfs2_buffer_head *rbh)
 {
 	struct gfs_rgrp *str = (struct gfs_rgrp *)rbh->b_data;
 
-	gfs2_meta_header_out(&rgrp->rg_header, rbh);
+	gfs2_meta_header_out_bh(&rgrp->rg_header, rbh);
 	str->rg_flags = cpu_to_be32(rgrp->rg_flags);
 	str->rg_free = cpu_to_be32(rgrp->rg_free);
 	str->rg_useddi = cpu_to_be32(rgrp->rg_useddi);
diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index c415745..1475227 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -785,14 +785,16 @@ extern void gfs2_inum_in(struct gfs2_inum *no, char *buf);
 extern void gfs2_inum_out(struct gfs2_inum *no, char *buf);
 extern void gfs2_meta_header_in(struct gfs2_meta_header *mh,
 				struct gfs2_buffer_head *bh);
-extern void gfs2_meta_header_out(struct gfs2_meta_header *mh,
-				 struct gfs2_buffer_head *bh);
+extern void gfs2_meta_header_out(const struct gfs2_meta_header *mh, char *buf);
+extern void gfs2_meta_header_out_bh(const struct gfs2_meta_header *mh,
+                                    struct gfs2_buffer_head *bh);
 extern void gfs2_sb_in(struct gfs2_sb *sb, struct gfs2_buffer_head *bh);
 extern void gfs2_sb_out(struct gfs2_sb *sb, struct gfs2_buffer_head *bh);
 extern void gfs2_rindex_in(struct gfs2_rindex *ri, char *buf);
 extern void gfs2_rindex_out(struct gfs2_rindex *ri, char *buf);
 extern void gfs2_rgrp_in(struct gfs2_rgrp *rg, struct gfs2_buffer_head *bh);
-extern void gfs2_rgrp_out(struct gfs2_rgrp *rg, struct gfs2_buffer_head *bh);
+extern void gfs2_rgrp_out(const struct gfs2_rgrp *rg, char *buf);
+extern void gfs2_rgrp_out_bh(const struct gfs2_rgrp *rg, struct gfs2_buffer_head *bh);
 extern void gfs2_quota_in(struct gfs2_quota *qu, char *buf);
 extern void gfs2_quota_out(struct gfs2_quota *qu, char *buf);
 extern void gfs2_dinode_in(struct gfs2_dinode *di,
diff --git a/gfs2/libgfs2/ondisk.c b/gfs2/libgfs2/ondisk.c
index 301d92d..4baacc7 100644
--- a/gfs2/libgfs2/ondisk.c
+++ b/gfs2/libgfs2/ondisk.c
@@ -72,16 +72,21 @@ void gfs2_meta_header_in(struct gfs2_meta_header *mh,
 	CPIN_32(mh, str, mh_format);
 }
 
-void gfs2_meta_header_out(struct gfs2_meta_header *mh,
-			  struct gfs2_buffer_head *bh)
+void gfs2_meta_header_out(const struct gfs2_meta_header *mh, char *buf)
 {
-	struct gfs2_meta_header *str = (struct gfs2_meta_header *)bh->b_data;
+	struct gfs2_meta_header *str = (struct gfs2_meta_header *)buf;
 
 	CPOUT_32(mh, str, mh_magic);
 	CPOUT_32(mh, str, mh_type);
 	CPOUT_32(mh, str, mh_format);
 	str->__pad0 = 0;
 	str->__pad1 = 0;
+}
+
+void gfs2_meta_header_out_bh(const struct gfs2_meta_header *mh,
+                             struct gfs2_buffer_head *bh)
+{
+	gfs2_meta_header_out(mh, bh->iov.iov_base);
 	bmodified(bh);
 }
 
@@ -123,7 +128,7 @@ void gfs2_sb_out(struct gfs2_sb *sb, struct gfs2_buffer_head *bh)
 {
 	struct gfs2_sb *str = (struct gfs2_sb *)bh->b_data;
 
-	gfs2_meta_header_out(&sb->sb_header, bh);
+	gfs2_meta_header_out_bh(&sb->sb_header, bh);
 
 	CPOUT_32(sb, str, sb_fs_format);
 	CPOUT_32(sb, str, sb_multihost_format);
@@ -243,16 +248,21 @@ void gfs2_rgrp_in(struct gfs2_rgrp *rg, struct gfs2_buffer_head *bh)
 	CPIN_08(rg, str, rg_reserved, 80);
 }
 
-void gfs2_rgrp_out(struct gfs2_rgrp *rg, struct gfs2_buffer_head *bh)
+void gfs2_rgrp_out(const struct gfs2_rgrp *rg, char *buf)
 {
-	struct gfs2_rgrp *str = (struct gfs2_rgrp *)bh->b_data;
+	struct gfs2_rgrp *str = (struct gfs2_rgrp *)buf;
 
-	gfs2_meta_header_out(&rg->rg_header, bh);
+	gfs2_meta_header_out(&rg->rg_header, buf);
 	CPOUT_32(rg, str, rg_flags);
 	CPOUT_32(rg, str, rg_free);
 	CPOUT_32(rg, str, rg_dinodes);
 
 	CPOUT_08(rg, str, rg_reserved, 80);
+}
+
+void gfs2_rgrp_out_bh(const struct gfs2_rgrp *rg, struct gfs2_buffer_head *bh)
+{
+	gfs2_rgrp_out(rg, bh->iov.iov_base);
 	bmodified(bh);
 }
 
@@ -330,7 +340,7 @@ void gfs2_dinode_out(struct gfs2_dinode *di, struct gfs2_buffer_head *bh)
 {
 	struct gfs2_dinode *str = (struct gfs2_dinode *)bh->b_data;
 
-	gfs2_meta_header_out(&di->di_header, bh);
+	gfs2_meta_header_out_bh(&di->di_header, bh);
 	gfs2_inum_out(&di->di_num, (char *)&str->di_num);
 
 	CPOUT_32(di, str, di_mode);
@@ -432,7 +442,7 @@ void gfs2_leaf_out(struct gfs2_leaf *lf, struct gfs2_buffer_head *bh)
 {
 	struct gfs2_leaf *str = (struct gfs2_leaf *)bh->b_data;
 
-	gfs2_meta_header_out(&lf->lf_header, bh);
+	gfs2_meta_header_out_bh(&lf->lf_header, bh);
 	CPOUT_16(lf, str, lf_depth);
 	CPOUT_16(lf, str, lf_entries);
 	CPOUT_32(lf, str, lf_dirent_format);
@@ -497,7 +507,7 @@ void gfs2_log_header_out(struct gfs2_log_header *lh,
 {
 	struct gfs2_log_header *str = (struct gfs2_log_header *)bh->b_data;
 
-	gfs2_meta_header_out(&lh->lh_header, bh);
+	gfs2_meta_header_out_bh(&lh->lh_header, bh);
 	CPOUT_64(lh, str, lh_sequence);
 	CPOUT_32(lh, str, lh_flags);
 	CPOUT_32(lh, str, lh_tail);
@@ -535,7 +545,7 @@ void gfs2_log_descriptor_out(struct gfs2_log_descriptor *ld,
 {
 	struct gfs2_log_descriptor *str = (struct gfs2_log_descriptor *)bh->b_data;
 
-	gfs2_meta_header_out(&ld->ld_header, bh);
+	gfs2_meta_header_out_bh(&ld->ld_header, bh);
 	CPOUT_32(ld, str, ld_type);
 	CPOUT_32(ld, str, ld_length);
 	CPOUT_32(ld, str, ld_data1);
diff --git a/gfs2/libgfs2/structures.c b/gfs2/libgfs2/structures.c
index f9231ca..c60f3e4 100644
--- a/gfs2/libgfs2/structures.c
+++ b/gfs2/libgfs2/structures.c
@@ -256,7 +256,7 @@ static int build_quota_change(struct gfs2_inode *per_node, unsigned int j)
 			return -1;
 
 		memset(bh->b_data, 0, sdp->bsize);
-		gfs2_meta_header_out(&mh, bh);
+		gfs2_meta_header_out_bh(&mh, bh);
 		brelse(bh);
 	}
 
diff --git a/gfs2/mkfs/main_jadd.c b/gfs2/mkfs/main_jadd.c
index a4c6ca7..223dce7 100644
--- a/gfs2/mkfs/main_jadd.c
+++ b/gfs2/mkfs/main_jadd.c
@@ -342,7 +342,7 @@ add_qc(struct gfs2_sbd *sdp)
 		mh.mh_magic = GFS2_MAGIC;
 		mh.mh_type = GFS2_METATYPE_QC;
 		mh.mh_format = GFS2_FORMAT_QC;
-		gfs2_meta_header_out(&mh, &dummy_bh);
+		gfs2_meta_header_out_bh(&mh, &dummy_bh);
 
 		for (x=0; x<blocks; x++) {
 			if (write(fd, buf, sdp->bsize) != sdp->bsize) {
-- 
1.8.1.2

From anprice@redhat.com Tue Feb 26 09:04:34 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QE4YFi026433 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 09:04:34 -0500
Received: from rhlaptop.andrewprice.me.uk.com (ovpn-116-97.ams2.redhat.com
	[10.36.116.97])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QE4Sn1018988
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 09:04:33 -0500
From: Andrew Price <anprice@redhat.com>
To: cluster-devel@redhat.com
Date: Tue, 26 Feb 2013 14:04:24 +0000
Message-Id: <1361887466-20763-4-git-send-email-anprice@redhat.com>
In-Reply-To: <1361887466-20763-1-git-send-email-anprice@redhat.com>
References: <1361887466-20763-1-git-send-email-anprice@redhat.com>
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 3/5] mkfs.gfs2: Reduce memory usage
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 14:04:34 -0000

This folds much of the resource group allocation and writing into two
new functions so that we allocate memory for each entire header at once
and free it once we're done with it.

Testing on a 50TB volume with default options, this brings the peak heap
usage down from 3.03GB to 24MB while also reducing the run time
slightly due to fewer writes and allocations.

There are still memory efficiency gains to be made here, notably we
still use gfs2_compute_bitstructs which allocates bitmap buffers and an
array of bh pointers for each rgrp.

Signed-off-by: Andrew Price <anprice@redhat.com>
---
 gfs2/mkfs/main_mkfs.c | 110 ++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 94 insertions(+), 16 deletions(-)

diff --git a/gfs2/mkfs/main_mkfs.c b/gfs2/mkfs/main_mkfs.c
index 2ed17d2..b6aa5dd 100644
--- a/gfs2/mkfs/main_mkfs.c
+++ b/gfs2/mkfs/main_mkfs.c
@@ -567,6 +567,93 @@ static int is_symlink(char *path, char **abspath)
 	return 1;
 }
 
+static int writerg(int fd, const struct rgrp_tree *rgt, const unsigned bsize)
+{
+	ssize_t ret = 0;
+	unsigned int i;
+	const struct gfs2_meta_header bmh = {
+		.mh_magic = GFS2_MAGIC,
+		.mh_type = GFS2_METATYPE_RB,
+		.mh_format = GFS2_FORMAT_RB,
+	};
+	struct iovec iov = {
+		.iov_len = rgt->ri.ri_length * bsize,
+		.iov_base = calloc(rgt->ri.ri_length, bsize),
+	};
+	if (iov.iov_base == NULL)
+		return -1;
+
+	gfs2_rgrp_out(&rgt->rg, iov.iov_base);
+	for (i = 1; i < rgt->ri.ri_length; i++)
+		gfs2_meta_header_out(&bmh, (char *)iov.iov_base + (i * bsize));
+
+	ret = pwritev(fd, &iov, 1, rgt->ri.ri_addr * bsize);
+	if (ret != iov.iov_len) {
+		free(iov.iov_base);
+		return -1;
+	}
+
+	free(iov.iov_base);
+	return 0;
+}
+
+static int place_rgrps(struct gfs2_sbd *sdp, int rgsize_specified)
+{
+	struct rgrp_tree *rgt = NULL;
+	uint64_t rgaddr = 0;
+	unsigned int i = 0;
+	int err = 0;
+
+	sdp->device.length -= sdp->sb_addr + 1;
+	sdp->new_rgrps = how_many_rgrps(sdp, &sdp->device, rgsize_specified);
+	rgaddr = sdp->sb_addr + 1;
+
+	for (i = 0; i < sdp->new_rgrps; i++) {
+		/* TODO: align to RAID stripes, etc. */
+		rgt = rgrp_insert(&sdp->rgtree, rgaddr);
+		if (rgt == NULL)
+			return -1;
+		if (i == 0)
+			rgt->length = sdp->device.length - ((sdp->new_rgrps - 1) * (sdp->device.length / sdp->new_rgrps));
+		else
+			rgt->length = sdp->device.length / sdp->new_rgrps;
+
+		/* Build the rindex entry */
+		rgt->ri.ri_length = rgblocks2bitblocks(sdp->bsize, rgt->length, &rgt->ri.ri_data);
+		rgt->ri.ri_addr = rgaddr;
+		rgt->ri.ri_data0 = rgaddr + rgt->ri.ri_length;
+		rgt->ri.ri_bitbytes = rgt->ri.ri_data / GFS2_NBBY;
+
+		/* Build the rgrp header */
+		memset(&rgt->rg, 0, sizeof(rgt->rg));
+		rgt->rg.rg_header.mh_magic = GFS2_MAGIC;
+		rgt->rg.rg_header.mh_type = GFS2_METATYPE_RG;
+		rgt->rg.rg_header.mh_format = GFS2_FORMAT_RG;
+		rgt->rg.rg_free = rgt->ri.ri_data;
+
+		/* TODO: This call allocates buffer heads and bitmap pointers
+		 * in rgt. We really shouldn't need to do that. */
+		err = gfs2_compute_bitstructs(sdp, rgt);
+		if (err != 0) {
+			fprintf(stderr, _("Could not compute bitmaps. "
+			        "Check resource group and block size options.\n"));
+			return -1;
+		}
+
+		err = writerg(sdp->device_fd, rgt, sdp->bsize);
+		if (err != 0) {
+			perror(_("Failed to write resource group"));
+			return -1;
+		}
+		sdp->blks_total += rgt->ri.ri_data;
+		rgaddr += rgt->length;
+	}
+
+	sdp->rgrps = sdp->new_rgrps;
+	sdp->fssize = rgt->ri.ri_data0 + rgt->ri.ri_data;
+	return 0;
+}
+
 /**
  * main_mkfs - do everything
  * @argc:
@@ -668,20 +755,13 @@ void main_mkfs(int argc, char *argv[])
 	if (!S_ISREG(sdp->dinfo.stat.st_mode) && discard)
 		discard_blocks(sdp);
 
-	/* Compute the resource group layouts */
-
-	compute_rgrp_layout(sdp, &sdp->rgtree, rgsize_specified);
-	debug_print_rgrps(sdp, &sdp->rgtree);
-
-	/* Generate a random uuid */
-	get_random_bytes(uuid, sizeof(uuid));
-
-	/* Build ondisk structures */
-
-	build_rgrps(sdp, TRUE);
+	error = place_rgrps(sdp, rgsize_specified);
+	if (error) {
+		fprintf(stderr, _("Failed to build resource groups\n"));
+		exit(1);
+	}
 	build_root(sdp);
 	build_master(sdp);
-	build_sb(sdp, uuid);
 	error = build_jindex(sdp);
 	if (error) {
 		fprintf(stderr, _("Error building '%s': %s\n"), "jindex", strerror(errno));
@@ -714,12 +794,12 @@ void main_mkfs(int argc, char *argv[])
 		fprintf(stderr, _("Error building '%s': %s\n"), "quota", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
+	get_random_bytes(uuid, sizeof(uuid));
+	build_sb(sdp, uuid);
 
 	do_init_inum(sdp);
 	do_init_statfs(sdp);
 
-	/* Cleanup */
-
 	inode_put(&sdp->md.rooti);
 	inode_put(&sdp->master_dir);
 	inode_put(&sdp->md.inum);
@@ -727,14 +807,12 @@ void main_mkfs(int argc, char *argv[])
 
 	gfs2_rgrp_free(&sdp->rgtree);
 	error = fsync(sdp->device_fd);
-
 	if (error){
 		perror(sdp->device_name);
 		exit(EXIT_FAILURE);
 	}
 
 	error = close(sdp->device_fd);
-
 	if (error){
 		perror(sdp->device_name);
 		exit(EXIT_FAILURE);
-- 
1.8.1.2

From anprice@redhat.com Tue Feb 26 09:04:35 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QE4ZWk026444 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 09:04:35 -0500
Received: from rhlaptop.andrewprice.me.uk.com (ovpn-116-97.ams2.redhat.com
	[10.36.116.97])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QE4Sn2018988
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 09:04:34 -0500
From: Andrew Price <anprice@redhat.com>
To: cluster-devel@redhat.com
Date: Tue, 26 Feb 2013 14:04:25 +0000
Message-Id: <1361887466-20763-5-git-send-email-anprice@redhat.com>
In-Reply-To: <1361887466-20763-1-git-send-email-anprice@redhat.com>
References: <1361887466-20763-1-git-send-email-anprice@redhat.com>
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 4/5] gfs2-utils: Make the tool tests script
	more useful
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 14:04:35 -0000

This makes the tool test script log command output to a file and only
remove the test file (now named testvol by default) on success so that
we can analyze it on failure.

Also adds some tests to create and check file systems with various
resource group sizes.

Signed-off-by: Andrew Price <anprice@redhat.com>
---
 .gitignore          |  2 ++
 tests/tool_tests.sh | 28 +++++++++++++++++++---------
 2 files changed, 21 insertions(+), 9 deletions(-)

diff --git a/.gitignore b/.gitignore
index bd47927..a1eadd0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -41,6 +41,8 @@ gfs2/fsck/fsck.gfs2
 gfs2/mkfs/mkfs.gfs2
 gfs2/tune/tunegfs2
 tests/check_libgfs2
+tests/testvol
+tests/tests.log
 group/gfs_control/gfs_control
 group/gfs_controld/gfs_controld
 ABOUT-NLS
diff --git a/tests/tool_tests.sh b/tests/tool_tests.sh
index 791b071..50be31a 100755
--- a/tests/tool_tests.sh
+++ b/tests/tool_tests.sh
@@ -11,7 +11,10 @@ MKFS="${TOPBUILDDIR}/gfs2/mkfs/mkfs.gfs2 -qO"
 FSCK="${TOPBUILDDIR}/gfs2/fsck/fsck.gfs2 -qn"
 
 # Name of the sparse file we'll use for testing
-TEST_TARGET=${TEST_TARGET:-test_sparse}
+TEST_TARGET=${TEST_TARGET:-testvol}
+# Log of test output
+TEST_LOG=${TEST_LOG:-tests.log}
+truncate -cs0 "${TEST_LOG}"
 # Size, in GB, of the sparse file we'll create to run the tests
 TEST_TARGET_SZ=${TEST_TARGET_SZ:-10}
 [ $TEST_TARGET_SZ -gt 0 ] || { echo "Target size (in GB) must be greater than 0" >&2; exit 1; }
@@ -22,17 +25,17 @@ fn_test()
 {
 	local expected="$1"
 	local cmd="$2"
-	echo -n "Running '$cmd' - (Exp: $expected Got: "
-	$cmd &> /dev/null;
+	echo -n "** Test '$cmd'" | tee -a "${TEST_LOG}"
+	$cmd &>> "${TEST_LOG}";
 	local ret=$?
-	echo -n "$ret) "
+	echo -n " (exp: $expected got: $ret) " | tee -a "${TEST_LOG}"
 	if [ "$ret" != "$expected" ];
 	then
-		echo "FAIL"
+		echo "FAIL" | tee -a "${TEST_LOG}"
 		TEST_RET=1
 		TEST_GRP_RET=1
 	else
-		echo "PASS"
+		echo "PASS" | tee -a "${TEST_LOG}"
 	fi
 }
 
@@ -44,7 +47,7 @@ fn_rm_target()
 fn_recreate_target()
 {
 	fn_rm_target
-	fn_test 0 "dd if=/dev/null of=$TEST_TARGET bs=1 count=0 seek=${TEST_TARGET_SZ}G"
+	fn_test 0 "truncate -s ${TEST_TARGET_SZ}G ${TEST_TARGET}"
 }
 
 
@@ -54,9 +57,16 @@ fn_test 0 "$MKFS -p lock_nolock $TEST_TARGET"
 fn_test 0 "$MKFS -p lock_dlm -t foo:bar $TEST_TARGET"
 fn_test 255 "$MKFS -p badprotocol $TEST_TARGET"
 fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 255 "$MKFS -p lock_nolock -r 31 $TEST_TARGET"
+fn_test 255 "$MKFS -p lock_nolock -r 2049 $TEST_TARGET"
+fn_test 0 "$MKFS -p lock_nolock -r 32 $TEST_TARGET"
+fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 0 "$MKFS -p lock_nolock -r 2048 $TEST_TARGET"
+fn_test 0 "$FSCK $TEST_TARGET"
 
 # Tests end here
 
-# Clean up
-fn_test 0 "rm -f $TEST_TARGET"
+# Only remove the test file on success
+[ "$TEST_RET" = "0" ] && fn_test 0 "rm -f $TEST_TARGET"
+echo "Tool test output written to ${TEST_LOG}"
 exit $TEST_RET
-- 
1.8.1.2

From anprice@redhat.com Tue Feb 26 09:04:36 2013
Received: from int-mx09.intmail.prod.int.phx2.redhat.com
	(int-mx09.intmail.prod.int.phx2.redhat.com [10.5.11.22])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QE4aNA026454 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 09:04:36 -0500
Received: from rhlaptop.andrewprice.me.uk.com (ovpn-116-97.ams2.redhat.com
	[10.36.116.97])
	by int-mx09.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QE4Sn3018988
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO)
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 09:04:35 -0500
From: Andrew Price <anprice@redhat.com>
To: cluster-devel@redhat.com
Date: Tue, 26 Feb 2013 14:04:26 +0000
Message-Id: <1361887466-20763-6-git-send-email-anprice@redhat.com>
In-Reply-To: <1361887466-20763-1-git-send-email-anprice@redhat.com>
References: <1361887466-20763-1-git-send-email-anprice@redhat.com>
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.22
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH 5/5] mkfs.gfs2: Separate user options from
	file system params
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 14:04:36 -0000

Previously the user-supplied options were tangled up with the calculated
file system parameters in the gfs2_sbd. This patch adds a mkfs_opts
structure to create a separation between the two and rearranges the code
to make that separation more apparent. It also adds some more tool tests
to be run with 'make check' and removes the now-unneeded orig_fssize
field from the gfs2_sbd definition.

Signed-off-by: Andrew Price <anprice@redhat.com>
---
 gfs2/libgfs2/libgfs2.h |   1 -
 gfs2/mkfs/main_mkfs.c  | 493 ++++++++++++++++++++++---------------------------
 tests/tool_tests.sh    |  30 ++-
 3 files changed, 249 insertions(+), 275 deletions(-)

diff --git a/gfs2/libgfs2/libgfs2.h b/gfs2/libgfs2/libgfs2.h
index 1475227..b2457c4 100644
--- a/gfs2/libgfs2/libgfs2.h
+++ b/gfs2/libgfs2/libgfs2.h
@@ -295,7 +295,6 @@ struct gfs2_sbd {
 
 	uint64_t sb_addr;
 
-	uint64_t orig_fssize;
 	uint64_t fssize;
 	uint64_t blks_total;
 	uint64_t blks_alloced;
diff --git a/gfs2/mkfs/main_mkfs.c b/gfs2/mkfs/main_mkfs.c
index b6aa5dd..610a641 100644
--- a/gfs2/mkfs/main_mkfs.c
+++ b/gfs2/mkfs/main_mkfs.c
@@ -26,8 +26,6 @@
 #include "libgfs2.h"
 #include "gfs2_mkfs.h"
 
-int discard = 1;
-
 /**
  * This function is for libgfs2's sake.
  */
@@ -41,13 +39,7 @@ void print_it(const char *label, const char *fmt, const char *fmt2, ...)
 	va_end(args);
 }
 
-/**
- * print_usage - print out usage information
- * @prog_name: The name of this program
- */
-
-static void
-print_usage(const char *prog_name)
+static void print_usage(const char *prog_name)
 {
 	int i;
 	const char *option, *param, *desc;
@@ -85,178 +77,157 @@ print_usage(const char *prog_name)
 	}
 }
 
+struct mkfs_opts {
+	unsigned bsize;
+	unsigned qcsize;
+	unsigned jsize;
+	unsigned rgsize;
+	uint64_t fssize;
+	uint32_t journals;
+	const char *lockproto;
+	const char *locktable;
+	const char *device;
+	unsigned discard:1;
+
+	unsigned got_bsize:1;
+	unsigned got_qcsize:1;
+	unsigned got_jsize:1;
+	unsigned got_rgsize:1;
+	unsigned got_fssize:1;
+	unsigned got_journals:1;
+	unsigned got_lockproto:1;
+	unsigned got_locktable:1;
+	unsigned got_device:1;
+
+	unsigned override:1;
+	unsigned quiet:1;
+	unsigned expert:1;
+	unsigned debug:1;
+	unsigned confirm:1;
+};
+
+static void opts_init(struct mkfs_opts *opts)
+{
+	memset(opts, 0, sizeof(*opts));
+	opts->discard = 1;
+	opts->journals = 1;
+	opts->bsize = GFS2_DEFAULT_BSIZE;
+	opts->jsize = GFS2_DEFAULT_JSIZE;
+	opts->qcsize = GFS2_DEFAULT_QCSIZE;
+	opts->rgsize = GFS2_DEFAULT_RGSIZE;
+	opts->lockproto = "lock_dlm";
+	opts->locktable = "";
+}
+
 #ifndef BLKDISCARD
 #define BLKDISCARD      _IO(0x12,119)
 #endif
 
-static int discard_blocks(struct gfs2_sbd *sdp)
+static int discard_blocks(int fd, uint64_t len, int debug)
 {
         __uint64_t range[2];
 
 	range[0] = 0;
-	range[1] = sdp->device.length * sdp->bsize;
-	if (sdp->debug)
+	range[1] = len;
+	if (debug)
 		/* Translators: "discard" is a request sent to a storage device to
 		 * discard a range of blocks. */
 		printf(_("Issuing discard request: range: %llu - %llu..."),
 		       (unsigned long long)range[0],
 		       (unsigned long long)range[1]);
-	if (ioctl(sdp->device_fd, BLKDISCARD, &range) < 0) {
-		if (sdp->debug)
+	if (ioctl(fd, BLKDISCARD, &range) < 0) {
+		if (debug)
 			printf("%s = %d\n", _("error"), errno);
 		return errno;
 	}
-	if (sdp->debug)
+	if (debug)
 		printf(_("Successful.\n"));
         return 0;
 }
 
-/**
- * decode_arguments - decode command line arguments and fill in the struct gfs2_sbd
- * @argc:
- * @argv:
- * @sdp: the decoded command line arguments
- *
- */
-
-static void decode_arguments(int argc, char *argv[], struct gfs2_sbd *sdp)
+static void opts_get(int argc, char *argv[], struct mkfs_opts *opts)
 {
-	int cont = TRUE;
-	int optchar;
-
-	memset(sdp->device_name, 0, sizeof(sdp->device_name));
-	sdp->md.journals = 1;
-	sdp->orig_fssize = 0;
-
-	while (cont) {
-		optchar = getopt(argc, argv, "-b:c:DhJ:j:KOp:qr:t:VX");
+	int c;
+	while (1) {
+		c = getopt(argc, argv, "-b:c:DhJ:j:KOp:qr:t:VX");
+		if (c == -1)
+			break;
 
-		switch (optchar) {
+		switch (c) {
 		case 'b':
-			sdp->bsize = atoi(optarg);
+			opts->bsize = atoi(optarg);
+			opts->got_bsize = 1;
 			break;
-
 		case 'c':
-			sdp->qcsize = atoi(optarg);
+			opts->qcsize = atoi(optarg);
+			opts->got_qcsize = 1;
 			break;
-
 		case 'D':
-			sdp->debug = TRUE;
+			opts->debug = 1;
 			break;
-
 		case 'h':
 			print_usage(argv[0]);
 			exit(0);
-			break;
-
 		case 'J':
-			sdp->jsize = atoi(optarg);
+			opts->jsize = atoi(optarg);
+			opts->got_jsize = 1;
 			break;
-
 		case 'j':
-			sdp->md.journals = atoi(optarg);
+			opts->journals = atoi(optarg);
+			opts->got_journals = 1;
 			break;
-
 		case 'K':
-			discard = 0;
+			opts->discard = 0;
 			break;
-
 		case 'O':
-			sdp->override = TRUE;
+			opts->override = 1;
 			break;
-
 		case 'p':
-			if (strlen(optarg) >= GFS2_LOCKNAME_LEN)
-				die( _("lock protocol name '%s' is too long\n"),
-				    optarg);
-			strcpy(sdp->lockproto, optarg);
+			opts->lockproto = optarg;
+			opts->got_lockproto = 1;
+			break;
+		case 't':
+			opts->locktable = optarg;
+			opts->got_locktable = 1;
 			break;
-
 		case 'q':
-			sdp->quiet = TRUE;
+			opts->quiet = 1;
 			break;
-
 		case 'r':
-			sdp->rgsize = atoi(optarg);
-			break;
-
-		case 't':
-			if (strlen(optarg) >= GFS2_LOCKNAME_LEN)
-				die( _("lock table name '%s' is too long\n"), optarg);
-			strcpy(sdp->locktable, optarg);
+			opts->rgsize = atoi(optarg);
+			opts->got_rgsize = 1;
 			break;
-
 		case 'V':
 			printf("mkfs.gfs2 %s (built %s %s)\n", VERSION,
 			       __DATE__, __TIME__);
 			printf(REDHAT_COPYRIGHT "\n");
 			exit(EXIT_SUCCESS);
 			break;
-
 		case 'X':
-			sdp->expert = TRUE;
+			opts->expert = 1;
 			break;
-
 		case ':':
 		case '?':
 			fprintf(stderr, _("Please use '-h' for help.\n"));
 			exit(EXIT_FAILURE);
 			break;
-
-		case EOF:
-			cont = FALSE;
-			break;
-
 		case 1:
 			if (strcmp(optarg, "gfs2") == 0)
 				continue;
-			if (!sdp->device_name[0])
-				strcpy(sdp->device_name, optarg);
-			else if (!sdp->orig_fssize &&
-				 isdigit(optarg[0]))
-				sdp->orig_fssize = atol(optarg);
-			else
+			if (!opts->got_device) {
+				opts->device = optarg;
+				opts->got_device = 1;
+			} else if (!opts->got_fssize && isdigit(optarg[0])) {
+				opts->fssize = atol(optarg);
+				opts->got_fssize = 1;
+			} else
 				die( _("More than one device specified (try -h for help)\n"));
 			break;
-
 		default:
-			die( _("Invalid option: %c\n"), optchar);
+			die( _("Invalid option: %c\n"), c);
 			break;
 		};
 	}
-
-	if ((sdp->device_name[0] == 0) && (optind < argc))
-		strcpy(sdp->device_name, argv[optind++]);
-
-	if (sdp->device_name[0] == '\0')
-		die( _("No device specified. Please use '-h' for help.\n"));
-
-	if (optind < argc)
-		sdp->orig_fssize = atol(argv[optind++]);
-
-	if (optind < argc)
-		die( _("Unrecognized argument: %s\n"), argv[optind]);
-
-	if (sdp->debug) {
-		printf( _("Command Line Arguments:\n"));
-		if (sdp->bsize != -1)
-			printf("  bsize = %u\n", sdp->bsize);
-		printf("  qcsize = %u\n", sdp->qcsize);
-		printf("  jsize = %u\n", sdp->jsize);
-		printf("  journals = %u\n", sdp->md.journals);
-		printf("  override = %d\n", sdp->override);
-		printf("  proto = %s\n", sdp->lockproto);
-		printf("  quiet = %d\n", sdp->quiet);
-		if (sdp->rgsize == (unsigned int)-1)
-			printf("  rgsize = %s\n", _("Optimize for best performance"));
-		else
-			printf("  rgsize = %u\n", sdp->rgsize);
-		printf("  table = %s\n", sdp->locktable);
-		printf("  device = %s\n", sdp->device_name);
-		if (sdp->orig_fssize)
-			printf("  block-count = %llu\n",
-			       (unsigned long long)sdp->orig_fssize);
-	}
 }
 
 /**
@@ -266,9 +237,9 @@ static void decode_arguments(int argc, char *argv[], struct gfs2_sbd *sdp)
  *
  */
 
-static void test_locking(char *lockproto, char *locktable)
+static void test_locking(const char *lockproto, const char *locktable)
 {
-	char *c;
+	const char *c;
 	/* Translators: A lock table is a string identifying a gfs2 file system
 	 * in a cluster, e.g. cluster_name:fs_name */
 	const char *errprefix = _("Invalid lock table:");
@@ -307,12 +278,6 @@ static void test_locking(char *lockproto, char *locktable)
 	}
 }
 
-/**
- * are_you_sure - protect lusers from themselves
- * @sdp: the command line
- *
- */
-
 static void are_you_sure(void)
 {
 	char *line = NULL;
@@ -345,59 +310,73 @@ static void are_you_sure(void)
 		free(line);
 }
 
-static void verify_bsize(struct gfs2_sbd *sdp)
+static unsigned choose_blocksize(struct mkfs_opts *opts, struct lgfs2_dev_info *dinfo)
 {
 	unsigned int x;
+	unsigned int bsize = opts->bsize;
 
-	/* Block sizes must be a power of two from 512 to 65536 */
+	if (!opts->got_bsize) {
+		if (S_ISREG(dinfo->stat.st_mode))
+			bsize = GFS2_DEFAULT_BSIZE;
+		/* See if optimal_io_size (the biggest I/O we can submit
+		   without incurring a penalty) is a suitable block size. */
+		else if (dinfo->io_optimal_size <= getpagesize() && dinfo->io_optimal_size >= dinfo->io_min_size)
+			bsize = dinfo->io_optimal_size;
+		/* See if physical_block_size (the smallest unit we can write
+		   without incurring read-modify-write penalty) is suitable. */
+		else if (dinfo->physical_block_size <= getpagesize() && dinfo->physical_block_size >= GFS2_DEFAULT_BSIZE)
+			bsize = dinfo->physical_block_size;
+		else
+			bsize = GFS2_DEFAULT_BSIZE;
 
+	}
+
+	/* Block sizes must be a power of two from 512 to 65536 */
 	for (x = 512; x; x <<= 1)
-		if (x == sdp->bsize)
+		if (x == bsize)
 			break;
 
-	if (!x || sdp->bsize > getpagesize())
+	if (!x || bsize > getpagesize())
 		die( _("Block size must be a power of two between 512 and %d\n"),
 		       getpagesize());
 
-	if (sdp->bsize < sdp->dinfo.logical_block_size) {
+	if (bsize < dinfo->logical_block_size) {
 		die( _("Error: Block size %d is less than minimum logical "
-		       "block size (%d).\n"), sdp->bsize,
-		     sdp->dinfo.logical_block_size);
+		       "block size (%d).\n"), bsize, dinfo->logical_block_size);
 	}
 
-	if (sdp->bsize < sdp->dinfo.physical_block_size) {
-		printf( _("WARNING: Block size %d is inefficient because it "
+	if (bsize < dinfo->physical_block_size) {
+		printf( _("Warning: Block size %d is inefficient because it "
 			  "is less than the physical block size (%d).\n"),
-			  sdp->bsize, sdp->dinfo.physical_block_size);
-		if (sdp->override)
-			return;
-
-		are_you_sure();
+			  bsize, dinfo->physical_block_size);
+		opts->confirm = 1;
 	}
+	return bsize;
 }
 
-static void verify_arguments(struct gfs2_sbd *sdp)
+static void opts_check(struct mkfs_opts *opts)
 {
-	if (!sdp->expert)
-		test_locking(sdp->lockproto, sdp->locktable);
-	if (sdp->expert) {
-		if (GFS2_EXP_MIN_RGSIZE > sdp->rgsize || sdp->rgsize > GFS2_MAX_RGSIZE)
+	if (!opts->expert)
+		test_locking(opts->lockproto, opts->locktable);
+	if (opts->expert) {
+		if (GFS2_EXP_MIN_RGSIZE > opts->rgsize || opts->rgsize > GFS2_MAX_RGSIZE)
 			/* Translators: gfs2 file systems are split into equal sized chunks called
 			   resource groups. We're checking that the user gave a valid size for them. */
 			die( _("bad resource group size\n"));
 	} else {
-		if (GFS2_MIN_RGSIZE > sdp->rgsize || sdp->rgsize > GFS2_MAX_RGSIZE)
+		if (GFS2_MIN_RGSIZE > opts->rgsize || opts->rgsize > GFS2_MAX_RGSIZE)
 			die( _("bad resource group size\n"));
 	}
 
-	if (!sdp->md.journals)
+	if (!opts->journals)
 		die( _("no journals specified\n"));
 
-	if (sdp->jsize < 8 || sdp->jsize > 1024)
+	if (opts->jsize < 8 || opts->jsize > 1024)
 		die( _("bad journal size\n"));
 
-	if (!sdp->qcsize || sdp->qcsize > 64)
+	if (!opts->qcsize || opts->qcsize > 64)
 		die( _("bad quota change size\n"));
+
 }
 
 static int get_file_output(int fd, char *buffer, size_t buflen)
@@ -499,27 +478,10 @@ fail:
 	exit(execv(args[0], args));
 }
 
-
-/**
- * print_results - print out summary information
- * @sdp: the command line
- *
- */
-
-static void
-print_results(struct gfs2_sbd *sdp, uint64_t real_device_size,
-	      unsigned char uuid[16])
+static void print_results(struct gfs2_sbd *sdp, uint64_t real_device_size,
+                          struct mkfs_opts *opts, unsigned char uuid[16])
 {
-	if (sdp->debug)
-		printf("\n");
-	else if (sdp->quiet)
-		return;
-
-	if (sdp->expert)
-		printf("%-27s%s\n", _("Expert mode:"), _("on"));
-
-	printf("%-27s%s\n", _("Device:"), sdp->device_name);
-
+	printf("%-27s%s\n", _("Device:"), opts->device);
 	printf("%-27s%u\n", _("Block size:"), sdp->bsize);
 	printf("%-27s%.2f %s (%llu %s)\n", _("Device size:"),
 	       /* Translators: "GB" here means "gigabytes" */
@@ -533,11 +495,11 @@ print_results(struct gfs2_sbd *sdp, uint64_t real_device_size,
 	printf("%-27s\"%s\"\n", _("Locking protocol:"), sdp->lockproto);
 	printf("%-27s\"%s\"\n", _("Lock table:"), sdp->locktable);
 
-	if (sdp->debug) {
-		printf("\n%-27s%u\n", _("Writes:"), sdp->writes);
+	if (opts->debug) {
+		printf("%-27s%u\n", _("Writes:"), sdp->writes);
 	}
 	/* Translators: "UUID" = universally unique identifier. */
-	printf("%-27s%s\n\n", _("UUID:"), str_uuid(uuid));
+	printf("%-27s%s\n", _("UUID:"), str_uuid(uuid));
 }
 
 
@@ -546,7 +508,7 @@ print_results(struct gfs2_sbd *sdp, uint64_t real_device_size,
  * otherwise return 0. Exit on errors. The caller must free the memory pointed
  * to by *abspath.
  */
-static int is_symlink(char *path, char **abspath)
+static int is_symlink(const char *path, char **abspath)
 {
 	struct stat lnkstat;
 
@@ -597,7 +559,7 @@ static int writerg(int fd, const struct rgrp_tree *rgt, const unsigned bsize)
 	return 0;
 }
 
-static int place_rgrps(struct gfs2_sbd *sdp, int rgsize_specified)
+static int place_rgrps(struct gfs2_sbd *sdp, const struct mkfs_opts *opts)
 {
 	struct rgrp_tree *rgt = NULL;
 	uint64_t rgaddr = 0;
@@ -605,7 +567,7 @@ static int place_rgrps(struct gfs2_sbd *sdp, int rgsize_specified)
 	int err = 0;
 
 	sdp->device.length -= sdp->sb_addr + 1;
-	sdp->new_rgrps = how_many_rgrps(sdp, &sdp->device, rgsize_specified);
+	sdp->new_rgrps = how_many_rgrps(sdp, &sdp->device, opts->got_rgsize);
 	rgaddr = sdp->sb_addr + 1;
 
 	for (i = 0; i < sdp->new_rgrps; i++) {
@@ -654,169 +616,160 @@ static int place_rgrps(struct gfs2_sbd *sdp, int rgsize_specified)
 	return 0;
 }
 
-/**
- * main_mkfs - do everything
- * @argc:
- * @argv:
- *
- */
+static void sbd_init(struct gfs2_sbd *sdp, struct mkfs_opts *opts, struct lgfs2_dev_info *dinfo, int fd)
+{
+	memset(sdp, 0, sizeof(struct gfs2_sbd));
+	sdp->time = time(NULL);
+	sdp->rgtree.osi_node = NULL;
+	sdp->rgsize = opts->rgsize;
+	sdp->qcsize = opts->qcsize;
+	sdp->jsize = opts->jsize;
+	sdp->md.journals = opts->journals;
+	sdp->device_fd = fd;
+	sdp->bsize = choose_blocksize(opts, dinfo);
+
+	if (compute_constants(sdp)) {
+		perror(_("Failed to compute file system constants"));
+		exit(1);
+	}
+	sdp->device.length = dinfo->size / sdp->bsize;
+	if (opts->got_fssize) {
+		if (opts->fssize > sdp->device.length) {
+			fprintf(stderr, _("Specified size is bigger than the device."));
+			die("%s %.2f %s (%llu %s)\n", _("Device size:"),
+			       dinfo->size / ((float)(1 << 30)), _("GB"),
+			       (unsigned long long)dinfo->size / sdp->bsize, _("blocks"));
+		}
+		/* TODO: Check if the fssize is too small, somehow */
+		sdp->device.length = opts->fssize;
+	}
+	strcpy(sdp->lockproto, opts->lockproto);
+	strcpy(sdp->locktable, opts->locktable);
+	if (opts->debug) {
+		printf(_("Calculated file system options:\n"));
+		printf("  bsize = %u\n", sdp->bsize);
+		printf("  qcsize = %u\n", sdp->qcsize);
+		printf("  jsize = %u\n", sdp->jsize);
+		printf("  journals = %u\n", sdp->md.journals);
+		printf("  proto = %s\n", sdp->lockproto);
+		printf("  rgsize = %u\n", sdp->rgsize);
+		printf("  table = %s\n", sdp->locktable);
+		printf("  fssize = %"PRIu64"\n", opts->fssize);
+	}
+}
+
 void main_mkfs(int argc, char *argv[])
 {
-	struct gfs2_sbd sbd, *sdp = &sbd;
+	struct gfs2_sbd sbd;
+	struct mkfs_opts opts;
+	struct lgfs2_dev_info dinfo;
 	int error;
-	int rgsize_specified = 0;
 	unsigned char uuid[16];
 	char *absname = NULL;
 	char *fdpath = NULL;
 	int islnk = 0;
+	int fd;
 
-	memset(sdp, 0, sizeof(struct gfs2_sbd));
-	sdp->bsize = -1;
-	sdp->jsize = GFS2_DEFAULT_JSIZE;
-	sdp->rgsize = -1;
-	sdp->qcsize = GFS2_DEFAULT_QCSIZE;
-	strcpy(sdp->lockproto, GFS2_DEFAULT_LOCKPROTO);
-	sdp->time = time(NULL);
-	sdp->rgtree.osi_node = NULL;
-
-	decode_arguments(argc, argv, sdp);
-	if (sdp->rgsize == -1)                 /* if rg size not specified */
-		sdp->rgsize = GFS2_DEFAULT_RGSIZE; /* default it for now */
-	else
-		rgsize_specified = TRUE;
-
-	verify_arguments(sdp);
+	opts_init(&opts);
+	opts_get(argc, argv, &opts);
 
-	sdp->device_fd = open(sdp->device_name, O_RDWR | O_CLOEXEC);
-	if (sdp->device_fd < 0){
-		perror(sdp->device_name);
+	fd = open(opts.device, O_RDWR | O_CLOEXEC);
+	if (fd < 0){
+		perror(opts.device);
 		exit(EXIT_FAILURE);
 	}
 
-	if (lgfs2_get_dev_info(sdp->device_fd, &sdp->dinfo) < 0) {
-		perror(sdp->device_name);
+	if (lgfs2_get_dev_info(fd, &dinfo) < 0) {
+		perror(opts.device);
 		exit(EXIT_FAILURE);
 	}
 
-	if (asprintf(&fdpath, "/proc/%d/fd/%d", getpid(), sdp->device_fd) < 0) {
+	opts_check(&opts);
+	sbd_init(&sbd, &opts, &dinfo, fd);
+
+	if (asprintf(&fdpath, "/proc/%d/fd/%d", getpid(), fd) < 0) {
 		perror(_("Failed to build string"));
 		exit(EXIT_FAILURE);
 	}
 
-	if (!sdp->override) {
-		islnk = is_symlink(sdp->device_name, &absname);
-		printf(_("This will destroy any data on %s.\n"), islnk ? absname : sdp->device_name);
+	if (!opts.override) {
+		islnk = is_symlink(opts.device, &absname);
+		printf(_("This will destroy any data on %s.\n"), islnk ? absname : opts.device);
 		free(absname);
 		check_dev_content(fdpath);
-		are_you_sure();
+		opts.confirm = 1;
 	}
 	free(fdpath);
 
-	if (sdp->bsize == -1) {
-		if (S_ISREG(sdp->dinfo.stat.st_mode))
-			sdp->bsize = GFS2_DEFAULT_BSIZE;
-		/* See if optimal_io_size (the biggest I/O we can submit
-		   without incurring a penalty) is a suitable block size. */
-		else if (sdp->dinfo.io_optimal_size <= getpagesize() &&
-		    sdp->dinfo.io_optimal_size >= sdp->dinfo.io_min_size)
-			sdp->bsize = sdp->dinfo.io_optimal_size;
-		/* See if physical_block_size (the smallest unit we can write
-		   without incurring read-modify-write penalty) is suitable. */
-		else if (sdp->dinfo.physical_block_size <= getpagesize() &&
-			 sdp->dinfo.physical_block_size >= GFS2_DEFAULT_BSIZE)
-			sdp->bsize = sdp->dinfo.physical_block_size;
-		else
-			sdp->bsize = GFS2_DEFAULT_BSIZE;
-
-		if (sdp->debug)
-			printf("\n%s %u\n", _("Using block size:"), sdp->bsize);
-	}
-	verify_bsize(sdp);
-
-	if (compute_constants(sdp)) {
-		perror(_("Failed to compute file system constants"));
-		exit(EXIT_FAILURE);
-	}
+	if (opts.confirm && !opts.override)
+		are_you_sure();
 
-	/* Convert optional block-count to basic blocks */
-	if (sdp->orig_fssize) {
-		sdp->orig_fssize *= sdp->bsize;
-		sdp->orig_fssize >>= GFS2_BASIC_BLOCK_SHIFT;
-		if (sdp->orig_fssize > sdp->device.length) {
-			fprintf(stderr, "%s:%s\n", argv[0],
-			        _("Specified size is bigger than the device."));
-			die("%s %.2f %s (%llu %s)\n", _("Device size:"),
-			       sdp->dinfo.size / ((float)(1 << 30)), _("GB"),
-			       (unsigned long long)sdp->dinfo.size / sdp->bsize, _("blocks"));
-		}
-		sdp->device.length = sdp->orig_fssize;
-	}
-	fix_device_geometry(sdp);
-	if (!S_ISREG(sdp->dinfo.stat.st_mode) && discard)
-		discard_blocks(sdp);
+	if (!S_ISREG(dinfo.stat.st_mode) && opts.discard)
+		discard_blocks(fd, sbd.bsize * sbd.device.length, opts.debug);
 
-	error = place_rgrps(sdp, rgsize_specified);
+	error = place_rgrps(&sbd, &opts);
 	if (error) {
 		fprintf(stderr, _("Failed to build resource groups\n"));
 		exit(1);
 	}
-	build_root(sdp);
-	build_master(sdp);
-	error = build_jindex(sdp);
+	build_root(&sbd);
+	build_master(&sbd);
+	error = build_jindex(&sbd);
 	if (error) {
 		fprintf(stderr, _("Error building '%s': %s\n"), "jindex", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
-	error = build_per_node(sdp);
+	error = build_per_node(&sbd);
 	if (error) {
 		fprintf(stderr, _("Error building '%s': %s\n"), "per_node", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
-	error = build_inum(sdp);
+	error = build_inum(&sbd);
 	if (error) {
 		fprintf(stderr, _("Error building '%s': %s\n"), "inum", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
-	gfs2_lookupi(sdp->master_dir, "inum", 4, &sdp->md.inum);
-	error = build_statfs(sdp);
+	gfs2_lookupi(sbd.master_dir, "inum", 4, &sbd.md.inum);
+	error = build_statfs(&sbd);
 	if (error) {
 		fprintf(stderr, _("Error building '%s': %s\n"), "statfs", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
-	gfs2_lookupi(sdp->master_dir, "statfs", 6, &sdp->md.statfs);
-	error = build_rindex(sdp);
+	gfs2_lookupi(sbd.master_dir, "statfs", 6, &sbd.md.statfs);
+	error = build_rindex(&sbd);
 	if (error) {
 		fprintf(stderr, _("Error building '%s': %s\n"), "rindex", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
-	error = build_quota(sdp);
+	error = build_quota(&sbd);
 	if (error) {
 		fprintf(stderr, _("Error building '%s': %s\n"), "quota", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
 	get_random_bytes(uuid, sizeof(uuid));
-	build_sb(sdp, uuid);
+	build_sb(&sbd, uuid);
 
-	do_init_inum(sdp);
-	do_init_statfs(sdp);
+	do_init_inum(&sbd);
+	do_init_statfs(&sbd);
 
-	inode_put(&sdp->md.rooti);
-	inode_put(&sdp->master_dir);
-	inode_put(&sdp->md.inum);
-	inode_put(&sdp->md.statfs);
+	inode_put(&sbd.md.rooti);
+	inode_put(&sbd.master_dir);
+	inode_put(&sbd.md.inum);
+	inode_put(&sbd.md.statfs);
 
-	gfs2_rgrp_free(&sdp->rgtree);
-	error = fsync(sdp->device_fd);
+	gfs2_rgrp_free(&sbd.rgtree);
+	error = fsync(fd);
 	if (error){
-		perror(sdp->device_name);
+		perror(opts.device);
 		exit(EXIT_FAILURE);
 	}
 
-	error = close(sdp->device_fd);
+	error = close(fd);
 	if (error){
-		perror(sdp->device_name);
+		perror(opts.device);
 		exit(EXIT_FAILURE);
 	}
 
-	print_results(sdp, sdp->dinfo.size, uuid);
+	if (!opts.quiet)
+		print_results(&sbd, dinfo.size, &opts, uuid);
 }
diff --git a/tests/tool_tests.sh b/tests/tool_tests.sh
index 50be31a..7b9a5c3 100755
--- a/tests/tool_tests.sh
+++ b/tests/tool_tests.sh
@@ -5,10 +5,10 @@
 # of the whole script will be non-zero but the tests will continue to be run. The
 # sparse file which is used as the target of the tests can be configured by
 # setting the environment variables TEST_TARGET (the filename) and TEST_TARGET_SZ
-# (its apparent size in gigabytes). Defaults to "test_sparse" and 10GB.
+# (its apparent size in gigabytes). Defaults to "testvol" and 10GB.
 
-MKFS="${TOPBUILDDIR}/gfs2/mkfs/mkfs.gfs2 -qO"
-FSCK="${TOPBUILDDIR}/gfs2/fsck/fsck.gfs2 -qn"
+MKFS="${TOPBUILDDIR}/gfs2/mkfs/mkfs.gfs2 -O"
+FSCK="${TOPBUILDDIR}/gfs2/fsck/fsck.gfs2 -n"
 
 # Name of the sparse file we'll use for testing
 TEST_TARGET=${TEST_TARGET:-testvol}
@@ -50,19 +50,41 @@ fn_recreate_target()
 	fn_test 0 "truncate -s ${TEST_TARGET_SZ}G ${TEST_TARGET}"
 }
 
+util_max_blocks()
+{
+	printf $((TEST_TARGET_SZ*1073741824/$1))
+}
 
 # Tests start here
 fn_recreate_target
 fn_test 0 "$MKFS -p lock_nolock $TEST_TARGET"
 fn_test 0 "$MKFS -p lock_dlm -t foo:bar $TEST_TARGET"
-fn_test 255 "$MKFS -p badprotocol $TEST_TARGET"
 fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 255 "$MKFS -p badprotocol $TEST_TARGET"
 fn_test 255 "$MKFS -p lock_nolock -r 31 $TEST_TARGET"
 fn_test 255 "$MKFS -p lock_nolock -r 2049 $TEST_TARGET"
 fn_test 0 "$MKFS -p lock_nolock -r 32 $TEST_TARGET"
 fn_test 0 "$FSCK $TEST_TARGET"
 fn_test 0 "$MKFS -p lock_nolock -r 2048 $TEST_TARGET"
 fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 255 "$MKFS -p lock_nolock -b 512 $TEST_TARGET $(($(util_max_blocks 512)+1))"
+fn_test 255 "$MKFS -p lock_nolock -b 4096 $TEST_TARGET $(($(util_max_blocks 4096)+1))"
+fn_test 0 "$MKFS -p lock_nolock -b 512 $TEST_TARGET $(util_max_blocks 512)"
+fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 0 "$MKFS -p lock_nolock -b 4096 $TEST_TARGET $(util_max_blocks 4096)"
+fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 255 "$MKFS -p lock_nolock -J 7 $TEST_TARGET"
+fn_test 255 "$MKFS -p lock_nolock -J 1025 $TEST_TARGET"
+fn_test 0 "$MKFS -p lock_nolock -J 1024 $TEST_TARGET"
+fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 0 "$MKFS -p lock_nolock -J 8 $TEST_TARGET"
+fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 255 "$MKFS -p lock_nolock -c 0 $TEST_TARGET"
+fn_test 255 "$MKFS -p lock_nolock -c 65 $TEST_TARGET"
+fn_test 0 "$MKFS -p lock_nolock -c 1 $TEST_TARGET"
+fn_test 0 "$FSCK $TEST_TARGET"
+fn_test 0 "$MKFS -p lock_nolock -c 64 $TEST_TARGET"
+fn_test 0 "$FSCK $TEST_TARGET"
 
 # Tests end here
 
-- 
1.8.1.2

From rmccabe@redhat.com Tue Feb 26 11:50:48 2013
Received: from int-mx01.intmail.prod.int.phx2.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QGeu7e025629 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 11:41:29 -0500
Received: from redhat.com (vpn-52-226.rdu2.redhat.com [10.10.52.226])
	by int-mx01.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QGesJL021770
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES128-SHA bits=128 verify=NO);
	Tue, 26 Feb 2013 11:40:55 -0500
Date: Tue, 26 Feb 2013 11:40:53 -0500
From: Ryan McCabe <rmccabe@redhat.com>
To: cluster-devel@redhat.com
Message-ID: <20130226164051.GA467810@redhat.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.21 (2010-09-15)
X-Scanned-By: MIMEDefang 2.67 on 10.5.11.11
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] [PATCH] rgmanager: Don't duplicate configuration
	change events
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 16:50:49 -0000

If a cluster configuration change is detected while there are events
on the event queue that take some time to process, a large number of
duplicate configuration update events are put onto the event queue.
With a large number of services and a small status poll interval,
thousands of duplicate events can be put onto the queue.

This patch causes rgmanager to queue only one config event per detected
configuration change.

This applies only to the RHEL5 branch.

Signed-off-by: Ryan McCabe <rmccabe@redhat.com>
---
 rgmanager/src/daemons/main.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/rgmanager/src/daemons/main.c b/rgmanager/src/daemons/main.c
index 1c7f746..59150c3 100644
--- a/rgmanager/src/daemons/main.c
+++ b/rgmanager/src/daemons/main.c
@@ -73,6 +73,7 @@ static int port = RG_PORT;
 static char *rgmanager_lsname = "rgmanager"; /* XXX default */
 static int status_poll_interval = DEFAULT_CHECK_INTERVAL;
 static int stops_queued = 0;
+static int lastqver = 0;
 
 int next_node_id(cluster_member_list_t *membership, int me);
 
@@ -750,7 +751,7 @@ dump_internal_state(int fd)
 int
 event_loop(msgctx_t *localctx, msgctx_t *clusterctx)
 {
-	int n = 0, max, ret, oldver, newver;
+	int n = 0, max, ret, oldver = 0, newver = 0;
 	fd_set rfds;
 	msgctx_t *newctx;
 	struct timeval tv;
@@ -826,9 +827,14 @@ event_loop(msgctx_t *localctx, msgctx_t *clusterctx)
 		return 0;
 
 	if (need_reconfigure || check_config_update(&oldver, &newver)) {
+		/* Only queue configuration events once per detected config update */
+		if (!need_reconfigure && newver <= lastqver)
+			return 0;
+
 		need_reconfigure = 0;
 		configure_rgmanager(-1, 0, NULL);
 		config_event_q(oldver, newver);
+		lastqver = newver;
 		return 0;
 	}
 
-- 
1.8.1.2

From swhiteho@redhat.com Tue Feb 26 14:33:54 2013
Received: from int-mx11.intmail.prod.int.phx2.redhat.com
	(int-mx11.intmail.prod.int.phx2.redhat.com [10.5.11.24])
	by lists01.pubmisc.prod.ext.phx2.redhat.com (8.13.8/8.13.8) with ESMTP
	id r1QJXsoE014842 for <cluster-devel@listman.util.phx.redhat.com>;
	Tue, 26 Feb 2013 14:33:54 -0500
Received: from [10.10.55.55] (vpn-55-55.rdu2.redhat.com [10.10.55.55])
	by int-mx11.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with ESMTP
	id r1QJXrCN030042
	for <cluster-devel@redhat.com>; Tue, 26 Feb 2013 14:33:54 -0500
From: Steven Whitehouse <swhiteho@redhat.com>
To: cluster-devel@redhat.com
Content-Type: text/plain; charset="UTF-8"
Organization: Red Hat UK Ltd
Date: Tue, 26 Feb 2013 19:32:21 +0000
Message-ID: <1361907141.2705.31.camel@menhir>
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.24
X-loop: cluster-devel@redhat.com
Subject: [Cluster-devel] GFS2: Remove gfs2_refresh_inode from inode creation
	path
X-BeenThere: cluster-devel@redhat.com
X-Mailman-Version: 2.1.12
Precedence: junk
List-Id: "\[Cluster devel\]" <cluster-devel.redhat.com>
List-Unsubscribe: <https://www.redhat.com/mailman/options/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=unsubscribe>
List-Archive: <https://www.redhat.com/archives/cluster-devel>
List-Post: <mailto:cluster-devel@redhat.com>
List-Help: <mailto:cluster-devel-request@redhat.com?subject=help>
List-Subscribe: <https://www.redhat.com/mailman/listinfo/cluster-devel>,
	<mailto:cluster-devel-request@redhat.com?subject=subscribe>
X-List-Received-Date: Tue, 26 Feb 2013 19:33:55 -0000


The original method for creating inodes used in GFS2 was to fill
out a buffer, with all the information, and then to read that
buffer into the in-core inode, using gfs2_refresh_inode()

The problem with this approach is that all the inode's fields
need to be calculated ahead of time, and were stored in various
variables making the code rather complicated.

The new approach is simply to allocate the in-core inode earlier
and fill in as many fields as possible ahead of time. These can
then be used to initilise the on disk representation. The
code has been working towards the point where it is possible
to remove gfs2_refresh_inode() because all the fields are
correctly initialised ahead of time. We've now reached that
milestone, and have reversed the order of setting up the in
core and on disk inodes.

Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index cf35155..6e30fd1 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -1279,19 +1279,6 @@ void gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)
 		gfs2_glock_dq(&ghs[num_gh]);
 }
 
-/**
- * gfs2_glock_dq_uninit_m - release multiple glocks
- * @num_gh: the number of structures
- * @ghs: an array of struct gfs2_holder structures
- *
- */
-
-void gfs2_glock_dq_uninit_m(unsigned int num_gh, struct gfs2_holder *ghs)
-{
-	while (num_gh--)
-		gfs2_glock_dq_uninit(&ghs[num_gh]);
-}
-
 void gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state)
 {
 	unsigned long delay = 0;
diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.h
index fd580b7..69f66e3 100644
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@ -201,7 +201,6 @@ extern int gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,
 			     struct gfs2_holder *gh);
 extern int gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs);
 extern void gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs);
-extern void gfs2_glock_dq_uninit_m(unsigned int num_gh, struct gfs2_holder *ghs);
 extern int gfs2_dump_glock(struct seq_file *seq, const struct gfs2_glock *gl);
 #define GLOCK_BUG_ON(gl,x) do { if (unlikely(x)) { gfs2_dump_glock(NULL, gl); BUG(); } } while(0)
 extern __printf(2, 3)
diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c
index df51557..cb53b4f 100644
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@ -448,7 +448,6 @@ static void gfs2_init_dir(struct buffer_head *dibh,
 static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 			const char *symname, struct buffer_head **bhp)
 {
-	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct gfs2_dinode *di;
 	struct buffer_head *dibh;
 
@@ -465,7 +464,7 @@ static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 	di->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));
 	di->di_nlink = 0;
 	di->di_size = cpu_to_be64(ip->i_inode.i_size);
-	di->di_blocks = cpu_to_be64(1);
+	di->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));
 	di->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);
 	di->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);
 	di->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);
@@ -473,33 +472,23 @@ static void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,
 	di->di_minor = cpu_to_be32(MINOR(ip->i_inode.i_rdev));
 	di->di_goal_meta = di->di_goal_data = cpu_to_be64(ip->i_no_addr);
 	di->di_generation = cpu_to_be64(ip->i_generation);
-	di->di_flags = 0;
+	di->di_flags = cpu_to_be32(ip->i_diskflags);
 	di->__pad1 = 0;
 	di->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) ? GFS2_FORMAT_DE : 0);
-	di->di_height = 0;
+	di->di_height = cpu_to_be16(ip->i_height);
 	di->__pad2 = 0;
 	di->__pad3 = 0;
-	di->di_depth = 0;
-	di->di_entries = 0;
+	di->di_depth = cpu_to_be16(ip->i_depth);
+	di->di_entries = cpu_to_be32(ip->i_entries);
 	memset(&di->__pad4, 0, sizeof(di->__pad4));
-	di->di_eattr = 0;
+	di->di_eattr = cpu_to_be64(ip->i_eattr);
 	di->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);
 	di->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);
 	di->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);
 	memset(&di->di_reserved, 0, sizeof(di->di_reserved));
 
 	switch(ip->i_inode.i_mode & S_IFMT) {
-	case S_IFREG:
-		if ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||
-		    gfs2_tune_get(sdp, gt_new_files_jdata))
-			di->di_flags |= cpu_to_be32(GFS2_DIF_JDATA);
-		break;
 	case S_IFDIR:
-		di->di_flags |= cpu_to_be32(dip->i_diskflags &
-					    GFS2_DIF_INHERIT_JDATA);
-		di->di_flags |= cpu_to_be32(GFS2_DIF_JDATA);
-		di->di_size = cpu_to_be64(sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode));
-		di->di_entries = cpu_to_be32(2);
 		gfs2_init_dir(dibh, dip);
 		break;
 	case S_IFLNK:
@@ -516,15 +505,10 @@ static int link_dinode(struct gfs2_inode *dip, const struct qstr *name,
 		       struct gfs2_inode *ip, int arq)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
-	struct buffer_head *dibh;
 	int error;
 
-	error = gfs2_quota_lock(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);
-	if (error)
-		return error;
-
 	if (arq) {
-		error = gfs2_quota_check(dip, dip->i_inode.i_uid, dip->i_inode.i_gid);
+		error = gfs2_quota_lock_check(dip);
 		if (error)
 			goto fail_quota_locks;
 
@@ -548,14 +532,8 @@ static int link_dinode(struct gfs2_inode *dip, const struct qstr *name,
 	if (error)
 		goto fail_end_trans;
 
-	error = gfs2_meta_inode_buffer(ip, &dibh);
-	if (error)
-		goto fail_end_trans;
 	set_nlink(&ip->i_inode, S_ISDIR(ip->i_inode.i_mode) ? 2 : 1);
-	gfs2_trans_add_meta(ip->i_gl, dibh);
-	gfs2_dinode_out(ip, dibh->b_data);
-	brelse(dibh);
-	return 0;
+	mark_inode_dirty(&ip->i_inode);
 
 fail_end_trans:
 	gfs2_trans_end(sdp);
@@ -655,13 +633,33 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	if (error)
 		goto fail_free_inode;
 
-	set_bit(GIF_INVALID, &ip->i_flags);
 	inode->i_mode = mode;
 	inode->i_rdev = dev;
 	inode->i_size = size;
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	gfs2_set_inode_blocks(inode, 1);
 	munge_mode_uid_gid(dip, inode);
 	ip->i_goal = dip->i_goal;
+	ip->i_diskflags = 0;
+	ip->i_eattr = 0;
+	ip->i_height = 0;
+	ip->i_depth = 0;
+	ip->i_entries = 0;
+
+	switch(mode & S_IFMT) {
+	case S_IFREG:
+		if ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||
+		    gfs2_tune_get(sdp, gt_new_files_jdata))
+			ip->i_diskflags |= GFS2_DIF_JDATA;
+		gfs2_set_aops(inode);
+		break;
+	case S_IFDIR:
+		ip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);
+		ip->i_diskflags |= GFS2_DIF_JDATA;
+		ip->i_entries = 2;
+		break;
+	}
+	gfs2_set_inode_flags(inode);
 
 	if ((GFS2_I(sdp->sd_root_dir->d_inode) == dip) ||
 	    (dip->i_diskflags & GFS2_DIF_TOPDIR))
@@ -700,10 +698,6 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	gfs2_set_iop(inode);
 	insert_inode_hash(inode);
 
-	error = gfs2_inode_refresh(ip);
-	if (error)
-		goto fail_gunlock3;
-
 	error = gfs2_acl_create(dip, inode);
 	if (error)
 		goto fail_gunlock3;
@@ -716,14 +710,9 @@ static int gfs2_create_inode(struct inode *dir, struct dentry *dentry,
 	if (error)
 		goto fail_gunlock3;
 
-	if (bh)
-		brelse(bh);
-
-	gfs2_trans_end(sdp);
-	gfs2_inplace_release(dip);
-	gfs2_quota_unlock(dip);
-	mark_inode_dirty(inode);
-	gfs2_glock_dq_uninit_m(2, ghs);
+	brelse(bh);
+	gfs2_glock_dq_uninit(ghs);
+	gfs2_glock_dq_uninit(ghs + 1);
 	d_instantiate(dentry, inode);
 	return 0;
 
@@ -1126,7 +1115,9 @@ static int gfs2_symlink(struct inode *dir, struct dentry *dentry,
 
 static int gfs2_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
-	return gfs2_create_inode(dir, dentry, S_IFDIR | mode, 0, NULL, 0, 0);
+	struct gfs2_sbd *sdp = GFS2_SB(dir);
+	unsigned dsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode);
+	return gfs2_create_inode(dir, dentry, S_IFDIR | mode, 0, NULL, dsize, 0);
 }
 
 /**


